<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CNC AI - Heatmap â†’ G-code (Ù…ØµØ­Ø­)</title>
<style>
  :root{--bg:#f5f7fb;--card:#fff;--accent:#0b63c8}
  body{font-family:Arial,Helvetica,sans-serif;background:var(--bg);margin:0;color:#111}
  header{background:var(--accent);color:#fff;padding:12px 16px;text-align:center;font-size:1.05rem}
  .toolbar{display:flex;flex-wrap:wrap;gap:10px;padding:12px;align-items:center;justify-content:center;background:var(--card);border-bottom:1px solid #e6eefb}
  .toolbar input, .toolbar select, .toolbar button {padding:8px 10px;border-radius:6px;border:1px solid #cbdff6;background:var(--accent);color:#fff;cursor:pointer}
  .toolbar input[type=range]{appearance:none;height:6px;background:#ddd;border-radius:6px;cursor:pointer;width:140px;padding:0}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;padding:14px;max-width:1200px;margin:14px auto}
  .panel{background:var(--card);padding:12px;border-radius:8px;box-shadow:0 1px 6px rgba(16,40,80,.06)}
  canvas{display:block;max-width:100%;height:auto;border:1px solid #ddd}
  #threeContainer{height:480px;border:1px solid #ddd}
  .small{font-size:0.92rem}
  footer{padding:12px;text-align:center;color:#555}
  @media(max-width:900px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<header>ğŸ› ï¸ CNC AI â€” Heatmap & G-code (Ù…ØµØ­Ø­ Ù„Ù„Ø£Ø®Ø·Ø§Ø¡)</header>

<div class="toolbar">
  <input type="file" id="fileInput" accept="image/*"/>
  <label class="small">Colormap:
    <select id="colormap">
      <option value="jet">Jet</option>
      <option value="hot">Hot</option>
      <option value="cool">Cool</option>
      <option value="gray">Gray</option>
    </select>
  </label>

  <label class="small">ØªØ¨Ø§ÙŠÙ†:
    <input type="range" id="contrast" min="0.5" max="3" step="0.1" value="1"/>
  </label>

  <label class="small">Ø¹ØªØ¨Ø© Ø§Ù„Ø­ÙˆØ§Ù:
    <input type="range" id="edgeThreshold" min="1" max="255" value="40"/>
  </label>

  <label class="small">Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ (Ù…Ù…):
    <input type="range" id="maxDepth" min="0.5" max="20" step="0.1" value="5"/>
  </label>

  <label class="small">Ù…Ù…/Ø¨ÙƒØ³Ù„:
    <input type="number" id="mmPerPixel" step="0.1" value="0.5" style="width:90px;padding:6px;border-radius:6px;border:1px solid #ccc;color:#111"/>
  </label>

  <label class="small"><input type="checkbox" id="invertZ"/> Ø§Ù†Ø¹ÙƒØ§Ø³ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹</label>
  <label class="small"><input type="checkbox" id="flipY"/> Ù‚Ù„Ø¨ Y ÙÙŠ G-code</label>

  <button id="btnProcess">Ù…Ø¹Ø§Ù„Ø¬Ø©</button>
  <button id="btnPreview3D">Ù…Ø¹Ø§ÙŠÙ†Ø© 3D</button>
  <button id="btnGcode">ØªÙˆÙ„ÙŠØ¯ G-code</button>
</div>

<div class="grid">
  <div class="panel">
    <h3>Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</h3>
    <canvas id="canvasOriginal"></canvas>
  </div>

  <div class="panel">
    <h3>Heatmap (Colormap & Contrast)</h3>
    <canvas id="canvasHeatmap"></canvas>
  </div>

  <div class="panel">
    <h3>Ø­ÙˆØ§Ù (Edges)</h3>
    <canvas id="canvasEdges"></canvas>
  </div>

  <div class="panel">
    <h3>Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</h3>
    <div id="threeContainer"></div>
  </div>
</div>

<footer class="small">ØªÙ†Ø¨ÙŠÙ‡: Ø¹Ù†Ø¯ Ø±ÙØ¹ ØµÙˆØ±Ø© ÙƒØ¨ÙŠØ±Ø© Ø³ÙŠØªÙ… ØªØµØºÙŠØ±Ù‡Ø§ Ù…Ø¤Ù‚ØªÙ‹Ø§ Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…ØªØµÙØ­).</footer>

<!-- three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
/* ===== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ£ØµÙˆÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ===== */
const fileInput = document.getElementById('fileInput');
const canvasOriginal = document.getElementById('canvasOriginal'), ctxOrig = canvasOriginal.getContext('2d');
const canvasHeatmap = document.getElementById('canvasHeatmap'), ctxHeat = canvasHeatmap.getContext('2d');
const canvasEdges = document.getElementById('canvasEdges'), ctxEdges = canvasEdges.getContext('2d');

const colormapSel = document.getElementById('colormap');
const contrastR = document.getElementById('contrast');
const edgeThresholdR = document.getElementById('edgeThreshold');
const maxDepthR = document.getElementById('maxDepth');
const mmPerPixelInput = document.getElementById('mmPerPixel');
const invertZChk = document.getElementById('invertZ');
const flipYChk = document.getElementById('flipY');

const btnProcess = document.getElementById('btnProcess');
const btnPreview3D = document.getElementById('btnPreview3D');
const btnGcode = document.getElementById('btnGcode');

let imgW=0, imgH=0;           // original image size
let procW=0, procH=0;         // processing size (downsampled)
let rawImageData=null;
let gray=null, blurred=null, edges=null, heightMap=null;
let binMap = null; // binary edge map used for tracing

const MAX_PROC_DIM = 512; // Ø£Ù‚ØµÙ‰ Ø¨Ø¹Ø¯ Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (Ù„ØªÙØ§Ø¯ÙŠ Ø§Ù„ØªØ¬Ù…Ù‘Ø¯)
const MAX_SUBDIV = 128;   // Ø£Ù‚ØµÙ‰ subdivs Ù„Ù„Ù€3D (Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø©)

/* ===== ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© ÙˆØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ ===== */
fileInput.addEventListener('change', handleFile);
function handleFile(e){
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = ev=>{
    const img = new Image();
    img.onload = ()=>{
      imgW = img.width; imgH = img.height;
      canvasOriginal.width = imgW; canvasOriginal.height = imgH;
      ctxOrig.clearRect(0,0,imgW,imgH);
      ctxOrig.drawImage(img,0,0);
      rawImageData = ctxOrig.getImageData(0,0,imgW,imgH);
      ctxHeat.clearRect(0,0,canvasHeatmap.width, canvasHeatmap.height);
      ctxEdges.clearRect(0,0,canvasEdges.width, canvasEdges.height);
      if(Math.max(imgW,imgH) > MAX_PROC_DIM){
        alert('ØªØ­Ø°ÙŠØ±: Ø§Ù„ØµÙˆØ±Ø© ÙƒØ¨ÙŠØ±Ø© ÙˆØ³ÙŠØªÙ… ØªØµØºÙŠØ±Ù‡Ø§ Ù…Ø¤Ù‚ØªÙ‹Ø§ Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…ØªØµÙØ­).');
      }
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(f);
}

/* ===== Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© ===== */
btnProcess.addEventListener('click', ()=>{ processImage(); });

function processImage(){
  if(!rawImageData){ alert('Ø£Ø±ÙØ¹ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹'); return false; }

  const scale = Math.min(1, MAX_PROC_DIM / Math.max(imgW, imgH));
  procW = Math.max(2, Math.floor(imgW * scale));
  procH = Math.max(2, Math.floor(imgH * scale));

  const tmp = document.createElement('canvas'); tmp.width = procW; tmp.height = procH;
  tmp.getContext('2d').drawImage(canvasOriginal, 0,0, imgW, imgH, 0,0, procW, procH);
  const id = tmp.getContext('2d').getImageData(0,0,procW,procH);

  // grayscale Ù…Ø¹ ØªØ¨Ø§ÙŠÙ† (Ù…Ù„Ø§Ø­Ø¸Ø©: gr Ø¨Ø¯Ù„ g Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø§Ù„ØªØ¨Ø§Ø³)
  const contrast = parseFloat(contrastR.value) || 1;
  gray = new Float32Array(procW*procH);
  for(let i=0,j=0;i<id.data.length;i+=4,j++){
    const r = id.data[i], gr = id.data[i+1], b = id.data[i+2];
    let v = 0.299*r + 0.587*gr + 0.114*b;
    v = 128 + contrast*(v - 128);
    if(v<0) v=0; if(v>255) v=255;
    gray[j] = v;
  }

  blurred = gaussianBlur(gray, procW, procH);
  edges = sobelMag(blurred, procW, procH);

  // heightMap combine
  const edgeBoost = 1.5;
  heightMap = new Float32Array(procW*procH);
  let mn = Infinity, mx = -Infinity;
  for(let i=0;i<procW*procH;i++){
    const v = blurred[i] + edges[i]*edgeBoost;
    heightMap[i] = v;
    if(v < mn) mn = v;
    if(v > mx) mx = v;
  }
  const denom = (mx - mn) || 1;
  for(let i=0;i<procW*procH;i++) heightMap[i] = (heightMap[i] - mn) / denom;

  // heatmap Ù„Ù„Ø¹Ø±Ø¶
  drawHeatmap(heightMap, procW, procH, colormapSel.value);

  // binary edges
  let maxE = 0; for(let i=0;i<edges.length;i++) if(edges[i] > maxE) maxE = edges[i];
  const thr = parseFloat(edgeThresholdR.value) || 40;
  const bin = new Uint8Array(procW*procH);
  for(let i=0;i<procW*procH;i++){
    const v = edges[i] / (maxE || 1) * 255;
    bin[i] = (v >= thr) ? 1 : 0;
  }
  binMap = {w: procW, h: procH, data: bin};
  drawBinaryToCanvas(bin, procW, procH, canvasEdges, ctxEdges, imgW, imgH);

  alert('ØªÙ…Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© â€” Heatmap ÙˆEdges Ø¬Ø§Ù‡Ø²ØªØ§Ù†.');
  return true;
}

/* ===== Gaussian & Sobel (ÙƒÙ…Ø§ Ù‚Ø¨Ù„) ===== */
function gaussianBlur(src, w, h){
  const kernel = [
    [1,4,7,4,1],[4,16,26,16,4],[7,26,41,26,7],[4,16,26,16,4],[1,4,7,4,1]
  ];
  const weight = 273;
  const out = new Float32Array(w*h);
  for(let y=2;y<h-2;y++){
    for(let x=2;x<w-2;x++){
      let s=0;
      for(let ky=-2; ky<=2; ky++){
        for(let kx=-2; kx<=2; kx++){
          s += src[(y+ky)*w + (x+kx)] * kernel[ky+2][kx+2];
        }
      }
      out[y*w + x] = s/weight;
    }
  }
  for(let x=0;x<w;x++){ out[x] = src[x]; out[(h-1)*w + x] = src[(h-1)*w + x]; }
  for(let y=0;y<h;y++){ out[y*w] = src[y*w]; out[y*w + (w-1)] = src[y*w + (w-1)]; }
  return out;
}
function sobelMag(src, w, h){
  const out = new Float32Array(w*h);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const a = src[(y-1)*w + (x-1)], b = src[(y-1)*w + x], c = src[(y-1)*w + (x+1)];
      const d = src[y*w + (x-1)], e = src[y*w + x], f = src[y*w + (x+1)];
      const g = src[(y+1)*w + (x-1)], h2 = src[(y+1)*w + x], i = src[(y+1)*w + (x+1)];
      const gx = (c + 2*f + i) - (a + 2*d + g);
      const gy = (g + 2*h2 + i) - (a + 2*b + c);
      out[y*w + x] = Math.sqrt(gx*gx + gy*gy);
    }
  }
  return out;
}

/* ===== Colormaps + drawHeatmap ===== */
function drawHeatmap(hmap, w, h, cmap){
  const img = new ImageData(w,h);
  for(let i=0;i<w*h;i++){
    const t = clamp(hmap[i],0,1);
    let col;
    switch(cmap){
      case 'jet': col = colormapJet(t); break;
      case 'hot': col = colormapHot(t); break;
      case 'cool': col = colormapCool(t); break;
      default: col = colormapGray(t); break;
    }
    img.data[i*4] = col.r; img.data[i*4+1] = col.g; img.data[i*4+2] = col.b; img.data[i*4+3] = 255;
  }
  const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
  tmp.getContext('2d').putImageData(img,0,0);
  canvasHeatmap.width = imgW; canvasHeatmap.height = imgH;
  ctxHeat.clearRect(0,0,canvasHeatmap.width, canvasHeatmap.height);
  ctxHeat.drawImage(tmp,0,0, imgW, imgH);
}
function colormapJet(t){ t = clamp(t,0,1); const r = clamp(Math.min(1, 1.5*(t-0.66)),0,1); const g = clamp(Math.min(1, 1.5*(1 - Math.abs(t-0.5))),0,1); const b = clamp(Math.min(1, 1.5*(0.66 - t)),0,1); return {r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255)}; }
function colormapHot(t){ t = clamp(t,0,1); let r = Math.min(1, 3*t); let g = Math.min(1, Math.max(0, 3*t-1)); let b = Math.min(1, Math.max(0, 3*t-2)); return {r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255)}; }
function colormapCool(t){ t = clamp(t,0,1); return {r: Math.round(255*(1-t)), g: Math.round(255*t), b: 255}; }
function colormapGray(t){ t = clamp(t,0,1); const v = Math.round(255*t); return {r:v,g:v,b:v}; }
function clamp(v,a,b){ return v<a? a: (v>b? b: v); }

/* ===== drawBinaryToCanvas (edges display) ===== */
function drawBinaryToCanvas(bin, w, h, canvasOut, ctxOut, outW, outH){
  const img = new ImageData(w,h);
  for(let i=0;i<w*h;i++){
    const v = bin[i] ? 255 : 0;
    img.data[i*4] = v; img.data[i*4+1] = v; img.data[i*4+2] = v; img.data[i*4+3] = 255;
  }
  const tmp = document.createElement('canvas'); tmp.width = w; tmp.height = h;
  tmp.getContext('2d').putImageData(img,0,0);
  canvasOut.width = outW; canvasOut.height = outH;
  ctxOut.clearRect(0,0,canvasOut.width, canvasOut.height);
  ctxOut.drawImage(tmp, 0,0, outW, outH);
}

/* ===== ØªØªØ¨Ø¹ Ø§Ù„Ø­ÙˆØ§Ù (Moore) + ØªØ¨Ø³ÙŠØ· RDP ===== */
function traceContours(binMap){
  if(!binMap) return [];
  const w = binMap.w, h = binMap.h, data = binMap.data;
  const visited = new Uint8Array(w*h);
  const contours = [];
  const neigh = [[1,0],[1,-1],[0,-1],[-1,-1],[-1,0],[-1,1],[0,1],[1,1]];
  function inside(x,y){ return x>=0 && y>=0 && x<w && y<h; }

  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const idx = y*w + x;
      if(data[idx] && !visited[idx]){
        const contour = [];
        let sx=x, sy=y, cx=x, cy=y;
        let prevDir = 0;
        let safety = 0;
        do {
          contour.push([cx,cy]);
          visited[cy*w + cx] = 1;
          let found = false;
          let start = (prevDir + 6) % 8;
          for(let k=0;k<8;k++){
            const nd = (start + k) % 8;
            const nx = cx + neigh[nd][0], ny = cy + neigh[nd][1];
            if(inside(nx,ny) && data[ny*w + nx]){
              prevDir = nd;
              cx = nx; cy = ny;
              found = true; break;
            }
          }
          if(!found) break;
          safety++; if(safety > 20000) break;
        } while(!(cx===sx && cy===sy));
        if(contour.length >= 6) contours.push(contour);
      }
    }
  }
  return contours;
}

function simplifyRDP(points, eps){
  if(points.length < 3) return points.slice();
  function distSq(p,a,b){
    const dx = b[0]-a[0], dy = b[1]-a[1];
    if(dx===0 && dy===0) return (p[0]-a[0])**2 + (p[1]-a[1])**2;
    let t = ((p[0]-a[0])*dx + (p[1]-a[1])*dy) / (dx*dx + dy*dy);
    t = Math.max(0, Math.min(1, t));
    const px = a[0] + t*dx, py = a[1] + t*dy;
    return (p[0]-px)**2 + (p[1]-py)**2;
  }
  function rdp(pts, eps2){
    let maxd = -1, idx = -1;
    const A = pts[0], B = pts[pts.length-1];
    for(let i=1;i<pts.length-1;i++){
      const d = distSq(pts[i], A, B);
      if(d > maxd){ maxd = d; idx = i; }
    }
    if(maxd > eps2){
      const left = rdp(pts.slice(0, idx+1), eps2);
      const right = rdp(pts.slice(idx), eps2);
      return left.slice(0,-1).concat(right);
    } else {
      return [A,B];
    }
  }
  return rdp(points, eps*eps);
}

/* ===== ØªÙˆÙ„ÙŠØ¯ G-code Ù…Ù†_contours ===== */
btnGcode.addEventListener('click', ()=>{
  if(!binMap){ alert('Ø§Ø¶ØºØ· Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙˆÙ„Ø§Ù‹'); return; }
  const contours = traceContours(binMap);
  if(!contours || contours.length===0){ alert('Ù„Ù… ØªÙÙƒØªØ´Ù Ø­ÙˆØ§Ù Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ‚Ø·ÙŠØ¹'); return; }
  generateGcodeFromContours(contours);
});

function generateGcodeFromContours(contours){
  if(!contours || contours.length===0){ alert('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø­ÙˆØ§Ù'); return; }
  const mmPerPixel = parseFloat(mmPerPixelInput.value) || 0.5;
  const maxDepth = parseFloat(maxDepthR.value) || 5;
  const flipY = flipYChk.checked;
  const invertZ = invertZChk.checked;
  const feedCut = 300, feedMove = 1500;

  const lines = [];
  lines.push('G21 ; mm');
  lines.push('G90 ; absolute');
  lines.push('G0 Z5.000 F' + feedMove);

  for(const c of contours){
    const simp = simplifyRDP(c, 1.0);
    if(simp.length < 2) continue;
    const p0 = simp[0];
    const x0 = p0[0] * mmPerPixel;
    const y0 = (flipY ? p0[1] : (procH - 1 - p0[1])) * mmPerPixel;
    lines.push(`; contour start (${simp.length} pts)`);
    lines.push(`G0 X${x0.toFixed(3)} Y${y0.toFixed(3)} Z5.000 F${feedMove}`);
    // fix: zplunge sign depends on invertZ flag (default plunge = negative)
    const zplunge = invertZ ? (maxDepth) : (-maxDepth);
    lines.push(`G1 Z${zplunge.toFixed(3)} F${feedCut}`);
    for(let i=1;i<simp.length;i++){
      const p = simp[i];
      const xi = p[0] * mmPerPixel;
      const yi = (flipY ? p[1] : (procH - 1 - p[1])) * mmPerPixel;
      lines.push(`G1 X${xi.toFixed(3)} Y${yi.toFixed(3)} F${feedCut}`);
    }
    lines.push(`G0 Z5.000 F${feedMove}`);
  }

  lines.push('M30');

  const blob = new Blob([lines.join('\n')], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'cnc_edges.gcode'; a.click();
  URL.revokeObjectURL(url);
}

/* ===== Ù…Ø¹Ø§ÙŠÙ†Ø© 3D Ù…Ø­Ø³Ù†Ø© Ù„Ù„Ø£Ø¯Ø§Ø¡ ===== */
let threeCtx = {renderer:null, scene:null, camera:null, controls:null, mesh:null, linesGroup:null};
btnPreview3D.addEventListener('click', ()=>{ preview3D(); });

function preview3D(){
  if(!heightMap){ alert('Ø§Ø¶ØºØ· Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙˆÙ„Ø§Ù‹'); return; }
  const container = document.getElementById('threeContainer');
  const cw = container.clientWidth || 800, ch = container.clientHeight || 480;

  try {
    if(!threeCtx.renderer){
      threeCtx.renderer = new THREE.WebGLRenderer({antialias:true});
      threeCtx.renderer.setSize(cw,ch);
      container.innerHTML = '';
      container.appendChild(threeCtx.renderer.domElement);
      threeCtx.scene = new THREE.Scene();
      threeCtx.camera = new THREE.PerspectiveCamera(45, cw/ch, 0.1, 10000);
      threeCtx.controls = new THREE.OrbitControls(threeCtx.camera, threeCtx.renderer.domElement);
      threeCtx.controls.enableDamping = true;
      threeCtx.scene.add(new THREE.AmbientLight(0x999999));
      const dir = new THREE.DirectionalLight(0xffffff, 0.9);
      dir.position.set(100,200,300);
      threeCtx.scene.add(dir);
    } else {
      threeCtx.renderer.setSize(cw,ch);
    }

    // subdivisions limited
    let subsX = Math.min(procW, MAX_SUBDIV);
    let subsY = Math.max(2, Math.round(subsX * procH / procW));
    // safety: limit total verts
    const MAX_VERTS = 15000;
    while(subsX * subsY > MAX_VERTS){
      subsX = Math.max(2, Math.floor(subsX * 0.9));
      subsY = Math.max(2, Math.round(subsX * procH / procW));
    }

    // geometry
    const geometry = new THREE.PlaneBufferGeometry(procW, procH, subsX-1, subsY-1);
    const posAttr = geometry.getAttribute('position');
    const posArr = posAttr.array;
    const verts = subsX * subsY;
    const maxDepth = parseFloat(maxDepthR.value) || 5;
    const invertZ = invertZChk.checked ? -1 : 1;

    for(let i=0;i<verts;i++){
      const xi = i % subsX;
      const yi = Math.floor(i / subsX);
      const sx = Math.floor(xi/(subsX-1) * (procW-1));
      const sy = Math.floor(yi/(subsY-1) * (procH-1));
      const hv = heightMap[sy*procW + sx] || 0;
      const z = hv * maxDepth * invertZ;
      posArr[i*3 + 2] = z;
    }
    posAttr.needsUpdate = true;
    geometry.computeVertexNormals();

    // texture for mesh
    const texCanvas = document.createElement('canvas'); texCanvas.width = procW; texCanvas.height = procH;
    const tctx = texCanvas.getContext('2d');
    // draw downscaled heatmap into texture
    tctx.drawImage(canvasHeatmap, 0,0, procW, procH);
    const texture = new THREE.CanvasTexture(texCanvas);
    texture.flipY = true;

    const material = new THREE.MeshStandardMaterial({map: texture, side: THREE.DoubleSide});
    // dispose old
    if(threeCtx.mesh){
      threeCtx.scene.remove(threeCtx.mesh);
      try{ threeCtx.mesh.geometry.dispose(); threeCtx.mesh.material.dispose(); }catch(_){}
    }
    threeCtx.mesh = new THREE.Mesh(geometry, material);
    threeCtx.mesh.rotation.x = -Math.PI / 2;
    threeCtx.scene.add(threeCtx.mesh);

    if(threeCtx.linesGroup) { threeCtx.scene.remove(threeCtx.linesGroup); }
    const linesGroup = new THREE.Group();
    const contours = traceContours(binMap);
    const mat = new THREE.LineBasicMaterial({color: 0xffffff, linewidth: 1});
    for(const c of contours){
      const simp = simplifyRDP(c, 1.2);
      if(simp.length < 2) continue;
      const pts = [];
      for(const pt of simp){
        const x = pt[0] - procW/2;
        const y = -(pt[1] - procH/2);
        const hv = heightMap[pt[1]*procW + pt[0]] || 0;
        const z = hv * maxDepth * 1.02;
        pts.push(new THREE.Vector3(x, z, y));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const line = new THREE.Line(geom, mat);
      linesGroup.add(line);
    }
    threeCtx.linesGroup = linesGroup;
    threeCtx.scene.add(linesGroup);

    threeCtx.camera.position.set(0, Math.max(procW,procH)*0.9, Math.max(procW,procH)*0.9);
    threeCtx.camera.lookAt(0,0,0);

    (function animate(){
      requestAnimationFrame(animate);
      threeCtx.controls.update();
      threeCtx.renderer.render(threeCtx.scene, threeCtx.camera);
    })();

  } catch(err){
    console.error('Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯:', err);
    alert('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¹Ø§ÙŠÙ†Ø© 3D â€” Ø­Ø§ÙˆÙ„ ØªÙ‚Ù„ÙŠÙ„ Ø¯Ù‚Ø© Ø§Ù„ØµÙˆØ±Ø© Ø£Ùˆ Ù‚ÙŠÙ… Ø§Ù„Ø¯Ù‚Ø© (MAX_SUBDIV). ØªØ­Ù‚Ù‚ ÙˆØ­Ø¯Ø© Ø§Ù„ØªØ­ÙƒÙ… (Console) Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„ØªÙØ§ØµÙŠÙ„.');
  }
}

</script>
</body>
</html>
