<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <title>CNC AI â€” Ù…Ø¹Ø§ÙŠÙ†Ø§Øª Ùˆ G-code</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#fdfdfd; --card:#fff; --muted:#666; --accent:#4a90e2;
    }
    body{margin:0;font-family:Segoe UI,Arial,sans-serif;background:var(--bg);color:#222;direction:rtl}
    header{background:linear-gradient(90deg,var(--accent),#67b0f5);color:#fff;padding:14px 18px;text-align:center;position:relative}
    header h1{margin:0;font-size:18px}
    #themeToggle{position:absolute;left:14px;top:50%;transform:translateY(-50%);background:transparent;border:0;color:#fff;font-size:18px;cursor:pointer}
    .tabs{display:flex;gap:8px;justify-content:center;background:#f0f4fb;padding:10px;flex-wrap:wrap}
    .tabs button{border:0;padding:8px 14px;border-radius:8px;background:#e6eefc;cursor:pointer;font-weight:600}
    .tabs button.active{background:var(--accent);color:#fff}
    .container{max-width:1100px;margin:20px auto;padding:0 12px;display:grid;grid-template-columns:1fr;gap:18px}
    .row{display:flex;gap:18px;flex-wrap:wrap;align-items:flex-start}
    .card{background:var(--card);border-radius:10px;padding:12px;box-shadow:0 6px 18px rgba(0,0,0,0.06);width:100%}
    .file-center{display:flex;justify-content:center;padding:8px}
    input[type=file]{padding:8px;border-radius:8px;border:1px solid #ddd;background:#fff}
    .preview-grid{display:grid;grid-template-columns:1fr 420px;gap:18px}
    .preview-block{display:flex;flex-direction:column;align-items:center}
    canvas{max-width:100%;border-radius:8px;border:1px solid #ddd;background:#fff}
    #preview3d canvas{width:420px;height:420px;display:block}
    .controls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;margin-top:8px}
    label{font-size:13px;color:var(--muted)}
    input[type=range]{vertical-align:middle}
    .colormap-controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:8px}
    .colormap-controls button{padding:8px 12px;border-radius:8px;border:0;background:#f0f0f0;cursor:pointer;font-weight:600}
    .gcode-area{display:flex;flex-direction:column;gap:8px}
    textarea{width:100%;height:220px;padding:10px;border-radius:8px;border:1px solid #ddd;font-family:monospace;background:#fafafa;resize:vertical}
    .small{font-size:13px;color:var(--muted)}
    /* responsive */
    @media (max-width:980px){
      .preview-grid{grid-template-columns:1fr}
      #preview3d canvas{width:100%;height:300px}
    }
    body.dark{background:#111;color:#eee}
    body.dark .card{background:#1b1b1b}
    body.dark .tabs button{background:#2b2b2b;color:#ddd}
    body.dark .tabs button.active{background:#3b82f6;color:#fff}
  </style>
</head>
<body>
  <header>
    <h1>ğŸ› ï¸ CNC AI â€” Ù…Ø¹Ø§ÙŠÙ†Ø§Øª Ùˆ G-code</h1>
    <button id="themeToggle" title="ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø«ÙŠÙ…">ğŸŒ™</button>
  </header>

  <div class="tabs" role="tablist">
    <button class="active" id="tabPreviewBtn">ğŸ“· Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©</button>
    <button id="tabGcodeBtn">âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª G-code</button>
  </div>

  <div class="container">

    <!-- PREVIEW TAB (default) -->
    <div id="previewTab" class="card">
      <div class="file-center">
        <input id="fileInput" type="file" accept="image/*">
      </div>

      <div class="preview-grid">
        <div>
          <div class="preview-block card" style="padding:12px;">
            <div class="small">ğŸ“· Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</div>
            <canvas id="preview2d"></canvas>
          </div>

          <div class="preview-block card" style="margin-top:12px;">
            <div class="small">ğŸŒˆ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª (Heatmap)</div>
            <canvas id="heatmap"></canvas>
            <div class="colormap-controls" aria-label="colormap controls">
              <button data-map="jet">Jet</button>
              <button data-map="hot">Hot</button>
              <button data-map="cool">Cool</button>
              <button data-map="gray">Gray</button>
            </div>
          </div>
        </div>

        <div>
          <div class="preview-block card">
            <div class="small">ğŸŒ€ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</div>
            <div id="preview3d"></div>
            <div class="controls">
              <label>ğŸ”„ Ø³Ø±Ø¹Ø©:
                <input id="rotationSpeed" type="range" min="0" max="0.05" step="0.001" value="0.01">
              </label>
              <label>ğŸ” Ø²ÙˆÙ…:
                <input id="zoomControl" type="range" min="50" max="600" step="10" value="200">
              </label>
              <button id="toggleWire">Toggle Wire</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- G-CODE TAB -->
    <div id="gcodeTab" class="card" style="display:none">
      <h3 style="margin:6px 0">ØªÙˆÙ„ÙŠØ¯ G-code (Ù…Ø¹ Ù…Ø¹Ø§ÙŠÙ†Ø© 2D Ù„Ù…Ø³Ø§Ø±)</h3>
      <div class="gcode-area">
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <label class="small">Ø¹Ø±Ø¶ (Ù…Ù…): <input id="widthMm" type="number" value="100" style="width:110px"></label>
          <label class="small">Ø·ÙˆÙ„ (Ù…Ù…): <input id="heightMm" type="number" value="100" style="width:110px"></label>
          <label class="small">Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ (Ù…Ù…): <input id="depthMm" type="number" value="2" style="width:110px"></label>
        </div>

        <div style="display:flex;gap:8px">
          <button id="genG" class="action">âš™ï¸ ØªÙˆÙ„ÙŠØ¯</button>
          <button id="dlG" class="action">ğŸ’¾ ØªØ­Ù…ÙŠÙ„</button>
        </div>

        <textarea id="gcodeOutput" placeholder="Ø³ÙŠØ¸Ù‡Ø± Ø§Ù„ÙƒÙˆØ¯ Ù‡Ù†Ø§..." readonly></textarea>

        <div>
          <div class="small">Ù…Ø¹Ø§ÙŠÙ†Ø© 2D Ù„Ù…Ø³Ø§Ø± G-code</div>
          <canvas id="gcodeCanvas" width="640" height="400" style="border:1px solid #eee;border-radius:6px"></canvas>
        </div>
      </div>
    </div>

  </div>

  <!-- three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
  // ---------- Helpers & state ----------
  const fileInput = document.getElementById('fileInput');
  const preview2d = document.getElementById('preview2d');
  const ctx2d = preview2d.getContext('2d');
  const heatmap = document.getElementById('heatmap');
  const ctxHeat = heatmap.getContext('2d');
  const preview3d = document.getElementById('preview3d');

  const gcodeCanvas = document.getElementById('gcodeCanvas');
  const gctx = gcodeCanvas.getContext('2d');

  let heightData = null;     // 2D array normalized [0..1]
  let heightW = 0, heightH = 0;
  let currentColormap = 'jet';
  let mesh, renderer, scene, camera;
  let rotationSpeed = 0.01;
  let wireframe = false;

  // downsample large images to this max for mesh/heatmap to keep memory low
  const MAX_DIM = 240;

  // ---------- Theme toggle ----------
  const themeToggle = document.getElementById('themeToggle');
  themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark');
    themeToggle.textContent = document.body.classList.contains('dark') ? "â˜€ï¸" : "ğŸŒ™";
  });

  // ---------- Tabs ----------
  document.getElementById('tabPreviewBtn').addEventListener('click', () => {
    document.getElementById('previewTab').style.display = '';
    document.getElementById('gcodeTab').style.display = 'none';
    document.getElementById('tabPreviewBtn').classList.add('active');
    document.getElementById('tabGcodeBtn').classList.remove('active');
  });
  document.getElementById('tabGcodeBtn').addEventListener('click', () => {
    document.getElementById('previewTab').style.display = 'none';
    document.getElementById('gcodeTab').style.display = '';
    document.getElementById('tabPreviewBtn').classList.remove('active');
    document.getElementById('tabGcodeBtn').classList.add('active');
  });

  // ---------- Colormap buttons ----------
  document.querySelectorAll('.colormap-controls button').forEach(b=>{
    b.addEventListener('click', () => {
      currentColormap = b.dataset.map;
      if (heightData) drawHeatmap(heightData, heightW, heightH);
      if (mesh) applyVertexColors();
    });
  });

  // ---------- File load ----------
  fileInput.addEventListener('change', (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = () => {
      // draw 2D preview at natural size but constrained width
      preview2d.width = img.width; preview2d.height = img.height;
      ctx2d.clearRect(0,0,preview2d.width,preview2d.height);
      ctx2d.drawImage(img,0,0);

      // prepare downsampled image for height extraction
      const scale = Math.min(1, MAX_DIM / Math.max(img.width, img.height));
      heightW = Math.max(2, Math.floor(img.width * scale));
      heightH = Math.max(2, Math.floor(img.height * scale));
      const tmp = document.createElement('canvas'); tmp.width = heightW; tmp.height = heightH;
      const tctx = tmp.getContext('2d');
      tctx.drawImage(img, 0, 0, heightW, heightH);
      const rgba = tctx.getImageData(0,0,heightW,heightH).data;

      // build heightData normalized (0..1) using luminance
      heightData = new Array(heightH);
      for (let y=0;y<heightH;y++){
        const row = new Float32Array(heightW);
        for (let x=0;x<heightW;x++){
          const i = (y*heightW + x) * 4;
          // convert to luminance (more robust than single channel)
          const r=rgba[i], g=rgba[i+1], b=rgba[i+2];
          const lum = (0.299*r + 0.587*g + 0.114*b) / 255;
          row[x] = lum;
        }
        heightData[y] = row;
      }

      // draw heatmap and 3D
      drawHeatmap(heightData, heightW, heightH);
      create3DMesh(heightData, heightW, heightH);
      URL.revokeObjectURL(url);
    };
    img.src = url;
  });

  // ---------- Heatmap rendering ----------
  function getHeatColor(value, map){
    // value in [0..1]
    value = Math.max(0, Math.min(1, value));
    let r=0,g=0,b=0;
    if(map==='jet'){
      r = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-3),1),0));
      g = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-2),1),0));
      b = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-1),1),0));
    } else if(map==='hot'){
      r = Math.floor(255 * Math.min(1, 3*value));
      g = Math.floor(255 * Math.min(1, 3*value-1)); g = Math.max(g,0);
      b = Math.floor(255 * Math.min(1, 3*value-2)); b = Math.max(b,0);
    } else if(map==='cool'){
      r = Math.floor(255 * value);
      g = Math.floor(255 * (1-value));
      b = 255;
    } else { // gray
      r = g = b = Math.floor(255 * value);
    }
    return {r,g,b};
  }

  function drawHeatmap(hData, w, h){
    // prepare imageData at native resolution then upscale to canvas to keep crispness
    const img = ctxHeat.createImageData(w,h);
    // compute min/max for contrast stretch
    let min=1, max=0;
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const v=hData[y][x];
        if (v<min) min=v;
        if (v>max) max=v;
      }
    }
    const span = (max-min) || 1;
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const i=(y*w+x)*4;
        const norm = (hData[y][x] - min) / span;
        const c = getHeatColor(norm, currentColormap);
        img.data[i]=c.r; img.data[i+1]=c.g; img.data[i+2]=c.b; img.data[i+3]=255;
      }
    }
    // put on a temp canvas then scale to displayed canvas to enlarge while keeping pixel mapping
    const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h;
    tmp.getContext('2d').putImageData(img,0,0);

    // compute display size to fit layout while keeping aspect
    const maxDisplayW = Math.min(420, window.innerWidth - 80);
    let dispW = Math.round(maxDisplayW);
    let dispH = Math.round((h / w) * dispW);
    heatmap.width = dispW; heatmap.height = dispH;
    ctxHeat.imageSmoothingEnabled = false;
    ctxHeat.clearRect(0,0,heatmap.width,heatmap.height);
    ctxHeat.drawImage(tmp, 0, 0, dispW, dispH);
  }

  // ---------- 3D: initialize scene on first use ----------
  function ensure3D(){
    if (renderer) return;
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, 1, 0.1, 2000);
    renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(420,420);
    preview3d.innerHTML = '';
    preview3d.appendChild(renderer.domElement);

    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(0,1,1).normalize();
    scene.add(dir);
    const amb = new THREE.AmbientLight(0xffffff,0.4);
    scene.add(amb);

    camera.position.set(0, -140, 120);
    camera.lookAt(0,0,0);

    // simple orbit via mouse: minimal handling to avoid adding OrbitControls lib
    let isDown=false, lastX=0, lastY=0;
    preview3d.addEventListener('pointerdown', e=>{isDown=true; lastX=e.clientX; lastY=e.clientY;});
    window.addEventListener('pointerup', ()=>isDown=false);
    window.addEventListener('pointermove', (e)=>{
      if(!isDown) return;
      const dx = (e.clientX - lastX); const dy = (e.clientY - lastY);
      lastX = e.clientX; lastY = e.clientY;
      if (mesh) mesh.rotation.y += dx * 0.01;
      if (mesh) mesh.rotation.x += dy * 0.01;
    });
  }

  function create3DMesh(hData, w, h){
    ensure3D();

    // reduce resolution if too big
    const step = Math.ceil(Math.max(1, Math.max(w,h)/MAX_DIM));
    const cols = Math.ceil(w/step);
    const rows = Math.ceil(h/step);

    // geometry plane of size 160 x 160 (arbitrary), with cols-1 and rows-1 segments
    const size = 160;
    const geometry = new THREE.PlaneGeometry(size, size, cols-1, rows-1);
    // fill z positions using downsampled heights
    for (let j=0;j<rows;j++){
      for (let i=0;i<cols;i++){
        const vx = i, vy = j;
        const idx = j*cols + i;
        const xSrc = Math.min(w-1, i*step);
        const ySrc = Math.min(h-1, j*step);
        const val = hData[ySrc][xSrc];
        const z = (val - 0.5) * 60; // center and scale
        geometry.attributes.position.setZ(idx, z);
      }
    }

    geometry.computeVertexNormals();

    // vertex colors from current colormap
    const colors = [];
    for (let j=0;j<rows;j++){
      for (let i=0;i<cols;i++){
        const xSrc = Math.min(w-1, i*step);
        const ySrc = Math.min(h-1, j*step);
        const v = hData[ySrc][xSrc];
        const c = getHeatColor(v, currentColormap);
        colors.push(c.r/255, c.g/255, c.b/255);
      }
    }
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    const mat = new THREE.MeshLambertMaterial({vertexColors:true, side:THREE.DoubleSide, wireframe:wireframe});
    if (mesh) { scene.remove(mesh); mesh.geometry.dispose(); mesh.material.dispose(); mesh = null; }
    mesh = new THREE.Mesh(geometry, mat);
    mesh.rotation.x = -Math.PI/2; // lay flat with Y up
    scene.add(mesh);
  }

  function applyVertexColors(){
    if (!mesh) return;
    const geom = mesh.geometry;
    // geom attribute size equals (cols*rows). We'll map using existing heightData sampling logic
    const pos = geom.attributes.position;
    const count = pos.count;
    const colors = [];
    for (let i=0;i<count;i++){
      // map geometry vertex index to a sample from heightData via nearest projection
      // rough approach: map i to u,v using geometry parameters (works for PlaneGeometry created above)
      // PlaneGeometry indexes positions in grid order; infer cols/rows:
      const segmentsX = geom.parameters.widthSegments + 1;
      const ix = i % segmentsX;
      const iy = Math.floor(i / segmentsX);
      // map ix,iy back to heightData coordinates
      const xSrc = Math.min(heightW-1, Math.floor(ix * (heightW / segmentsX)));
      const ySrc = Math.min(heightH-1, Math.floor(iy * (heightH / (geom.parameters.heightSegments + 1))));
      const v = heightData[ySrc][xSrc];
      const c = getHeatColor(v, currentColormap);
      colors.push(c.r/255, c.g/255, c.b/255);
    }
    geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    geom.attributes.color.needsUpdate = true;
  }

  // animation loop
  function animate3D(){
    requestAnimationFrame(animate3D);
    if (mesh) { mesh.rotation.y += rotationSpeed; }
    if (renderer && camera) renderer.render(scene, camera);
  }
  animate3D();

  // controls handlers
  document.getElementById('rotationSpeed').addEventListener('input', (e)=> rotationSpeed = parseFloat(e.target.value));
  document.getElementById('zoomControl').addEventListener('input', (e)=>{
    const z = parseFloat(e.target.value);
    if (camera) camera.position.set(0, -z*0.7, z*0.9);
  });
  document.getElementById('toggleWire').addEventListener('click', ()=>{
    wireframe = !wireframe;
    if (mesh) mesh.material.wireframe = wireframe;
  });

  // ---------- G-code generation (simple height-based simulation) ----------
  let latestGcode = '';
  document.getElementById('genG').addEventListener('click', generateGcode);
  document.getElementById('dlG').addEventListener('click', downloadGcode);

  function generateGcode(){
    if (!heightData) { alert('Ø§Ø±ÙØ¹ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹ ÙÙŠ ØªØ¨ÙˆÙŠØ¨ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©'); return; }
    const width = parseFloat(document.getElementById('widthMm').value) || 100;
    const height = parseFloat(document.getElementById('heightMm').value) || 100;
    const maxDepth = parseFloat(document.getElementById('depthMm').value) || 2;

    // map heightData to grid with pixelSize
    const px = width / heightW;
    const py = height / heightH;

    // simple serpentine raster
    const lines = [];
    lines.push('(Generated by CNC AI)');
    lines.push('G21');
    lines.push('G90');
    lines.push('M3 S12000');
    lines.push('G0 Z5');

    const pathPoints = [];
    for (let y=0;y<heightH;y++){
      const y_mm = (y) * py;
      if (y % 2 === 0) {
        for (let x=0;x<heightW;x++){
          const val = heightData[y][x]; // 0..1
          const depth = (1 - val) * maxDepth; // darker -> deeper
          const z = -depth;
          const x_mm = x * px;
          lines.push(`G0 X${x_mm.toFixed(3)} Y${y_mm.toFixed(3)}`);
          lines.push(`G1 Z${z.toFixed(3)} F300`);
          pathPoints.push({x:x_mm,y:y_mm});
        }
      } else {
        for (let x=heightW-1;x>=0;x--){
          const val = heightData[y][x];
          const depth = (1 - val) * maxDepth;
          const z = -depth;
          const x_mm = x * px;
          lines.push(`G0 X${x_mm.toFixed(3)} Y${y_mm.toFixed(3)}`);
          lines.push(`G1 Z${z.toFixed(3)} F300`);
          pathPoints.push({x:x_mm,y:y_mm});
        }
      }
      lines.push('G0 Z5');
    }

    lines.push('M5');
    lines.push('M30');
    latestGcode = lines.join('\n');
    document.getElementById('gcodeOutput').value = latestGcode;

    // draw path preview scaled to canvas
    drawGcodePathPreview(pathPoints, width, height);
  }

  function drawGcodePathPreview(points, widthMM, heightMM){
    const c = gcodeCanvas;
    const ctx = gctx;
    ctx.clearRect(0,0,c.width,c.height);
    if (!points || points.length===0) return;
    // compute margins and scaling
    const padding = 20;
    const scaleX = (c.width - padding*2) / widthMM;
    const scaleY = (c.height - padding*2) / heightMM;
    ctx.beginPath();
    ctx.strokeStyle = '#1677ff';
    ctx.lineWidth = 1.2;
    // move to first
    ctx.moveTo(padding + points[0].x * scaleX, padding + points[0].y*scaleY);
    for (let i=1;i<points.length;i++){
      const p = points[i];
      ctx.lineTo(padding + p.x*scaleX, padding + p.y*scaleY);
    }
    ctx.stroke();
  }

  function downloadGcode(){
    if (!latestGcode) { alert('Ù…Ù† ÙØ¶Ù„Ùƒ Ø§Ø¶ØºØ· ØªÙˆÙ„ÙŠØ¯ Ø£ÙˆÙ„Ø§Ù‹'); return; }
    const blob = new Blob([latestGcode], {type:'text/plain'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'cnc_output.gcode';
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // ---------- small safety/resize handling ----------
  window.addEventListener('resize', ()=> {
    if (heightData) drawHeatmap(heightData, heightW, heightH);
    // adjust renderer size
    if (renderer) {
      const size = Math.min(420, Math.floor(window.innerWidth*0.45));
      renderer.setSize(size, size);
      if (camera) camera.aspect = 1; camera.updateProjectionMatrix();
    }
  });

  </script>
</body>
</html>
