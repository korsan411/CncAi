<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CNC AI - Laser Gcode Fixed</title>
  <style>
    :root {
      --bg-dark: #0e0e0e;
      --bg-light: #f5f5f5;
      --text-light: #eaeaea;
      --accent: #00ffc3;
      --accent2: #ff8800;
    }
    body {
      margin: 0;
      font-family: "Cairo", sans-serif;
      background: var(--bg-dark);
      color: var(--text-light);
      overflow-x: hidden;
      text-align: center;
    }
    header {
      padding: 10px 0;
      background: linear-gradient(90deg, #1a1a1a, #111);
      color: var(--accent);
      font-size: 1.3em;
      font-weight: 600;
      border-bottom: 2px solid var(--accent2);
      text-shadow: 0 0 10px var(--accent);
    }
    main {
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    .canvas-container {
      position: relative;
      display: inline-block;
    }
    canvas {
      max-width: 100%;
      border: 1px solid #333;
      border-radius: 10px;
      background-color: #000;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
    }
    button {
      padding: 10px 15px;
      border-radius: 8px;
      border: none;
      background: var(--accent2);
      color: #000;
      font-weight: 600;
      cursor: pointer;
      transition: 0.3s;
    }
    button:hover {
      background: var(--accent);
      color: #000;
      transform: scale(1.05);
    }
    #progressBarFixed {
      width: 0%;
      height: 4px;
      background: var(--accent);
      transition: width 0.4s ease;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 9999;
    }
    #operationStatusFixed {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 0.9em;
      background: rgba(0, 0, 0, 0.7);
      color: var(--accent);
      z-index: 9999;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <header>CNC AI â€” Ù†Ø³Ø®Ø© Ø§Ù„Ù„ÙŠØ²Ø± Ø§Ù„Ù…ØµØ­Ø­Ø©</header>
  <div id="progressBarFixed"></div>
  <div id="operationStatusFixed">Ø¬Ø§Ù‡Ø²</div>

  <main>
    <div class="controls">
      <input type="file" id="fileInput" accept="image/*">
      <button id="detectBtn">ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù</button>
      <button id="gcodeBtn">ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠØ²Ø±</button>
    </div>
    <div class="canvas-container">
      <canvas id="imageCanvas"></canvas>
    </div>
  </main>
<script>
let src, gray, edges;
let contoursData = { mask: null, gray: null, boundingBox: null };

// âœ… ØªØ­Ù…ÙŠÙ„ OpenCV.js
function loadOpenCv() {
  if (typeof cv === 'undefined') {
    const script = document.createElement('script');
    script.src = "https://docs.opencv.org/4.x/opencv.js";
    script.onload = () => {
      console.log("ØªÙ… ØªØ­Ù…ÙŠÙ„ OpenCV Ø¨Ù†Ø¬Ø§Ø­");
      updateStatusFixed("âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ OpenCV Ø¨Ù†Ø¬Ø§Ø­", "success");
    };
    document.body.appendChild(script);
  } else {
    console.log("OpenCV Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ù‹Ø§");
  }
}
loadOpenCv();

// âœ… ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ´ØºÙŠÙ„
function updateStatusFixed(text, type = "info") {
  const el = document.getElementById('operationStatusFixed');
  if (!el) return;
  el.textContent = text;
  el.style.color = type === "error" ? "#ff5555" : (type === "success" ? "#00ffae" : "#ffaa00");
}

// âœ… ØªØ­Ø¯ÙŠØ« Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù…
function setProgressFixed(percent) {
  const bar = document.getElementById('progressBarFixed');
  if (bar) bar.style.width = percent + "%";
}

// âœ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„ÙƒØ§Ù†ÙØ§Ø³
document.getElementById('fileInput').addEventListener('change', function (e) {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = function () {
    const canvas = document.getElementById('imageCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);
    updateStatusFixed("ğŸ“· ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©");
  };
  img.src = URL.createObjectURL(file);
});

// âœ… ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù
document.getElementById('detectBtn').addEventListener('click', async () => {
  if (typeof cv === 'undefined') {
    updateStatusFixed("âš ï¸ OpenCV Ù„Ù… ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡ Ø¨Ø¹Ø¯", "error");
    return;
  }

  const canvas = document.getElementById('imageCanvas');
  if (!canvas.width) {
    updateStatusFixed("âš ï¸ ÙŠØ±Ø¬Ù‰ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹", "error");
    return;
  }

  setProgressFixed(10);
  updateStatusFixed("ğŸ” Ø¬Ø§Ø±ÙŠ ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù...", "loading");

  const srcMat = cv.imread(canvas);
  gray = new cv.Mat();
  cv.cvtColor(srcMat, gray, cv.COLOR_RGBA2GRAY, 0);
  edges = new cv.Mat();
  cv.Canny(gray, edges, 100, 200);

  const mask = edges.clone();
  contoursData.mask = mask.clone();
  contoursData.gray = gray.clone();
  contoursData.boundingBox = { x: 0, y: 0, width: mask.cols, height: mask.rows };

  cv.imshow(canvas, edges);
  updateStatusFixed("âœ… ØªÙ… ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ø¨Ù†Ø¬Ø§Ø­", "success");
  setProgressFixed(100);

  srcMat.delete();
  edges.delete();
});

</script>

<script>
// âœ… Ø¯Ø§Ù„Ø© ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠØ²Ø± Ø§Ù„Ø¢Ù…Ù†Ø©
document.getElementById('gcodeBtn')?.addEventListener('click', () => {
  if (!window.contoursData?.mask) {
    updateStatusFixed('âš ï¸ ÙŠØ¬Ø¨ Ø£ÙˆÙ„Ø§Ù‹ ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ù‚Ø¨Ù„ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙƒÙˆØ¯', 'error');
    console.warn('Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„ÙƒÙˆØ¯ - Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø­ÙˆØ§Ù');
    return;
  }

  updateStatusFixed('âš™ï¸ Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠØ²Ø±...', 'loading');
  setProgressFixed(20);

  setTimeout(() => {
    const gcode = generateLaserGcodeSafe({
      mask: contoursData.mask,
      boundingBox: contoursData.boundingBox,
      gray: contoursData.gray
    });

    if (gcode && gcode.length > 0) {
      window.latestGcode = gcode;
      updateStatusFixed('âœ… ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠØ²Ø± Ø¨Ù†Ø¬Ø§Ø­', 'success');
      setProgressFixed(100);
      console.log("âœ… G-code generated successfully");
      console.log(gcode);
    } else {
      updateStatusFixed('âŒ Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ ØµØ§Ù„Ø­', 'error');
      setProgressFixed(0);
      console.warn('Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ ØµØ§Ù„Ø­');
    }
  }, 200);
});

// âœ… Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„ÙØ¹Ù„ÙŠØ© Ù„ØªÙˆÙ„ÙŠØ¯ GCODE Ù…Ù† Ø§Ù„Ø­ÙˆØ§Ù
function generateLaserGcodeSafe({ mask, boundingBox, gray }) {
  try {
    const stepOver = 2.0;
    const spacing = 1.0;
    const speed = 2000;
    const maxS = 1000;

    const pxPerMmX = mask.cols / (boundingBox?.width || mask.cols);
    const pxPerMmY = mask.rows / (boundingBox?.height || mask.rows);

    const mmPerPxX = 1 / pxPerMmX;
    const mmPerPxY = 1 / pxPerMmY;

    const sx = Math.max(0, Math.floor(boundingBox?.x || 0));
    const sy = Math.max(0, Math.floor(boundingBox?.y || 0));
    const ex = Math.min(mask.cols, Math.ceil(sx + (boundingBox?.width || mask.cols)));
    const ey = Math.min(mask.rows, Math.ceil(sy + (boundingBox?.height || mask.rows)));

    let gcode = [];
    gcode.push('; === GCODE GENERATED BY CNC AI ===');
    gcode.push('G21 ; Set units to mm');
    gcode.push('G90 ; Absolute positioning');
    gcode.push(`F${speed}`);

    const xStep = Math.max(1, Math.round(spacing * pxPerMmX));
    const yStep = Math.max(1, Math.round(stepOver * pxPerMmY));

    let prevPower = -1;

    for (let y = sy; y < ey; y += yStep) {
      let dir = (y - sy) / yStep % 2 === 0 ? 1 : -1; // zig-zag pattern
      let xStart = dir > 0 ? sx : ex - 1;
      let xEnd = dir > 0 ? ex : sx;
      for (let x = xStart; dir > 0 ? x < xEnd : x >= xEnd; x += dir * xStep) {
        const v = mask.ucharPtr(y, x)[0];
        if (v > 0) {
          let powerNorm = 1.0;
          if (gray) {
            const gv = gray.ucharPtr(y, x)[0];
            powerNorm = (255 - gv) / 255.0;
          }
          const sVal = Math.round(powerNorm * maxS);
          if (sVal !== prevPower) {
            gcode.push(`M3 S${sVal}`);
            prevPower = sVal;
          }
          const gx = (x * mmPerPxX).toFixed(3);
          const gy = (y * mmPerPxY).toFixed(3);
          gcode.push(`G1 X${gx} Y${gy}`);
        }
      }
      setProgressFixed(30 + ((y - sy) / (ey - sy)) * 60);
    }

    gcode.push('M5 ; Laser off');
    gcode.push('G0 X0 Y0');
    return gcode.join('\n');
  } catch (err) {
    console.error('generateLaserGcodeSafe error:', err);
    updateStatusFixed('âš ï¸ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠØ²Ø±', 'error');
    return '';
  }
}
</script>

<script>
// âœ… Ø¯Ø§Ù„Ø© ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ø¨Ø£Ù…Ø§Ù† (ØªÙ…Ù†Ø¹ Ø§Ù„Ø®Ø·Ø£ textContent of null)
function updateDimensionDisplay(width, height) {
  let label = document.getElementById('dimensionLabel');
  if (!label) {
    label = document.createElement('div');
    label.id = 'dimensionLabel';
    label.style.position = 'fixed';
    label.style.bottom = '10px';
    label.style.left = '10px';
    label.style.padding = '5px 10px';
    label.style.background = 'rgba(0,0,0,0.6)';
    label.style.color = '#00ffc3';
    label.style.borderRadius = '5px';
    label.style.fontSize = '0.9em';
    document.body.appendChild(label);
  }
  label.textContent = `Ø§Ù„Ø¹Ø±Ø¶: ${width}px â€” Ø§Ù„Ø§Ø±ØªÙØ§Ø¹: ${height}px`;
}

// âœ… Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
const canvas = document.getElementById('imageCanvas');
const observer = new ResizeObserver(entries => {
  for (let entry of entries) {
    const { width, height } = entry.contentRect;
    updateDimensionDisplay(Math.round(width), Math.round(height));
  }
});
observer.observe(canvas);

// âœ… ØªØ­Ù…ÙŠÙ„ Ø£ÙˆÙ„ÙŠ
window.addEventListener('load', () => {
  updateStatusFixed("âœ… Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…", "success");
  setProgressFixed(0);
});
</script>

</body>
</html>







