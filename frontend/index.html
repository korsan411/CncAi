<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>CNC AI — Multi Machine Raster Engraving (With Debug Overlay)</title>

  <!-- مكتبات -->
  <script src="https://docs.opencv.org/4.8.0/opencv.js" async></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

  <style>
    /* تنسيقات أساسية (محافظة على المظهر الأصلي) */
    * { box-sizing: border-box; }
    body { margin: 0; font-family: Arial, Segoe UI, system-ui; background: #041022; color:#e6eef6; line-height:1.5 }
    .app { max-width:1400px; margin:16px auto; padding:14px }
    header { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #1e293b }
    .grid { display:grid; grid-template-columns:1fr 480px; gap:16px }
    @media (max-width:1000px){ .grid{ grid-template-columns:1fr } }
    .panel { background:#0b1320; padding:16px; border-radius:10px; border:1px solid #1e293b }
    .tabs { display:flex; margin-top:12px; border-bottom:1px solid #1e293b }
    .tabs button { margin-left:6px; padding:8px 14px; border:none; border-radius:6px 6px 0 0; cursor:pointer; background:transparent; color:#9bb0c8; font-size:0.9rem }
    .tabs button.active { background:#06b6d4; color:#021 }
    .tab-content { display:none; margin-top:12px }
    .tab-content.active { display:block }
    canvas { max-width:100%; border-radius:6px; background:#000; display:block; margin:0 auto; border:1px solid #334155 }
    #threeContainer { width:100%; height:400px; background:#081224; border-radius:8px; overflow:hidden; position:relative }
    label { display:block; margin-top:12px; color:#cfeaf2; font-weight:bold }
    input, select, textarea, button { font-size:0.9rem }
    input, select { width:100%; padding:8px 10px; border-radius:6px; border:1px solid #1e293b; background:#0f172a; color:#e6eef6; margin-top:6px }
    .button-group { display:flex; flex-direction:column; gap:8px; margin-top:16px }
    button { background:#1e293b; color:#e6eef6; border:none; padding:10px; border-radius:8px; cursor:pointer }
    button.primary { background:#06b6d4; color:#021; font-weight:bold }
    #toast { position:fixed; left:16px; bottom:16px; background:rgba(0,0,0,0.85); color:#fff; padding:10px 14px; border-radius:8px; display:none; z-index:10000 }
    .canvas-placeholder { width:100%; height:300px; background:#000; border-radius:6px; display:flex; align-items:center; justify-content:center; color:#9bb0c8; border:1px solid #334155 }

    /* Debug overlay */
    #debugOverlay {
      position: fixed;
      right: 16px;
      bottom: 16px;
      width: 360px;
      max-height: 50vh;
      background: rgba(2,6,23,0.85);
      color: #e6eef6;
      border: 1px solid rgba(102, 126, 234, 0.08);
      border-radius: 8px;
      font-size: 13px;
      z-index: 20000;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    }
    #debugHeader {
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:8px 10px;
      border-bottom:1px solid rgba(255,255,255,0.03);
      background: linear-gradient(90deg, rgba(6,182,212,0.06), rgba(8,145,178,0.02));
    }
    #debugHeader b { color:#aee8f2; }
    #debugControls { display:flex; gap:6px; align-items:center; }
    .dbg-btn { background:transparent; border:1px solid rgba(255,255,255,0.06); color:#cfeaf2; padding:6px 8px; border-radius:6px; cursor:pointer; font-size:12px; }
    #debugList { overflow:auto; padding:8px; display:flex; flex-direction:column; gap:6px; }
    .dbg-item { padding:8px; border-radius:6px; background:rgba(255,255,255,0.02); line-height:1.2; max-height:120px; overflow:auto; font-family:monospace; font-size:12px; }
    .dbg-time { opacity:0.7; font-size:11px; margin-bottom:6px; display:block; }
    .dbg-error { border-left:4px solid #ef4444; }
    .dbg-warn { border-left:4px solid #f59e0b; }
    .dbg-info { border-left:4px solid #06b6d4; color:#cfeaf2; }
    .dbg-meta { opacity:0.75; font-size:11px; margin-top:6px; color:#9bb0c8; }
    #debugFooter { padding:6px 10px; border-top:1px solid rgba(255,255,255,0.02); text-align:right; font-size:12px; color:#9bb0c8; background:rgba(0,0,0,0.03); }

    .simulation-controls { position:absolute; top:10px; left:10px; z-index:100; display:flex; gap:8px }
    .simulation-controls button { background:rgba(0,0,0,0.7); color:white; border:1px solid #06b6d4; border-radius:4px; padding:6px 12px; cursor:pointer; font-size:0.8rem }

    @keyframes spin { 0%{transform:rotate(0)}100%{transform:rotate(360deg)} }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>CNC AI — Multi Machine Raster Engraving</h1>
      <div id="cvState">
        <span class="loading" style="display:inline-block;width:16px;height:16px;border:3px solid #f3f3f3;border-top:3px solid #06b6d4;border-radius:50%;animation:spin 1s linear infinite;margin-left:8px;"></span>
        جاري تحميل OpenCV...
      </div>
    </header>

    <div class="grid">
      <!-- اللوحة اليسرى: المعاينات -->
      <div class="panel">
        <div class="file-input-container" style="margin-bottom:12px">
          <input id="fileInput" type="file" accept="image/*"/>
          <label class="file-input-label" for="fileInput" style="display:block;padding:10px;background:#1e293b;border-radius:6px;color:#e6eef6;text-align:center;cursor:pointer;border:2px dashed #334155">📁 اختر صورة للتحميل</label>
        </div>

        <div class="tabs">
          <button data-tab="original" class="active">🖼️ الصورة الأصلية</button>
          <button data-tab="heatmap">🔥 خريطة الحرارة</button>
          <button data-tab="contour">📐 الكشف عن الحواف</button>
          <button data-tab="simulation">🎬 محاكاة التشغيل</button>
        </div>

        <div id="original" class="tab-content active">
          <div class="canvas-placeholder" id="originalPlaceholder">سيتم عرض الصورة هنا</div>
          <canvas id="canvasOriginal" style="display:none;"></canvas>
        </div>

        <div id="heatmap" class="tab-content">
          <div class="canvas-placeholder" id="heatmapPlaceholder">خريطة الحرارة ستظهر هنا بعد تحميل الصورة</div>
          <canvas id="canvasHeatmap" style="display:none;"></canvas>
        </div>

        <div id="contour" class="tab-content">
          <div class="canvas-placeholder" id="contourPlaceholder">كشف الحواف سيظهر هنا بعد تحميل الصورة</div>
          <canvas id="canvasContour" style="display:none;"></canvas>
        </div>

        <div id="simulation" class="tab-content">
          <div id="threeContainer">
            <div class="canvas-placeholder" id="simulationPlaceholder">محاكاة التشغيل ستظهر هنا بعد توليد G-code</div>
          </div>
        </div>
      </div>

      <!-- اللوحة اليمنى: الإعدادات والتحكم -->
      <div class="panel">
        <div class="panel-section">
          <h3>⚙️ إعدادات الماكينة</h3>
          <label for="machineType">نوع الماكينة</label>
          <select id="machineType">
            <option value="router">Router CNC</option>
            <option value="laser">Laser Engraver</option>
            <option value="plasma">Plasma Cutter</option>
            <option value="3dprinter">3D Printer</option>
          </select>
          <div class="info-text" id="machineDescription">Router CNC - مناسبة للنحت على الخشب والأكريليك والمعادن اللينة</div>
        </div>

        <div class="panel-section">
          <h3>📏 إعدادات حجم العمل</h3>
          <div class="input-group" style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
            <div>
              <label for="workWidth">عرض العمل (سم)</label>
              <input id="workWidth" type="number" value="30" step="0.1" min="1" max="200"/>
              <div class="dimension-info" id="widthMm">300.0 مم</div>
            </div>
            <div>
              <label for="workHeight">ارتفاع العمل (سم)</label>
              <input id="workHeight" type="number" value="20" step="0.1" min="1" max="200"/>
              <div class="dimension-info" id="heightMm">200.0 مم</div>
            </div>
          </div>

          <label for="workDepth">عمق العمل (مم)</label>
          <input id="workDepth" type="number" value="3.0" step="0.1" min="0.1" max="50"/>

          <div class="settings-row" style="display:flex;gap:10px;align-items:end;margin-top:8px">
            <div class="input-group" style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
              <div>
                <label for="originX">نقطة الأصل X (سم)</label>
                <input id="originX" type="number" value="0" step="0.1"/>
              </div>
              <div>
                <label for="originY">نقطة الأصل Y (سم)</label>
                <input id="originY" type="number" value="0" step="0.1"/>
              </div>
            </div>
            <button id="btnCenterOrigin" class="secondary">🎯 توسيط نقطة الأصل</button>
          </div>
        </div>

        <div class="panel-section">
          <h3>🚀 إعدادات التشغيل</h3>
          <label for="feedRate">سرعة التغذية (مم/دقيقة)</label>
          <input id="feedRate" type="number" value="800" min="10" max="5000"/>
          <label for="safeZ">ارتفاع الأمان (مم)</label>
          <input id="safeZ" type="number" value="5" step="0.1" min="0" max="100"/>
          <label for="scanDir">اتجاه المسارات</label>
          <select id="scanDir">
            <option value="x">أفقي (X)</option>
            <option value="y">رأسي (Y)</option>
          </select>
          <label for="stepOver">خطوة المسح (مم)</label>
          <input id="stepOver" type="number" value="5" step="0.1" min="0.1" max="50"/>
          <label for="maxDepth">أقصى عمق (مم)</label>
          <input id="maxDepth" type="number" value="3.0" step="0.1" min="0.1" max="50"/>
        </div>

        <div class="button-group">
          <button id="btnGen" class="primary">⚡ توليد G-code</button>
          <button id="btnQuick">🧪 اختبار سريع</button>
          <button id="btnDownload">💾 تحميل G-code</button>
        </div>

        <div id="estTime" style="margin-top:12px;color:#9bb0c8;text-align:center;padding:8px;background:#0f172a;border-radius:6px"></div>

        <label for="gcodeOut" style="margin-top:16px">📄 مخرجات G-code</label>
        <textarea id="gcodeOut" readonly placeholder="سيظهر G-code هنا بعد التوليد..." style="height:200px;background:#021024;color:#cfeaf2;border-radius:8px;padding:10px;"></textarea>

      </div>
    </div>
  </div>

  <!-- Debug Overlay -->
  <div id="debugOverlay" aria-live="polite" role="status">
    <div id="debugHeader">
      <div><b>Debug</b> — Console</div>
      <div id="debugControls">
        <button id="dbgCopy" class="dbg-btn" title="نسخ السجل">📋 نسخ</button>
        <button id="dbgClear" class="dbg-btn" title="مسح السجل">🧹 مسح</button>
      </div>
    </div>
    <div id="debugList"></div>
    <div id="debugFooter">الأخطاء والتحذيرات ستظهر هنا</div>
  </div>

  <div id="toast"></div>

  <script>
    // ========= متغيرات عامة =========
    let cvReady = false;
    let grayMat = null;
    let contour = null;
    let previewCanvas = null;
    let additionalContours = []; // array of {contour, area}
    let lastScanDir = 'x'; // لحفظ آخر اتجاه مسح (لتلوين المسار بالمحاكاة)

    // Simulation
    let scene, camera, renderer, controls;
    let simulation = { isPlaying: false, animationId: null, tool: null, toolPath: null, currentIndex: 0 };

    // ========= Debug overlay system =========
    (function initDebugOverlay(){
      const debugList = document.getElementById('debugList');
      const dbgClear = document.getElementById('dbgClear');
      const dbgCopy = document.getElementById('dbgCopy');

      const logs = [];

      function formatTime(d) {
        return d.toISOString().slice(11, 23);
      }

      function addEntry(type, message, stack) {
        const time = new Date();
        const entry = { time, type, message, stack };
        logs.push(entry);

        const div = document.createElement('div');
        div.className = 'dbg-item ' + (type === 'error' ? 'dbg-error' : (type === 'warn' ? 'dbg-warn' : 'dbg-info'));
        const tspan = document.createElement('span');
        tspan.className = 'dbg-time';
        tspan.textContent = `[${formatTime(time)}] ${type.toUpperCase()}`;
        const msg = document.createElement('div');
        msg.textContent = message;
        div.appendChild(tspan);
        div.appendChild(msg);
        if (stack) {
          const meta = document.createElement('div');
          meta.className = 'dbg-meta';
          meta.textContent = stack.split('\n').slice(0,3).join(' | ');
          div.appendChild(meta);
        }
        debugList.prepend(div);
      }

      dbgClear.addEventListener('click', () => {
        debugList.innerHTML = '';
        logs.length = 0;
      });

      dbgCopy.addEventListener('click', async () => {
        try {
          const text = logs.map(l => `[${l.time.toISOString()}] ${l.type.toUpperCase()}: ${l.message}\n${l.stack||''}`).join('\n\n');
          await navigator.clipboard.writeText(text);
          addEntry('info', 'تم نسخ السجل إلى الحافظة');
        } catch (e) {
          addEntry('error', 'فشل نسخ السجل: ' + (e.message || e));
        }
      });

      // override console methods
      const _log = console.log, _warn = console.warn, _error = console.error;
      console.log = function(...args) {
        try { addEntry('info', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' ')); } catch(e){}
        _log.apply(console, args);
      };
      console.warn = function(...args) {
        try { addEntry('warn', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' '), new Error().stack); } catch(e){}
        _warn.apply(console, args);
      };
      console.error = function(...args) {
        try { addEntry('error', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' '), new Error().stack); } catch(e){}
        _error.apply(console, args);
      };

      // global error handler
      window.addEventListener('error', function(ev){
        try { addEntry('error', ev.message + ' (' + ev.filename + ':' + ev.lineno + ')', ev.error && ev.error.stack ? ev.error.stack : ev.filename + ':' + ev.lineno); } catch(e){}
      });

      window.addEventListener('unhandledrejection', function(ev){
        try { addEntry('error', 'UnhandledRejection: ' + (ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason)), ev.reason && ev.reason.stack ? ev.reason.stack : ''); } catch(e){}
      });

      // Initially hidden if you prefer; keep shown for development
      // document.getElementById('debugOverlay').style.display = 'none';
    })();

    // ======= Helper UI funcs =======
    function showToast(msg, ms = 3000) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.style.display = 'block';
      clearTimeout(t._t);
      t._t = setTimeout(() => t.style.display = 'none', ms);
      // Log to debug too
      try { console.log(msg); } catch (e) {}
    }

    function cmToMm(cm) { return cm * 10; }

    function updateDimensionDisplay() {
      const widthCm = parseFloat(document.getElementById('workWidth').value) || 0;
      const heightCm = parseFloat(document.getElementById('workHeight').value) || 0;
      document.getElementById('widthMm').textContent = cmToMm(widthCm).toFixed(1) + ' مم';
      document.getElementById('heightMm').textContent = cmToMm(heightCm).toFixed(1) + ' مم';
    }

    function showElement(elementId, hidePlaceholderId) {
      const element = document.getElementById(elementId);
      const placeholder = document.getElementById(hidePlaceholderId);
      if (element && placeholder) {
        element.style.display = 'block';
        placeholder.style.display = 'none';
      }
    }

    // ========= تنظيف ميموري OpenCV =========
    function cleanupMats() {
      try {
        if (grayMat && !grayMat.isDeleted) { grayMat.delete(); grayMat = null; }
      } catch (e) { console.warn('cleanup grayMat', e); }

      try {
        if (contour && !contour.isDeleted && contour.delete) {
          contour.delete();
          contour = null;
        }
      } catch (e) { console.warn('cleanup contour', e); }

      try {
        additionalContours.forEach(item => {
          if (item && item.contour && !item.contour.isDeleted) {
            item.contour.delete();
          }
        });
      } catch (e) { console.warn('cleanup additionalContours', e); }
      additionalContours = [];
    }

    // ========= انتظار تحميل OpenCV =========
    function waitForCv() {
      if (typeof cv !== 'undefined' && cv.getBuildInformation) {
        cvReady = true;
        document.getElementById('cvState').innerHTML = '✅ OpenCV جاهز';
        showToast('تم تحميل OpenCV بنجاح', 1500);
      } else {
        setTimeout(waitForCv, 100);
      }
    }
    waitForCv();

    // ========= تبويبات الواجهة =========
    document.querySelectorAll('.tabs button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab).classList.add('active');

        if (btn.dataset.tab === 'simulation' && document.getElementById('gcodeOut').value) {
          initSimulation();
        }
      });
    });

    // ========= تحميل الصورة =========
    document.getElementById('fileInput').addEventListener('change', async function (e) {
      const file = e.target.files[0];
      if (!file) return;
      if (!file.type.match('image.*')) {
        showToast('الرجاء اختيار ملف صورة فقط');
        return;
      }

      try {
        cleanupMats();

        // تحميل الصورة بعنصر Image
        const img = new Image();
        img.src = URL.createObjectURL(file);
        await img.decode();

        previewCanvas = document.getElementById('canvasOriginal');
        const ctx = previewCanvas.getContext('2d');

        // تحسين أحجام الصور الكبيرة لحماية المتصفح
        const maxPixels = 1024 * 1024; // 1MP
        let w = img.width, h = img.height;
        const currentPixels = w * h;
        if (currentPixels > maxPixels) {
          const ratio = Math.sqrt(maxPixels / currentPixels);
          w = Math.floor(w * ratio);
          h = Math.floor(h * ratio);
          showToast('تم تحسين حجم الصورة للأداء الأفضل');
        }

        previewCanvas.width = w;
        previewCanvas.height = h;
        ctx.drawImage(img, 0, 0, w, h);

        showElement('canvasOriginal', 'originalPlaceholder');

        if (cvReady) {
          await detectContours();
        } else {
          showToast('في انتظار OpenCV...');
          setTimeout(async () => { if (cvReady) await detectContours(); }, 800);
        }

      } catch (error) {
        console.error('image load error', error);
        showToast('فشل في تحميل الصورة');
      }
    });

    // ========= كشف الحواف ومعالجة الصورة =========
    async function detectContours() {
      if (!cvReady) {
        showToast('OpenCV غير جاهز بعد');
        return;
      }

      try {
        // قراءة الصورة من الـ canvas
        const src = cv.imread(previewCanvas);

        // تحويل إلى رمادي
        const gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        // تمويه لتقليل الضوضاء
        const blurred = new cv.Mat();
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);

        // حساب متوسط الصورة لاستخدامه كمرجع للـ Canny
        // === تصحيح مهم هنا ===
        const median = cv.mean(blurred)[0];

        const lowerThreshold = Math.max(0, (1.0 - 0.33) * median);
        const upperThreshold = Math.min(255, (1.0 + 0.33) * median);

        const edges = new cv.Mat();
        cv.Canny(blurred, edges, lowerThreshold, upperThreshold);

        // تحسين الحواف
        const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
        cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);

        // إيجاد الكنتورات
        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

        // تصفية الكنتورات حسب المساحة (قابلة للتعديل لاحقاً)
        const minArea = (gray.cols * gray.rows) * 0.01; // 1%
        const validContours = [];

        for (let i = 0; i < contours.size(); i++) {
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area > minArea) {
            validContours.push({ contour: cnt, area });
          } else {
            // حذف الكنتور الصغير فوراً لتفريغ الذاكرة
            try { cnt.delete(); } catch (e) { /* ignore */ }
          }
        }

        if (validContours.length > 0) {
          validContours.sort((a, b) => b.area - a.area);
          // احتفظ بالمؤشر الأكبر كرئيسي، والباقي للتفاصيل
          contour = validContours[0].contour;
          additionalContours = validContours.slice(1).map(v => ({ contour: v.contour, area: v.area }));
          showToast(`تم كشف ${validContours.length} كونتور`);
        } else {
          showToast('لم يتم العثور على حواف واضحة في الصورة');
          // تنظيف
          src.delete(); blurred.delete(); edges.delete(); hierarchy.delete(); contours.delete(); kernel.delete();
          gray.delete();
          return;
        }

        // حفظ نسخة رمادية للاستعلام لاحقًا
        if (grayMat) { try { grayMat.delete(); } catch (e) {} }
        grayMat = gray.clone();

        // عرض heatmap و contour
        renderHeatmap(gray);
        renderContour(gray, contour);

        // تنظيف مؤقت
        src.delete(); blurred.delete(); edges.delete(); hierarchy.delete(); kernel.delete(); contours.delete();
        // نَحْرِص على حذف الـ gray فقط بعد clone (تم الاحتفاظ بنسخة)
        gray.delete();

      } catch (error) {
        console.error('detectContours error', error);
        showToast('فشل في تحليل الصورة');
      }
    }

    // ========= عرض Heatmap و Contour =========
    function renderHeatmap(gray) {
      const heatCanvas = document.getElementById('canvasHeatmap');
      const ctx = heatCanvas.getContext('2d');
      heatCanvas.width = gray.cols;
      heatCanvas.height = gray.rows;
      const imgData = ctx.createImageData(heatCanvas.width, heatCanvas.height);
      const data = gray.data;
      for (let i = 0; i < data.length; i++) {
        const value = data[i];
        const idx = i * 4;
        // تدرج بسيط: أحمر / أزرق
        imgData.data[idx] = value;           // R
        imgData.data[idx + 1] = 0;           // G
        imgData.data[idx + 2] = 255 - value; // B
        imgData.data[idx + 3] = 255;
      }
      ctx.putImageData(imgData, 0, 0);
      showElement('canvasHeatmap', 'heatmapPlaceholder');
    }

    function renderContour(gray, mainContour) {
      const contourCanvas = document.getElementById('canvasContour');
      const ctx = contourCanvas.getContext('2d');
      contourCanvas.width = gray.cols;
      contourCanvas.height = gray.rows;

      // خلفية من heatmap
      const heatCanvas = document.getElementById('canvasHeatmap');
      ctx.drawImage(heatCanvas, 0, 0);

      // رسم الكنتور الرئيسي
      if (mainContour) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const data = mainContour.data32S;
        for (let i = 0; i < data.length; i += 2) {
          const x = data[i], y = data[i + 1];
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
      }

      // باقي الكنتورات
      ctx.strokeStyle = '#ffff00';
      ctx.lineWidth = 1;
      additionalContours.forEach(ci => {
        try {
          const cnt = ci.contour;
          ctx.beginPath();
          const data = cnt.data32S;
          for (let i = 0; i < data.length; i += 2) {
            const x = data[i], y = data[i + 1];
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
        } catch (e) {
          console.warn('renderContour extra error', e);
        }
      });

      showElement('canvasContour', 'contourPlaceholder');
    }

    // ========= أخذ عينة رمادية مع استيفاء ثنائي =========
    function sampleGrayAt(x, y) {
      if (!grayMat) return 128;
      const gw = grayMat.cols, gh = grayMat.rows;
      const gx_f = (x / previewCanvas.width) * (gw - 1);
      const gy_f = (y / previewCanvas.height) * (gh - 1);
      const x0 = Math.floor(gx_f), y0 = Math.floor(gy_f);
      const x1 = Math.min(gw - 1, x0 + 1), y1 = Math.min(gh - 1, y0 + 1);
      const sx = gx_f - x0, sy = gy_f - y0;
      const v00 = grayMat.data[y0 * gw + x0];
      const v10 = grayMat.data[y0 * gw + x1];
      const v01 = grayMat.data[y1 * gw + x0];
      const v11 = grayMat.data[y1 * gw + x1];
      const v0 = v00 * (1 - sx) + v10 * sx;
      const v1 = v01 * (1 - sx) + v11 * sx;
      return Math.round(v0 * (1 - sy) + v1 * sy);
    }

    // ========= توليد نقاط المسح =========
    function addSegmentPoints(rowPoints, startX, endX, y, scaleX, scaleY, originX, originY, maxDepth, invertZ) {
      // تحسين بسيط: sampling كل 2 بكسل (قابل للتعديل)
      for (let x = startX; x <= endX; x += 2) {
        const pv = sampleGrayAt(x, y);
        let z = -((255 - pv) / 255.0) * maxDepth;
        if (invertZ) z = -z;
        const scaledX = (x * scaleX) + originX;
        const scaledY = (y * scaleY) + originY;
        rowPoints.push({ x: scaledX, y: scaledY, z });
      }
    }

    function processRowPoints(rowPoints, lines, feed, safeZ, reverse) {
      if (reverse) rowPoints.reverse();
      // تحرّك سريع إلى أول نقطة ثم إعداد التغذية
      lines.push('G0 X' + rowPoints[0].x.toFixed(2) + ' Y' + rowPoints[0].y.toFixed(2) + ' Z' + safeZ.toFixed(2));
      lines.push('G1 F' + feed.toFixed(0));
      for (let i = 0; i < rowPoints.length; i++) {
        const p = rowPoints[i];
        lines.push('G1 X' + p.x.toFixed(2) + ' Y' + p.y.toFixed(2) + ' Z' + p.z.toFixed(3));
      }
      lines.push('G0 Z' + safeZ.toFixed(2));
    }

    function calculateRowLength(rowPoints) {
      let length = 0;
      for (let i = 1; i < rowPoints.length; i++) {
        length += Math.hypot(rowPoints[i].x - rowPoints[i - 1].x, rowPoints[i].y - rowPoints[i - 1].y);
      }
      return length;
    }

    // ========= توليد G-code الرئيسي =========
    function generateRasterGcode(scaleDown = false) {
      if (!grayMat || !contour) {
        showToast("لا توجد صورة جاهزة للمعالجة");
        return "";
      }

      try {
        const dir = document.getElementById('scanDir').value;
        lastScanDir = dir; // حفظ الاتجاه لاستخدامه في المحاكاة (للتلوين)
        const stepOver = parseFloat(document.getElementById('stepOver').value) || 5;
        const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
        const feed = parseFloat(document.getElementById('feedRate').value) || 800;
        const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
        const invertZ = false; // احتفظنا بخيار واجهة افتراضي (يمكن توسيعه لاحقاً)

        const workWidth = cmToMm(parseFloat(document.getElementById('workWidth').value) || 30);
        const workHeight = cmToMm(parseFloat(document.getElementById('workHeight').value) || 20);
        const originX = cmToMm(parseFloat(document.getElementById('originX').value) || 0);
        const originY = cmToMm(parseFloat(document.getElementById('originY').value) || 0);

        const lines = [];
        lines.push('G21 G90 G17'); // mm, absolute, XY plane
        lines.push('G0 Z' + safeZ.toFixed(2));

        let totalLen = 0;
        const step = scaleDown ? stepOver * 4 : stepOver;
        const scaleX = workWidth / previewCanvas.width;
        const scaleY = workHeight / previewCanvas.height;

        // مسح حسب الاتجاه
        if (dir === 'x') {
          for (let y = 0; y < previewCanvas.height; y += step) {
            const rowPoints = [];
            let inContour = false;
            let segmentStart = -1;
            // تجنب pointPolygonTest لكل بكسل: نستخدم sampling كل 2 بكسل
            for (let x = 0; x < previewCanvas.width; x += 2) {
              const pt = new cv.Point(x, y);
              const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
              if (inside && !inContour) {
                segmentStart = x;
                inContour = true;
              } else if (!inside && inContour) {
                addSegmentPoints(rowPoints, segmentStart, x - 1, y, scaleX, scaleY, originX, originY, maxDepth, invertZ);
                inContour = false;
              }
            }
            if (inContour) {
              addSegmentPoints(rowPoints, segmentStart, previewCanvas.width - 1, y, scaleX, scaleY, originX, originY, maxDepth, invertZ);
            }
            if (rowPoints.length > 1) {
              processRowPoints(rowPoints, lines, feed, safeZ, (y / step) % 2 !== 0);
              totalLen += calculateRowLength(rowPoints);
            }
          }
        } else if (dir === 'y') {
          // مسح رأسي
          for (let x = 0; x < previewCanvas.width; x += step) {
            const colPoints = [];
            let inContour = false;
            let segmentStart = -1;
            for (let y = 0; y < previewCanvas.height; y += 2) {
              const pt = new cv.Point(x, y);
              const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
              if (inside && !inContour) {
                segmentStart = y;
                inContour = true;
              } else if (!inside && inContour) {
                // هنا نضيف نقاط على امتداد رأسي (x ثابت، y متغير)
                addSegmentPoints(colPoints, x, x, segmentStart, scaleX, scaleY, originX, originY, maxDepth, invertZ);
                inContour = false;
              }
            }
            if (inContour) {
              addSegmentPoints(colPoints, x, x, previewCanvas.height - 1, scaleX, scaleY, originX, originY, maxDepth, invertZ);
            }
            if (colPoints.length > 1) {
              processRowPoints(colPoints, lines, feed, safeZ, (x / step) % 2 !== 0);
              totalLen += calculateRowLength(colPoints);
            }
          }
        }

        lines.push('M5'); // stop spindle/laser
        lines.push('M30'); // program end

        // تقدير وقت تقريبي محسّن (أخذ زمان التحركات والـ safeZ تقريبياً بعين الاعتبار)
        const timeMin = (totalLen / (feed || 1)) + ((Math.max(0, safeZ) / 50) * (totalLen / 1000));
        const estTimeHTML = "⏱️ تقدير الوقت: " + timeMin.toFixed(1) + " دقيقة";
        document.getElementById('estTime').innerHTML = estTimeHTML;

        return lines.join('\n');
      } catch (error) {
        console.error('generateGcode error', error);
        showToast('فشل في توليد G-code');
        return "";
      }
    }

    // ========= أزرار التحكم =========
    document.getElementById('btnGen').addEventListener('click', () => {
      const gcode = generateRasterGcode(false);
      document.getElementById('gcodeOut').value = gcode;
      if (gcode) {
        showToast("تم توليد G-code بنجاح");
        // الانتقال لتبويب المحاكاة
        document.querySelector('[data-tab="simulation"]').click();
      }
    });

    document.getElementById('btnQuick').addEventListener('click', () => {
      const gcode = generateRasterGcode(true);
      document.getElementById('gcodeOut').value = gcode;
      if (gcode) {
        showToast("تم توليد G-code سريع بنجاح");
        document.querySelector('[data-tab="simulation"]').click();
      }
    });

    document.getElementById('btnDownload').addEventListener('click', () => {
      const text = document.getElementById('gcodeOut').value;
      if (!text) {
        showToast("لا يوجد G-code لتحميله");
        return;
      }
      try {
        const now = new Date();
        const dateStr = now.toISOString().slice(0, 19).replace(/[:.]/g, '-');
        const filename = `cnc_output_${dateStr}.gcode`;
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast(`تم تحميل الملف: ${filename}`);
      } catch (error) {
        console.error('file download error', error);
        showToast('فشل في تحميل الملف');
      }
    });

    document.getElementById('btnCenterOrigin').addEventListener('click', () => {
      const workWidth = parseFloat(document.getElementById('workWidth').value) || 0;
      const workHeight = parseFloat(document.getElementById('workHeight').value) || 0;
      document.getElementById('originX').value = (workWidth / 2).toFixed(1);
      document.getElementById('originY').value = (workHeight / 2).toFixed(1);
      showToast("تم توسيط نقطة الأصل");
    });

    // ======= مفاتيح اختصار =======
    document.addEventListener('keydown', function (e) {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key.toLowerCase()) {
          case 'g':
            e.preventDefault();
            document.getElementById('btnGen').click();
            break;
          case 'r':
            e.preventDefault();
            document.getElementById('btnQuick').click();
            break;
          case 'd':
            e.preventDefault();
            document.getElementById('btnDownload').click();
            break;
        }
      }
    });

    // ========= Simulation 3D =========

    function parseGcodeForSimulation(gcode) {
      const lines = gcode.split('\n');
      const path = [];
      let pos = { x: 0, y: 0, z: 0 };
      for (let line of lines) {
        line = line.trim();
        if (!line) continue;
        if (line.startsWith('G0') || line.startsWith('G1')) {
          const xm = line.match(/X([-\d.]+)/i);
          const ym = line.match(/Y([-\d.]+)/i);
          const zm = line.match(/Z([-\d.]+)/i);
          if (xm) pos.x = parseFloat(xm[1]);
          if (ym) pos.y = parseFloat(ym[1]);
          if (zm) pos.z = parseFloat(zm[1]);
          path.push({ x: pos.x, y: pos.y, z: pos.z });
        }
      }
      return path;
    }

    function createToolPathVisualization(pathPoints, dir) {
      if (!pathPoints || pathPoints.length < 2) return null;
      const points = pathPoints.map(p => new THREE.Vector3(p.x / 10, -p.z, p.y / 10));
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      // اختر اللون حسب الاتجاه
      const color = dir === 'y' ? 0x3b82f6 : 0x10b981; // y -> blue, x -> green
      const material = new THREE.LineBasicMaterial({ color: color });
      const line = new THREE.Line(geometry, material);
      return line;
    }

    function createToolModel() {
      const group = new THREE.Group();
      const bodyGeom = new THREE.CylinderGeometry(0.5, 0.5, 6, 12);
      const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff4444 });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      body.rotation.x = Math.PI / 2;
      group.add(body);

      const tipGeom = new THREE.ConeGeometry(0.7, 2.5, 12);
      const tipMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
      const tip = new THREE.Mesh(tipGeom, tipMat);
      tip.rotation.x = Math.PI / 2;
      tip.position.z = 4;
      group.add(tip);
      group.scale.set(1.5, 1.5, 1.5);

      return group;
    }

    function addSimulationControls(container) {
      // إزالة إذا وُجدت
      const oldControls = container.querySelector('.simulation-controls');
      const oldInfo = container.querySelector('.simulation-info');
      if (oldControls) oldControls.remove();
      if (oldInfo) oldInfo.remove();

      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'simulation-controls';
      controlsDiv.innerHTML = `<button id="btnPlaySim">▶ تشغيل</button><button id="btnPauseSim">⏸ إيقاف</button><button id="btnResetSim">⏹ إعادة</button>`;
      container.appendChild(controlsDiv);

      const infoDiv = document.createElement('div');
      infoDiv.className = 'simulation-info';
      infoDiv.innerHTML = `<div>الحالة: <span id="simStatus">جاهز</span></div><div>التقدم: <span id="simProgress">0%</span></div>`;
      container.appendChild(infoDiv);

      // الأحداث
      document.getElementById('btnPlaySim').addEventListener('click', () => {
        if (!simulation.toolPath || !simulation.tool) return;
        if (!simulation.animationId) {
          simulation.isPlaying = true;
          animateToolMovement();
          document.getElementById('simStatus').textContent = 'جاري التشغيل';
          showToast('بدأت المحاكاة');
        }
      });

      document.getElementById('btnPauseSim').addEventListener('click', () => {
        if (simulation.animationId) {
          cancelAnimationFrame(simulation.animationId);
          simulation.animationId = null;
        }
        simulation.isPlaying = false;
        document.getElementById('simStatus').textContent = 'متوقف';
        showToast('تم إيقاف المحاكاة');
      });

      document.getElementById('btnResetSim').addEventListener('click', () => {
        if (simulation.animationId) {
          cancelAnimationFrame(simulation.animationId);
          simulation.animationId = null;
        }
        simulation.currentIndex = 0;
        simulation.isPlaying = false;
        if (simulation.tool) simulation.tool.position.set(0, 0, 0);
        document.getElementById('simProgress').textContent = '0%';
        document.getElementById('simStatus').textContent = 'جاهز';
        showToast('تم إعادة تعيين المحاكاة');
      });
    }

    function animateToolMovement() {
      if (!simulation.toolPath || !simulation.tool) return;
      const posAttr = simulation.toolPath.geometry.attributes.position;
      const totalPoints = posAttr.count;
      function step() {
        if (simulation.currentIndex >= totalPoints) {
          // انتهت
          simulation.animationId = null;
          simulation.isPlaying = false;
          document.getElementById('simStatus').textContent = 'مكتمل';
          showToast('اكتملت المحاكاة');
          return;
        }
        const ix = simulation.currentIndex;
        const x = posAttr.getX(ix);
        const y = posAttr.getY(ix);
        const z = posAttr.getZ(ix);
        simulation.tool.position.set(x, y, z);
        const progress = ((ix + 1) / totalPoints) * 100;
        document.getElementById('simProgress').textContent = progress.toFixed(1) + '%';
        simulation.currentIndex += 1;
        simulation.animationId = requestAnimationFrame(step);
      }
      if (!simulation.animationId) step();
    }

    function initSimulation() {
      const container = document.getElementById('threeContainer');

      // تنظيف مشهد سابق
      if (renderer) {
        try {
          // Remove renderer DOM and dispose
          container.removeChild(renderer.domElement);
          renderer.dispose();
        } catch (e) { /* ignore */ }
        renderer = null;
        scene = null;
        camera = null;
        controls = null;
        simulation = { isPlaying: false, animationId: null, tool: null, toolPath: null, currentIndex: 0 };
      }

      // إخفاء العنصر النائب
      const placeholder = document.getElementById('simulationPlaceholder');
      if (placeholder) placeholder.style.display = 'none';

      try {
        const gcode = document.getElementById('gcodeOut').value;
        if (!gcode) throw new Error('لا يوجد G-code للمحاكاة');

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x081224);

        camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 2000);
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // إضاءة
        const ambient = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 120, 50);
        scene.add(dirLight);

        // إضافة سطح العمل (scaled)
        const workWidth = cmToMm(parseFloat(document.getElementById('workWidth').value) || 30) / 10;
        const workHeight = cmToMm(parseFloat(document.getElementById('workHeight').value) || 20) / 10;
        const workDepth = (parseFloat(document.getElementById('workDepth').value) || 3) / 10;

        const materialGeometry = new THREE.BoxGeometry(workWidth, workDepth, workHeight);
        const materialMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, transparent: true, opacity: 0.85 });
        const materialMesh = new THREE.Mesh(materialGeometry, materialMaterial);
        materialMesh.position.set(workWidth / 2, -workDepth / 2, workHeight / 2);
        scene.add(materialMesh);

        // توليد مسار من G-code
        const pathPoints = parseGcodeForSimulation(gcode);
        simulation.toolPath = createToolPathVisualization(pathPoints, lastScanDir);
        if (simulation.toolPath) scene.add(simulation.toolPath);

        // إضافة أداة
        simulation.tool = createToolModel();
        simulation.tool.position.set(0, 0, 0);
        scene.add(simulation.tool);

        // مساعدة الشبكة والمحاور
        const gridSize = Math.max(workWidth, workHeight) * 1.2;
        const gridHelper = new THREE.GridHelper(gridSize, 10);
        gridHelper.position.set(gridSize / 2, 0, gridSize / 2);
        scene.add(gridHelper);

        const axesHelper = new THREE.AxesHelper(Math.max(workWidth, workHeight) / 2 + 5);
        scene.add(axesHelper);

        // عناصر التحكم بالمحاكاة
        addSimulationControls(container);

        // Render loop
        (function animate() {
          requestAnimationFrame(animate);
          if (controls) controls.update();
          if (renderer && scene && camera) renderer.render(scene, camera);
        })();

        showToast('تم تهيئة المحاكاة بنجاح');

      } catch (error) {
        console.error('initSimulation error', error);
        showToast('فشل في تهيئة المحاكاة');
        if (placeholder) placeholder.style.display = 'flex';
      }
    }

    // ========= تهيئة الواجهة =========
    document.addEventListener('DOMContentLoaded', () => {
      updateDimensionDisplay();
      showToast('تم تحميل التطبيق بنجاح', 1500);

      // حدث تغيير عرض الأبعاد
      document.getElementById('workWidth').addEventListener('input', () => setTimeout(updateDimensionDisplay, 300));
      document.getElementById('workHeight').addEventListener('input', () => setTimeout(updateDimensionDisplay, 300));

      // تغيير وصف الماكينة عند الاختيار
      const machineDefaults = {
        router: { feed: 800, safeZ: 5, maxDepth: 3, stepOver: 5, description: "Router CNC - مناسبة للنحت على الخشب والأكريليك والمعادن اللينة" },
        laser: { feed: 1200, safeZ: 0, maxDepth: 0, stepOver: 0.2, description: "Laser Engraver - مناسبة للنقش على الخشب والجلود والأكريليك" },
        plasma: { feed: 1500, safeZ: 3, maxDepth: 0, stepOver: 1, description: "Plasma Cutter - مناسبة لقطع المعادن بسمك مختلف" },
        "3dprinter": { feed: 1000, safeZ: 0.2, maxDepth: 0.2, stepOver: 0.4, description: "3D Printer - للطباعة ثلاثية الأبعاد بتقنية FDM" }
      };
      document.getElementById('machineType').addEventListener('change', (e) => {
        const def = machineDefaults[e.target.value];
        if (def) {
          document.getElementById('feedRate').value = def.feed;
          document.getElementById('safeZ').value = def.safeZ;
          document.getElementById('maxDepth').value = def.maxDepth;
          document.getElementById('stepOver').value = def.stepOver;
          document.getElementById('machineDescription').textContent = def.description;
          showToast(`تم تحميل إعدادات ${e.target.value}`);
        }
      });

    });

    // إعادة ضبط حجم الـ renderer عند تغيير النافذة
    window.addEventListener('resize', () => {
      const container = document.getElementById('threeContainer');
      if (camera && renderer && container) {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }
    });
  </script>
</body>
</html>
