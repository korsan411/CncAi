<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CNC AI - ØªØ­Ù„ÙŠÙ„ Ù…Ø±ØªÙØ¹Ø§Øª Ø¯Ù‚ÙŠÙ‚</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f8f8f8;
      text-align: center;
      margin: 0;
      padding: 0;
      color: #333;
    }

    header {
      background: #222;
      color: #fff;
      padding: 15px;
      font-size: 20px;
    }

    .container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      padding: 20px;
    }

    canvas {
      border: 1px solid #ccc;
      max-width: 100%;
    }

    #controls {
      margin: 20px 0;
    }

    button {
      padding: 10px 20px;
      margin: 0 5px;
      cursor: pointer;
      border: none;
      border-radius: 8px;
      background: #007bff;
      color: #fff;
      transition: background 0.3s;
    }

    button:hover {
      background: #0056b3;
    }

    #threeContainer {
      width: 500px;
      height: 500px;
      margin: auto;
    }
  </style>
</head>
<body>
  <header>ğŸ› ï¸ CNC AI - ØªØ­Ù„ÙŠÙ„ Ù…Ø±ØªÙØ¹Ø§Øª Ø¯Ù‚ÙŠÙ‚</header>

  <div id="controls">
    <input type="file" id="uploadImage" accept="image/*">
    <button onclick="generateHeightMap()">Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ù…Ø±ØªÙØ¹Ø§Øª</button>
    <button onclick="update3DView()">Ù…Ø¹Ø§ÙŠÙ†Ø© 3D</button>
  </div>

  <div class="container">
    <div>
      <h3>Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</h3>
      <canvas id="canvasOriginal"></canvas>
    </div>
    <div>
      <h3>Ø®Ø±ÙŠØ·Ø© Heatmap</h3>
      <canvas id="canvasHeightmap"></canvas>
    </div>
    <div>
      <h3>Ù…Ø¹Ø§ÙŠÙ†Ø© 3D</h3>
      <div id="threeContainer"></div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const canvasOriginal = document.getElementById('canvasOriginal');
    const ctxOriginal = canvasOriginal.getContext('2d');

    const canvasHeightmap = document.getElementById('canvasHeightmap');
    const ctxHeightmap = canvasHeightmap.getContext('2d');

    let width, height, heightMapData = [];
    let originalImage = null;

    // Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©
    document.getElementById('uploadImage').addEventListener('change', function(event) {
      const file = event.target.files[0];
      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
          width = img.width;
          height = img.height;
          canvasOriginal.width = width;
          canvasOriginal.height = height;
          ctxOriginal.drawImage(img, 0, 0, width, height);
          originalImage = ctxOriginal.getImageData(0, 0, width, height);
        }
        img.src = e.target.result;
      }
      reader.readAsDataURL(file);
    });

    /* ========== Gaussian Blur ========== */
    function applyGaussianBlur(data, w, h) {
      const kernel = [
        [1, 4, 7, 4, 1],
        [4, 16, 26, 16, 4],
        [7, 26, 41, 26, 7],
        [4, 16, 26, 16, 4],
        [1, 4, 7, 4, 1]
      ];
      const weight = 273;
      const output = new Float32Array(w * h);

      for (let y = 2; y < h - 2; y++) {
        for (let x = 2; x < w - 2; x++) {
          let sum = 0;
          for (let ky = -2; ky <= 2; ky++) {
            for (let kx = -2; kx <= 2; kx++) {
              const val = data[(y + ky) * w + (x + kx)];
              const k = kernel[ky + 2][kx + 2];
              sum += val * k;
            }
          }
          output[y * w + x] = sum / weight;
        }
      }
      return output;
    }

    /* ========== Sobel Edge Detection ========== */
    function applySobel(gray, w, h) {
      const gxKernel = [
        [-1, 0, 1],
        [-2, 0, 2],
        [-1, 0, 1]
      ];
      const gyKernel = [
        [-1, -2, -1],
        [0, 0, 0],
        [1, 2, 1]
      ];
      const output = new Float32Array(w * h);

      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          let gx = 0, gy = 0;
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const val = gray[(y + ky) * w + (x + kx)];
              gx += gxKernel[ky + 1][kx + 1] * val;
              gy += gyKernel[ky + 1][kx + 1] * val;
            }
          }
          output[y * w + x] = Math.sqrt(gx * gx + gy * gy);
        }
      }
      return output;
    }

    /* ========== Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª ========== */
    function generateHeightMap() {
      if (!originalImage) return;

      const gray = new Float32Array(width * height);
      const data = originalImage.data;

      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ grayscale
      for (let i = 0; i < data.length; i += 4) {
        gray[i / 4] = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
      }

      // Gaussian Blur Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ØªØ´ÙˆÙŠØ´
      const blurred = applyGaussianBlur(gray, width, height);

      // Ø§ÙƒØªØ´Ø§Ù Ø§Ù„Ø­ÙˆØ§Ù
      const edges = applySobel(blurred, width, height);

      // Ø¯Ù…Ø¬ Ø§Ù„Ø­ÙˆØ§Ù Ù…Ø¹ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ù…ÙˆÙ‡Ø©
      heightMapData = new Float32Array(width * height);
      let minVal = Infinity, maxVal = -Infinity;
      for (let i = 0; i < blurred.length; i++) {
        const combined = blurred[i] + edges[i] * 1.5; // Ø§Ù„Ø­ÙˆØ§Ù Ù„Ù‡Ø§ ÙˆØ²Ù† Ø£Ø¹Ù„Ù‰
        heightMapData[i] = combined;
        if (combined < minVal) minVal = combined;
        if (combined > maxVal) maxVal = combined;
      }

      // ØªØ·Ø¨ÙŠØ¹ Ø§Ù„Ù‚ÙŠÙ… Ø¨ÙŠÙ† 0 Ùˆ 1
      for (let i = 0; i < heightMapData.length; i++) {
        heightMapData[i] = (heightMapData[i] - minVal) / (maxVal - minVal || 1);
      }

      // Ø±Ø³Ù… Heatmap
      canvasHeightmap.width = width;
      canvasHeightmap.height = height;
      const heatImg = ctxHeightmap.createImageData(width, height);
      for (let i = 0; i < heightMapData.length; i++) {
        const val = heightMapData[i];
        const color = getHeatmapColor(val);
        heatImg.data[i * 4] = color.r;
        heatImg.data[i * 4 + 1] = color.g;
        heatImg.data[i * 4 + 2] = color.b;
        heatImg.data[i * 4 + 3] = 255;
      }
      ctxHeightmap.putImageData(heatImg, 0, 0);
    }

    /* ========== Ø£Ù„ÙˆØ§Ù† Heatmap ========== */
    function getHeatmapColor(value) {
      const r = Math.floor(255 * Math.pow(value, 1.2));  // Ø§Ù„Ø£Ø­Ù…Ø± Ù„Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ø¹Ø§Ù„ÙŠØ©
      const g = Math.floor(255 * (1 - value) * 0.8);     // Ø§Ù„Ø£Ø®Ø¶Ø± Ù„Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…ØªÙˆØ³Ø·Ø©
      const b = Math.floor(255 * (1 - value * 0.6));     // Ø§Ù„Ø£Ø²Ø±Ù‚ Ù„Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…Ù†Ø®ÙØ¶Ø©
      return { r, g, b };
    }

    /* ========== Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ ========== */
    let scene, camera, renderer, mesh;

    function update3DView() {
      if (!heightMapData.length) return;

      if (!scene) {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(500, 500);
        document.getElementById('threeContainer').appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 0, 1).normalize();
        scene.add(light);
      }

      const geometry = new THREE.PlaneGeometry(10, 10, width - 1, height - 1);

      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª
      for (let i = 0; i < geometry.attributes.position.count; i++) {
        geometry.attributes.position.setZ(i, heightMapData[i] * 2); // scaleZ = 2
      }
      geometry.computeVertexNormals();

      const material = new THREE.MeshStandardMaterial({
        color: 0xdddddd,
        wireframe: false,
        side: THREE.DoubleSide
      });

      if (mesh) scene.remove(mesh);
      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      camera.position.z = 15;

      function animate() {
        requestAnimationFrame(animate);
        mesh.rotation.z += 0.002;
        mesh.rotation.x = Math.PI / 3;
        renderer.render(scene, camera);
      }
      animate();
    }
  </script>
</body>
</html>
