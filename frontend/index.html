<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>CNC AI â€” Ù…ØªÙƒØ§Ù…Ù„ (Upload + 2D + Heatmap + 3D + G-code)</title>

  <!-- Ù…ÙƒØªØ¨Ø§Øª -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

  <style>
    *{box-sizing:border-box}
    body{margin:0;font-family:Arial,Segoe UI,system-ui;background:#041022;color:#e6eef6}
    .app{max-width:1300px;margin:14px auto;padding:12px}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;padding-bottom:12px;border-bottom:1px solid #10202b}
    h1{margin:0;color:#06b6d4}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:14px}
    @media(max-width:1000px){.grid{grid-template-columns:1fr}}
    .panel{background:#081226;padding:14px;border-radius:10px;border:1px solid #162834}
    .tabs{display:flex;flex-wrap:wrap;gap:6px;border-bottom:1px solid #162834;padding-bottom:8px}
    .tabs button{background:transparent;border:none;padding:8px 12px;border-radius:6px 6px 0 0;color:#9bb0c8;cursor:pointer}
    .tabs button.active{background:#06b6d4;color:#021}
    .tab-content{display:none;padding-top:12px}
    .tab-content.active{display:block}
    canvas{background:#000;display:block;border-radius:6px;max-width:100%}
    #threeContainer,#gcodeSimContainer{width:100%;height:380px;background:#06111a;border-radius:8px;overflow:hidden;position:relative}
    input,select,textarea{background:#0e1a26;color:#e6eef6;border:1px solid #163043;padding:8px;border-radius:6px}
    label{display:block;margin-top:10px;color:#cfeaf2;font-weight:600}
    .input-group{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .button-group{display:flex;flex-direction:column;gap:8px;margin-top:12px}
    button.primary{background:#06b6d4;color:#021;border:none;padding:10px;border-radius:8px;cursor:pointer}
    button.secondary{background:#163043;color:#e6eef6;border:none;padding:10px;border-radius:8px;cursor:pointer}
    .material-preset{background:#102533;border-radius:6px;padding:8px;margin-top:8px;cursor:pointer}
    .dimension-info{color:#06b6d4;font-size:0.9em;margin-top:6px}
    #toast{position:fixed;left:16px;bottom:16px;background:rgba(0,0,0,0.8);color:#fff;padding:10px 12px;border-radius:8px;display:none;z-index:9999}
    .three-controls{display:flex;align-items:center;gap:8px;margin-top:8px}
    .progress-bar{width:100%;height:6px;background:#102533;border-radius:4px;overflow:hidden;margin-top:8px}
    .progress-fill{height:100%;background:#06b6d4;width:0%;transition:width .25s}
    textarea{font-family:monospace;height:200px}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>CNC AI â€” Ù…ØªÙƒØ§Ù…Ù„</h1>
      <div id="cvState">â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ OpenCV...</div>
    </header>

    <div class="grid">
      <!-- ÙŠØ³Ø§Ø±: Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ± ÙˆØ§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª -->
      <div class="panel">
        <div style="margin-bottom:10px">
          <label class="file-input-label" style="display:block;background:#163043;padding:8px;border-radius:6px;text-align:center;cursor:pointer;">
            Ø§Ø®ØªØ± ØµÙˆØ±Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
            <input id="fileInput" type="file" accept="image/*" style="position:absolute;left:0;top:0;opacity:0;width:100%;height:100%;cursor:pointer"/>
          </label>
          <div class="progress-bar"><div id="genProgress" class="progress-fill"></div></div>
        </div>

        <div class="tabs">
          <button data-tab="original" class="active">ğŸ–¼ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</button>
          <button data-tab="heatmap">ğŸ”¥ Heatmap</button>
          <button data-tab="contour">ğŸ“ Ø§Ù„Ø­ÙˆØ§Ù</button>
          <button data-tab="threeD">ğŸ“¦ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© 3D</button>
          <button data-tab="gcodeSim" id="gcodeSimTab" disabled>ğŸ® Ù…Ø­Ø§ÙƒØ§Ø© G-code</button>
        </div>

        <div id="original" class="tab-content active">
          <canvas id="canvasOriginal"></canvas>
        </div>

        <div id="heatmap" class="tab-content">
          <canvas id="canvasHeatmap"></canvas>
        </div>

        <div id="contour" class="tab-content">
          <canvas id="canvasContour"></canvas>
        </div>

        <div id="threeD" class="tab-content">
          <div id="threeContainer">
            <div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#9bb0c8">Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯...</div>
          </div>

          <div class="three-controls">
            <label for="scaleZSlider">Ù…Ù‚ÙŠØ§Ø³ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Z: <span id="scaleZVal">1.00</span>x</label>
            <input id="scaleZSlider" type="range" min="0" max="5" step="0.05" value="1" style="flex:1"/>
            <label style="margin-left:8px;font-weight:600;color:#cfeaf2">maxDepth(mm)</label>
            <input id="maxDepth" type="number" value="3.0" step="0.1" min="0.1" style="width:90px"/>
          </div>
        </div>

        <div id="gcodeSim" class="tab-content">
          <div id="gcodeSimContainer">
            <div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#9bb0c8">Ø³ÙŠØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø¨Ø¹Ø¯ ØªÙˆÙ„ÙŠØ¯ G-code</div>
          </div>
        </div>
      </div>

      <!-- ÙŠÙ…ÙŠÙ†: Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ùˆ G-code -->
      <div class="panel">
        <div class="panel-section">
          <h3 style="margin:0 0 6px 0">âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø© & Ø§Ù„Ø¹Ù…Ù„</h3>

          <label for="machineType">Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</label>
          <select id="machineType">
            <option value="router">Router CNC</option>
            <option value="laser">Laser Engraver</option>
            <option value="plasma">Plasma Cutter</option>
            <option value="3dprinter">3D Printer</option>
          </select>

          <div class="info-text" id="machineDescription" style="margin-top:8px;color:#9bb0c8">Router CNC - Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ø®Ø´Ø¨ ÙˆØ§Ù„Ø£ÙƒØ±ÙŠÙ„ÙŠÙƒ.</div>

          <label for="workWidth">Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù…Ù„ (Ø³Ù…)</label>
          <input id="workWidth" type="number" value="30" step="0.1"/>

          <label for="workHeight">Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¹Ù…Ù„ (Ø³Ù…)</label>
          <input id="workHeight" type="number" value="20" step="0.1"/>
          <div class="dimension-info" id="dimInfo">300.0 Ã— 200.0 Ù…Ù…</div>

          <label for="originX">Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„ X (Ø³Ù…)</label>
          <input id="originX" type="number" value="0" step="0.1"/>

          <label for="originY">Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„ Y (Ø³Ù…)</label>
          <input id="originY" type="number" value="0" step="0.1"/>

          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="btnCenterOrigin" class="secondary" style="flex:1">ğŸ¯ ØªÙˆØ³ÙŠØ· Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„</button>
            <button id="btnQuick" class="secondary" style="flex:1">âš¡ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ø®ØªØ¨Ø§Ø± Ø³Ø±ÙŠØ¹</button>
          </div>
        </div>

        <div class="panel-section" style="margin-top:12px">
          <h3 style="margin:0 0 6px 0">ğŸš€ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ´ØºÙŠÙ„</h3>

          <label for="feedRate">Ø³Ø±Ø¹Ø© Ø§Ù„ØªØºØ°ÙŠØ© (Ù…Ù…/Ø¯Ù‚ÙŠÙ‚Ø©)</label>
          <input id="feedRate" type="number" value="800" min="10" max="5000"/>

          <label for="safeZ">Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø£Ù…Ø§Ù† SafeZ (Ù…Ù…)</label>
          <input id="safeZ" type="number" value="5.0" step="0.1" min="0"/>

          <label for="scanDir">Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø³Ø­</label>
          <select id="scanDir"><option value="x">Ø£ÙÙ‚ÙŠ (X)</option><option value="y">Ø±Ø£Ø³ÙŠ (Y)</option></select>

          <label for="stepOver">Ø®Ø·ÙˆØ© Ø§Ù„Ù…Ø³Ø­ (Ù…Ù…)</label>
          <input id="stepOver" type="number" value="5" step="0.1" min="0.1"/>
        </div>

        <div class="button-group">
          <button id="btnGen" class="primary">âš¡ ØªÙˆÙ„ÙŠØ¯ G-code</button>
          <button id="btnDownload" class="secondary">ğŸ’¾ ØªØ­Ù…ÙŠÙ„ G-code</button>
        </div>

        <label style="margin-top:12px">ğŸ“„ Ù…Ø®Ø±Ø¬Ø§Øª G-code</label>
        <textarea id="gcodeOut" readonly placeholder="Ø³ÙŠØ¸Ù‡Ø± G-code Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙˆÙ„ÙŠØ¯..."></textarea>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <script>
    // ===== Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø© =====
    let cvReady = false;
    let grayMat = null;
    let previewCanvas = null;
    let currentScene = null;
    let gcodeSimScene = null;
    let gcodeSimAnimationId = null;
    let isGcodeGenerated = false;
    let scaleZ = parseFloat(document.getElementById('scaleZSlider').value || 1.0);

    // ===== Ù…Ø³Ø§Ø¹Ø¯Ø©: Toast =====
    function showToast(msg, ms = 2000) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.style.display = 'block';
      clearTimeout(t._t);
      t._t = setTimeout(() => t.style.display = 'none', ms);
    }

    // ===== ÙˆØ­Ø¯Ø© ØªØ­ÙˆÙŠÙ„ =====
    function cmToMm(cm){ return cm * 10; }

    // ===== Ø§Ù†ØªØ¸Ø§Ø± ØªÙ‡ÙŠØ¦Ø© OpenCV =====
    function waitForCv(){
      if(window.cv && cv.getBuildInformation){
        cvReady = true;
        document.getElementById('cvState').textContent = 'âœ… OpenCV Ø¬Ø§Ù‡Ø²';
        showToast('OpenCV ØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡');
        return;
      }
      if(window.cv){
        cv['onRuntimeInitialized'] = () => {
          cvReady = true;
          document.getElementById('cvState').textContent = 'âœ… OpenCV Ø¬Ø§Ù‡Ø²';
          showToast('OpenCV ØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡');
        };
      } else {
        setTimeout(waitForCv, 200);
      }
    }
    waitForCv();

    // ===== ØªØ¨ÙˆÙŠØ¨Ø§Øª =====
    document.querySelectorAll('.tabs button').forEach(btn=>{
      btn.addEventListener('click', ()=> {
        document.querySelectorAll('.tabs button').forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(tc=>tc.classList.remove('active'));
        btn.classList.add('active');
        const id = btn.dataset.tab;
        document.getElementById(id).classList.add('active');

        if(id === 'threeD' && grayMat) { show3D(); }
        if(id === 'gcodeSim' && isGcodeGenerated) { initGcodeSimulation(); }
      });
    });

    // ===== Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© ÙˆÙ…Ø¹Ø§Ù„Ø¬ØªÙ‡Ø§ =====
    document.getElementById('fileInput').addEventListener('change', e=>{
      const file = e.target.files[0];
      if(!file) return;
      if(!file.type.match('image.*')){ showToast('âš ï¸ Ø§Ø®ØªØ± Ù…Ù„Ù ØµÙˆØ±Ø©'); return; }
      const img = new Image();
      img.onload = function(){
        previewCanvas = document.getElementById('canvasOriginal');
        const maxW = 900, maxH = 600;
        let w = img.width, h = img.height;
        if(w > maxW){ h = Math.round((maxW/w)*h); w = maxW; }
        if(h > maxH){ w = Math.round((maxH/h)*w); h = maxH; }
        previewCanvas.width = w; previewCanvas.height = h;
        const ctx = previewCanvas.getContext('2d');
        ctx.clearRect(0,0,w,h);
        ctx.drawImage(img,0,0,w,h);

        // Ø§ÙØ¹Ù„ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
        if(cvReady) { detectContours(); } else { showToast('â³ Ø§Ù†ØªØ¸Ø§Ø± OpenCV...'); }
      };
      img.onerror = ()=> showToast('âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©');
      img.src = URL.createObjectURL(file);
    });

    // ===== Ø¥Ø¯Ø§Ø±Ø© Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø±Ø¶ =====
    function updateDimInfo(){
      const w = parseFloat(document.getElementById('workWidth').value)||30;
      const h = parseFloat(document.getElementById('workHeight').value)||20;
      document.getElementById('dimInfo').textContent = (cmToMm(w).toFixed(1)) + ' Ã— ' + (cmToMm(h).toFixed(1)) + ' Ù…Ù…';
    }
    document.getElementById('workWidth').addEventListener('input', updateDimInfo);
    document.getElementById('workHeight').addEventListener('input', updateDimInfo);
    updateDimInfo();

    document.getElementById('btnCenterOrigin').addEventListener('click', ()=>{
      const w = parseFloat(document.getElementById('workWidth').value)||30;
      const h = parseFloat(document.getElementById('workHeight').value)||20;
      document.getElementById('originX').value = (w/2).toFixed(1);
      document.getElementById('originY').value = (h/2).toFixed(1);
      showToast('âœ… ØªÙ… ØªÙˆØ³ÙŠØ· Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„');
    });
    document.getElementById('btnQuick').addEventListener('click', ()=>{
      document.getElementById('workWidth').value = 15;
      document.getElementById('workHeight').value = 10;
      document.getElementById('stepOver').value = 2;
      document.getElementById('maxDepth').value = 1;
      updateDimInfo();
      showToast('âš¡ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ø®ØªØ¨Ø§Ø± Ø³Ø±ÙŠØ¹ Ù…ÙØ¹Ù„');
    });

    // ===== Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± (OpenCV) =====
    function sampleGrayAt(x,y){
      if(!grayMat || !previewCanvas) return 128;
      const gw = grayMat.cols, gh = grayMat.rows;
      if(x<0||x>=previewCanvas.width||y<0||y>=previewCanvas.height) return 128;
      const gx_f = (x/previewCanvas.width) * (gw-1);
      const gy_f = (y/previewCanvas.height) * (gh-1);
      const x0 = Math.floor(gx_f), y0 = Math.floor(gy_f);
      const x1 = Math.min(gw-1,x0+1), y1 = Math.min(gh-1,y0+1);
      const sx = gx_f - x0, sy = gy_f - y0;
      const v00 = grayMat.ucharPtr(y0,x0)[0];
      const v10 = grayMat.ucharPtr(y0,x1)[0];
      const v01 = grayMat.ucharPtr(y1,x0)[0];
      const v11 = grayMat.ucharPtr(y1,x1)[0];
      const v0 = v00*(1-sx)+v10*sx;
      const v1 = v01*(1-sx)+v11*sx;
      return v0*(1-sy)+v1*sy;
    }

    function detectContours(){
      if(!cvReady || !previewCanvas) { showToast('âš ï¸ Ø§ÙØªØ­ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹'); return; }
      try{
        const src = cv.imread(previewCanvas);
        grayMat = new cv.Mat();
        cv.cvtColor(src, grayMat, cv.COLOR_RGBA2GRAY);
        const blurred = new cv.Mat();
        cv.GaussianBlur(grayMat, blurred, new cv.Size(5,5), 0);
        const edges = new cv.Mat();
        cv.Canny(blurred, edges, 50, 150);
        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // Ø±Ø³Ù… Ø§Ù„Ø­ÙˆØ§Ù Ø¹Ù„Ù‰ canvasContour
        const contourCanvas = document.getElementById('canvasContour');
        contourCanvas.width = previewCanvas.width; contourCanvas.height = previewCanvas.height;
        const ctx = contourCanvas.getContext('2d');
        ctx.clearRect(0,0,contourCanvas.width,contourCanvas.height);
        ctx.drawImage(previewCanvas,0,0);
        ctx.strokeStyle = '#06b6d4'; ctx.lineWidth = 2;

        for(let i=0;i<contours.size();i++){
          const cnt = contours.get(i);
          ctx.beginPath();
          for(let j=0;j<cnt.data32S.length;j+=2){
            const x = cnt.data32S[j], y = cnt.data32S[j+1];
            if(j===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
          }
          ctx.closePath(); ctx.stroke();
        }

        // ØªØ­Ø±ÙŠØ± Ù…Ø¤Ù‚Øª Ù„Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ø§Øª
        src.delete(); blurred.delete(); edges.delete(); contours.delete(); hierarchy.delete();

        // Ø¥Ù†Ø´Ø§Ø¡ Heatmap
        createHeatmap();
        showToast('âœ… Ø§Ù†ØªÙ‡Øª Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©');
      }catch(err){
        console.error(err);
        showToast('âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©');
      }
    }

    function createHeatmap(){
      if(!grayMat || !previewCanvas) return;
      const heatmapCanvas = document.getElementById('canvasHeatmap');
      heatmapCanvas.width = previewCanvas.width; heatmapCanvas.height = previewCanvas.height;
      const ctx = heatmapCanvas.getContext('2d'); ctx.clearRect(0,0,heatmapCanvas.width,heatmapCanvas.height);
      ctx.drawImage(previewCanvas,0,0);
      const imageData = ctx.getImageData(0,0,heatmapCanvas.width,heatmapCanvas.height);
      const data = imageData.data;
      for(let i=0;i<data.length;i+=4){
        const px = (i/4)%heatmapCanvas.width; const py = Math.floor((i/4)/heatmapCanvas.width);
        const g = sampleGrayAt(px,py);
        let r,gc,b;
        if(g<64){ r=0; gc=Math.floor((g/64)*255); b=255; }
        else if(g<128){ r=Math.floor(((g-64)/64)*255); gc=255; b=Math.floor((1-((g-64)/64))*255); }
        else if(g<192){ r=255; gc=Math.floor((1-((g-128)/64))*255); b=0; }
        else { r=255; gc=Math.floor((1-((g-192)/64))*128); b=0; }
        const alpha=0.6;
        data[i]=Math.floor(data[i]*(1-alpha)+r*alpha);
        data[i+1]=Math.floor(data[i+1]*(1-alpha)+gc*alpha);
        data[i+2]=Math.floor(data[i+2]*(1-alpha)+b*alpha);
      }
      ctx.putImageData(imageData,0,0);
    }

    // ===== Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© 3D =====
    function disposeScene(){
      if(!currentScene) return;
      try{
        if(currentScene.renderer && currentScene.renderer.domElement && currentScene.renderer.domElement.parentNode)
          currentScene.renderer.domElement.parentNode.removeChild(currentScene.renderer.domElement);
        if(currentScene.geometry) currentScene.geometry.dispose();
        if(currentScene.material) currentScene.material.dispose();
        if(currentScene.renderer){ currentScene.renderer.forceContextLoss(); currentScene.renderer.domElement=null; currentScene.renderer=null; }
      }catch(e){ console.warn('cleanup error',e); }
      currentScene = null;
    }

    function show3D(){
      if(!grayMat || !previewCanvas){ showToast('âš ï¸ Ø­Ù…Ù„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹'); return; }
      const container = document.getElementById('threeContainer');
      container.innerHTML = '<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#9bb0c8">Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø´Ù‡Ø¯ 3D...</div>';
      disposeScene();

      setTimeout(()=>{
        try{
          const workWcm = parseFloat(document.getElementById('workWidth').value) || 30;
          const workHcm = parseFloat(document.getElementById('workHeight').value) || 20;
          const workWmm = cmToMm(workWcm), workHmm = cmToMm(workHcm);

          const sceneUnitPerMm = 1/10; // 1 scene unit = 10 mm
          const planeWidth = workWmm * sceneUnitPerMm;
          const planeHeight = workHmm * sceneUnitPerMm;

          const segX = Math.max(1, previewCanvas.width-1);
          const segY = Math.max(1, previewCanvas.height-1);

          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 1000);
          const renderer = new THREE.WebGLRenderer({antialias:true});
          renderer.setSize(container.clientWidth, container.clientHeight);
          renderer.setClearColor(0x041022);
          container.innerHTML = '';
          container.appendChild(renderer.domElement);

          const controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true; controls.dampingFactor = 0.05;

          const ambient = new THREE.AmbientLight(0x555555); scene.add(ambient);
          const dir = new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(1,1,1); scene.add(dir);

          const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight, segX, segY);
          const material = new THREE.MeshPhongMaterial({color:0x06b6d4,side:THREE.DoubleSide,flatShading:true});
          const plane = new THREE.Mesh(geometry, material);
          plane.rotation.x = -Math.PI/2;
          scene.add(plane);

          // ÙˆØ¶Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
          camera.position.set(0, Math.max(planeWidth,planeHeight), Math.max(planeWidth,planeHeight)*0.8 + 2);
          camera.lookAt(scene.position);
          controls.update();

          // Ø­ÙØ¸ Ø§Ù„Ù…Ø±Ø§Ø¬Ø¹
          currentScene = { scene, camera, renderer, controls, geometry, material, plane, sceneUnitPerMm, segX, segY, planeWidth, planeHeight };

          // RENDER LOOP
          function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }
          animate();

          // Ø§Ø³ØªÙ…Ø¹ Ù„ØªØºÙŠØ± Ø§Ù„Ø­Ø¬Ù…
          window.addEventListener('resize', ()=> {
            if(!currentScene || !currentScene.camera || !currentScene.renderer) return;
            currentScene.camera.aspect = container.clientWidth/container.clientHeight;
            currentScene.camera.updateProjectionMatrix();
            currentScene.renderer.setSize(container.clientWidth, container.clientHeight);
          });

          // Ø­Ø³Ø§Ø¨ Ø§Ø±ØªÙØ§Ø¹Ø§Øª Ø§ÙˆÙ„ Ù…Ø±Ø©
          update3DHeights();
          showToast('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯');
        }catch(err){ console.error(err); container.innerHTML = '<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#f88">Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ 3D</div>'; showToast('âŒ Ø®Ø·Ø£ ÙÙŠ 3D'); }
      },50);
    }

    // Ø¥Ø¹Ø§Ø¯Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª ÙÙŠ Ø§Ù„Ù€ geometry Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± scaleZ Ø£Ùˆ maxDepth
    function update3DHeights(){
      if(!currentScene || !grayMat || !previewCanvas) return;
      const geometry = currentScene.geometry;
      const positions = geometry.attributes.position.array;
      const segX = currentScene.segX;
      const segY = currentScene.segY;
      const sceneUnitPerMm = currentScene.sceneUnitPerMm;
      const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3.0;
      scaleZ = parseFloat(document.getElementById('scaleZSlider').value) || 1.0;
      document.getElementById('scaleZVal').textContent = scaleZ.toFixed(2);

      for(let i=0;i<positions.length;i+=3){
        const vi = i/3;
        const ix = vi % (segX+1);
        const iy = Math.floor(vi / (segX+1));
        const xPix = Math.round((ix / (segX)) * (previewCanvas.width-1));
        const yPix = Math.round((iy / (segY)) * (previewCanvas.height-1));
        const gray = sampleGrayAt(xPix, yPix);
        const depthMm = ((255 - gray) / 255) * maxDepth * scaleZ; // mm
        const depthScene = depthMm * sceneUnitPerMm; // scene units
        positions[i+2] = depthScene;
      }
      geometry.attributes.position.needsUpdate = true;
      geometry.computeVertexNormals();
    }

    document.getElementById('scaleZSlider').addEventListener('input', ()=>{
      if(currentScene) update3DHeights();
    });
    document.getElementById('maxDepth').addEventListener('input', ()=>{
      if(currentScene) update3DHeights();
    });

    // ===== ØªÙˆÙ„ÙŠØ¯ G-code Ù…Ø­Ø³Ù‘Ù† =====
    document.getElementById('btnGen').addEventListener('click', ()=>{
      if(!grayMat || !previewCanvas){ showToast('âš ï¸ Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø©ØŒ Ø§Ø±ÙØ¹ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹'); return; }
      try{
        const workWcm = parseFloat(document.getElementById('workWidth').value) || 30;
        const workHcm = parseFloat(document.getElementById('workHeight').value) || 20;
        const workWmm = cmToMm(workWcm), workHmm = cmToMm(workHcm);
        const originXcm = parseFloat(document.getElementById('originX').value) || 0;
        const originYcm = parseFloat(document.getElementById('originY').value) || 0;
        const originXmm = cmToMm(originXcm), originYmm = cmToMm(originYcm);
        const feedRate = parseFloat(document.getElementById('feedRate').value) || 800;
        const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
        const scanDir = document.getElementById('scanDir').value || 'x';
        const stepOver = parseFloat(document.getElementById('stepOver').value) || 5;
        const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3.0;

        const scaleX = workWmm / previewCanvas.width;
        const scaleY = workHmm / previewCanvas.height;

        // clear progress
        document.getElementById('genProgress').style.width = '0%';

        let gcode = `; G-code generated by CNC AI\\n`;
        gcode += `; Work area: ${workWmm.toFixed(1)} x ${workHmm.toFixed(1)} mm\\n`;
        gcode += `; Max depth: ${maxDepth.toFixed(2)} mm | StepOver: ${stepOver.toFixed(2)} mm\\n`;
        gcode += `G21\\nG90\\nG17\\nG94\\n\\n`;
        gcode += `G0 Z${safeZ.toFixed(3)} ; safe Z\\n`;
        gcode += `G0 X${originXmm.toFixed(3)} Y${originYmm.toFixed(3)} ; origin\\n\\n`;

        // stepOver in pixels (choose based on X or Y scaling)
        const pxPerMmX = previewCanvas.width / workWmm;
        const pxPerMmY = previewCanvas.height / workHmm;
        const pxStep = Math.max(1, Math.round(stepOver * Math.max(pxPerMmX, pxPerMmY)));

        // total steps for progress
        const totalSteps = (scanDir === 'x') ? Math.ceil(previewCanvas.height / pxStep) : Math.ceil(previewCanvas.width / pxStep);
        let stepIdx = 0;

        if(scanDir === 'x'){
          for(let y=0; y<previewCanvas.height; y += pxStep){
            let cutting = false;
            // move to line start (rapid)
            const lineYmm = originYmm + y * scaleY;
            gcode += `G0 X${originXmm.toFixed(3)} Y${lineYmm.toFixed(3)}\\n`;
            for(let x=0; x<previewCanvas.width; x++){
              const gray = sampleGrayAt(x,y);
              const depth = ((255 - gray)/255) * maxDepth; // mm
              // threshold minimal depth to avoid tiny moves
              const minDepth = 0.02;
              const targetZ = depth > minDepth ? -depth : safeZ;
              const xmm = originXmm + x * scaleX;
              const ymm = lineYmm;
              if(depth > minDepth && !cutting){
                // plunge to cut depth
                gcode += `G1 Z${(-depth).toFixed(3)} F${Math.max(20, Math.round(feedRate/4))} ; plunge\\n`;
                cutting = true;
              } else if(depth <= minDepth && cutting){
                // lift to safeZ
                gcode += `G0 Z${safeZ.toFixed(3)} ; lift\\n`;
                cutting = false;
              }
              if(cutting){
                gcode += `G1 X${xmm.toFixed(3)} Y${ymm.toFixed(3)} Z${(-depth).toFixed(3)} F${feedRate.toFixed(0)}\\n`;
              } else {
                gcode += `G0 X${xmm.toFixed(3)} Y${ymm.toFixed(3)} ; rapid\\n`;
              }
            }
            if(cutting){ gcode += `G0 Z${safeZ.toFixed(3)} ; lift end of line\\n`; cutting=false; }
            stepIdx++;
            document.getElementById('genProgress').style.width = `${Math.round((stepIdx/totalSteps)*100)}%`;
          }
        } else {
          // scan along Y (columns)
          for(let x=0; x<previewCanvas.width; x += pxStep){
            let cutting = false;
            const lineXmm = originXmm + x * scaleX;
            gcode += `G0 X${lineXmm.toFixed(3)} Y${originYmm.toFixed(3)}\\n`;
            for(let y=0; y<previewCanvas.height; y++){
              const gray = sampleGrayAt(x,y);
              const depth = ((255 - gray)/255) * maxDepth;
              const minDepth = 0.02;
              const targetZ = depth > minDepth ? -depth : safeZ;
              const xmm = lineXmm;
              const ymm = originYmm + y * scaleY;
              if(depth > minDepth && !cutting){
                gcode += `G1 Z${(-depth).toFixed(3)} F${Math.max(20, Math.round(feedRate/4))} ; plunge\\n`;
                cutting = true;
              } else if(depth <= minDepth && cutting){
                gcode += `G0 Z${safeZ.toFixed(3)} ; lift\\n`;
                cutting = false;
              }
              if(cutting){
                gcode += `G1 X${xmm.toFixed(3)} Y${ymm.toFixed(3)} Z${(-depth).toFixed(3)} F${feedRate.toFixed(0)}\\n`;
              } else {
                gcode += `G0 X${xmm.toFixed(3)} Y${ymm.toFixed(3)} ; rapid\\n`;
              }
            }
            if(cutting){ gcode += `G0 Z${safeZ.toFixed(3)} ; lift end of col\\n`; cutting=false; }
            stepIdx++;
            document.getElementById('genProgress').style.width = `${Math.round((stepIdx/totalSteps)*100)}%`;
          }
        }

        gcode += `\\nG0 Z${safeZ.toFixed(3)}\\nG0 X${originXmm.toFixed(3)} Y${originYmm.toFixed(3)}\\nM30\\n`;
        document.getElementById('gcodeOut').value = gcode;
        document.getElementById('gcodeSimTab').disabled = false;
        isGcodeGenerated = true;
        document.getElementById('genProgress').style.width = '100%';
        showToast('âœ… ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code');
      }catch(e){ console.error(e); showToast('âŒ Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ G-code'); }
    });

    // ===== ØªØ­Ù…ÙŠÙ„ G-code ÙƒÙ…Ù„Ù =====
    document.getElementById('btnDownload').addEventListener('click', ()=>{
      const g = document.getElementById('gcodeOut').value;
      if(!g || g.trim()===''){ showToast('âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„Ù„ØªØ­Ù…ÙŠÙ„'); return; }
      const blob = new Blob([g],{type:'text/plain'}); const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'cnc_ai_gcode.nc'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
      showToast('ğŸ’¾ ØªÙ… ØªØ­Ù…ÙŠÙ„ G-code');
    });

    // ===== Ù…Ø­Ø§ÙƒØ§Ø© G-code (Ù…Ø¨Ø³Ø·Ø©) =====
    function initGcodeSimulation(){
      if(!isGcodeGenerated){ showToast('âš ï¸ ØªÙˆÙ„ÙŠØ¯ G-code Ø£ÙˆÙ„Ø§Ù‹'); return; }
      const container = document.getElementById('gcodeSimContainer');
      container.innerHTML = '<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#9bb0c8">Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©...</div>';
      if(gcodeSimScene){ try{ if(gcodeSimScene.renderer && gcodeSimScene.renderer.domElement && gcodeSimScene.renderer.domElement.parentNode) gcodeSimScene.renderer.domElement.parentNode.removeChild(gcodeSimScene.renderer.domElement); if(gcodeSimAnimationId){ cancelAnimationFrame(gcodeSimAnimationId); gcodeSimAnimationId=null; } }catch(e){} gcodeSimScene=null; }
      setTimeout(()=>{
        try{
          const scene = new THREE.Scene();
          const camera = new THREE.PerspectiveCamera(60, container.clientWidth/container.clientHeight, 0.1, 1000);
          const renderer = new THREE.WebGLRenderer({antialias:true});
          renderer.setSize(container.clientWidth, container.clientHeight);
          renderer.setClearColor(0x06111a);
          container.innerHTML = ''; container.appendChild(renderer.domElement);
          const controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping=true; controls.dampingFactor=0.05;
          const ambient = new THREE.AmbientLight(0x555555); scene.add(ambient);
          const dir = new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(1,1,1); scene.add(dir);
          const grid = new THREE.GridHelper(40,40,0x222222,0x111111); scene.add(grid);
          const axes = new THREE.AxesHelper(20); scene.add(axes);

          // Ù…Ù†ØµØ© Ø§Ù„Ø¹Ù…Ù„ Ø­Ø³Ø¨ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
          const workWmm = cmToMm(parseFloat(document.getElementById('workWidth').value) || 30);
          const workHmm = cmToMm(parseFloat(document.getElementById('workHeight').value) || 20);
          const sceneUnitPerMm = 1/10;
          const platform = new THREE.Mesh(new THREE.BoxGeometry(workWmm*sceneUnitPerMm, workHmm*sceneUnitPerMm, 0.5), new THREE.MeshPhongMaterial({color:0x333333}));
          platform.position.z = -0.25; scene.add(platform);

          // Ø£Ø¯Ø§Ø©
          const tool = new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.2,1,8), new THREE.MeshPhongMaterial({color:0xff3333}));
          tool.position.set(0,0,1); scene.add(tool);

          // path
          const pathPoints = []; const pathGeo = new THREE.BufferGeometry().setFromPoints(pathPoints);
          const pathMat = new THREE.LineBasicMaterial({color:0x06b6d4});
          const path = new THREE.Line(pathGeo, pathMat); scene.add(path);

          camera.position.set(20,20,20); camera.lookAt(0,0,0); controls.update();

          gcodeSimScene = { scene, camera, renderer, controls, tool, path, pathPoints, sceneUnitPerMm };

          // controls UI
          const simControls = document.createElement('div'); simControls.className='sim-controls';
          simControls.style.position='absolute'; simControls.style.bottom='10px'; simControls.style.left='10px';
          simControls.innerHTML = '<button id=\"simPlay\">â–¶</button><button id=\"simPause\">â¸</button><button id=\"simReset\">â¹</button>';
          container.appendChild(simControls);
          const simInfo = document.createElement('div'); simInfo.className='sim-info'; simInfo.style.position='absolute'; simInfo.style.top='10px'; simInfo.style.left='10px'; simInfo.textContent='Ø¬Ø§Ù‡Ø² Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø©'; container.appendChild(simInfo);

          document.getElementById('simPlay').addEventListener('click', ()=> startGcodeSimulation());
          document.getElementById('simPause').addEventListener('click', ()=>{
            if(gcodeSimAnimationId){ cancelAnimationFrame(gcodeSimAnimationId); gcodeSimAnimationId=null; simInfo.textContent='Ù…ØªÙˆÙ‚Ù'; }
          });
          document.getElementById('simReset').addEventListener('click', ()=>{
            if(gcodeSimAnimationId){ cancelAnimationFrame(gcodeSimAnimationId); gcodeSimAnimationId=null; }
            gcodeSimScene.tool.position.set(0,0,1); gcodeSimScene.pathPoints.length=0; gcodeSimScene.path.geometry.setFromPoints(gcodeSimScene.pathPoints); simInfo.textContent='Ø¬Ø§Ù‡Ø²';
          });

          function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene,camera); }
          animate();
          showToast('âœ… ØªÙ… ØªØ­Ø¶ÙŠØ± Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
        }catch(e){ console.error(e); container.innerHTML = '<div style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#f88">Ø®Ø·Ø£ ÙÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©</div>'; showToast('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©'); }
      },50);
    }

    function startGcodeSimulation(){
      if(!gcodeSimScene){ showToast('âš ï¸ Ù„Ù… ÙŠØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©'); return; }
      const gcode = document.getElementById('gcodeOut').value;
      if(!gcode || gcode.trim()===''){ showToast('âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code'); return; }
      const lines = gcode.split('\\n');
      const tool = gcodeSimScene.tool;
      const path = gcodeSimScene.path;
      const points = gcodeSimScene.pathPoints;
      points.length = 0; path.geometry.setFromPoints(points);
      let idx = 0;
      function step(){
        if(idx >= lines.length){ gcodeSimAnimationId = null; return; }
        const line = lines[idx++].trim();
        if(line.startsWith('G1')||line.startsWith('G0')){
          const xm = (line.match(/X([\\d.-]+)/) || [])[1];
          const ym = (line.match(/Y([\\d.-]+)/) || [])[1];
          const zm = (line.match(/Z([\\d.-]+)/) || [])[1];
          if(xm && ym){
            const x = parseFloat(xm) / 10; // mm->scene units scale used earlier
            const y = parseFloat(ym) / 10;
            const z = zm ? (parseFloat(zm)/10 + 1) : tool.position.z;
            tool.position.set(x, y, z);
            points.push(new THREE.Vector3(x,y,z));
            path.geometry.setFromPoints(points);
          }
        }
        gcodeSimAnimationId = requestAnimationFrame(step);
      }
      step();
    }

    // ===== Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØµÙØ­Ø© =====
    document.addEventListener('DOMContentLoaded', ()=>{
      setTimeout(()=> showToast('Ù…Ø±Ø­Ø¨Ø§Ù‹ â€” Ø§Ø±ÙØ¹ ØµÙˆØ±Ø© Ù„Ù„Ø¨Ø¯Ø¡'), 700);
    });
  </script>
</body>
</html>
