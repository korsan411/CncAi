<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>CNC AI â€” Raster Ø¯Ø§Ø®Ù„ Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ± + Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</title>

  <!-- Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ùˆ OpenCV -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/OrbitControls.js"></script>
  <script async src="https://docs.opencv.org/4.8.0/opencv.js"></script>

  <style>
    :root{
      --bg:#041022; --panel:#0b1320; --muted:#9bb0c8; --accent:#06b6d4; --text:#e6eef6; --card-border:#1e293b;
    }
    body{ margin:0; font-family:Arial,Segoe UI,system-ui; background:var(--bg); color:var(--text); }
    .app{ max-width:1400px; margin:16px auto; padding:14px; }
    header{ display:flex; justify-content:space-between; align-items:center; padding:12px 16px; border-bottom:1px solid var(--card-border); }
    .grid{ display:grid; grid-template-columns:1fr 460px; gap:16px; }
    @media(max-width:1000px){ .grid{ grid-template-columns:1fr; } }
    .panel{ background:var(--panel); padding:14px; border-radius:10px; border:1px solid var(--card-border); }
    .tabs{ display:flex; gap:6px; border-bottom:1px solid var(--card-border); margin-top:12px;}
    .tabs button{ padding:8px 12px; border-radius:6px 6px 0 0; border:none; background:transparent; color:var(--muted); cursor:pointer; }
    .tabs button.active{ background:var(--accent); color:#021; }
    .tab-content{ display:none; margin-top:12px; }
    .tab-content.active{ display:block; }
    .canvas-placeholder{ width:100%; height:320px; background:#000; border-radius:6px; display:flex; align-items:center; justify-content:center; color:var(--muted); border:1px solid #334155; }
    canvas{ display:block; border-radius:6px; background:#000; max-width:100%; border:1px solid #334155; transform-origin: top left; }
    .file-input-container{ position:relative; width:100%; margin-bottom:8px; }
    .file-input-label{ display:block; padding:10px; background:#1e293b; color:var(--text); text-align:center; border-radius:6px; cursor:pointer; border:2px dashed #334155; }
    .controls-row{ display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap;}
    label{ font-weight:bold; color:var(--text); display:block; margin-top:8px; }
    input, select, textarea{ padding:8px 10px; border-radius:6px; border:1px solid var(--card-border); background:#0f172a; color:var(--text); margin-top:6px; width:100%; }
    .button-group{ display:flex; flex-direction:column; gap:8px; margin-top:12px; }
    button.primary{ background:var(--accent); color:#021; border:none; padding:10px; border-radius:8px; cursor:pointer; }
    button.secondary{ background:#1e293b; color:var(--text); border:none; padding:10px; border-radius:8px; cursor:pointer; }
    #toast{ position:fixed; left:16px; bottom:16px; background:rgba(0,0,0,0.85); color:#fff; padding:10px 14px; border-radius:8px; display:none; z-index:10000; }
    .progress-bar{ width:100%; height:8px; background:#111827; border-radius:6px; overflow:hidden; margin-top:8px; }
    .progress-fill{ height:100%; width:0%; background:var(--accent); transition:width .2s; }
    .meta-line{ font-size:0.85rem; color:var(--muted); margin-top:8px; }
    #threeContainer{ width:100%; height:380px; background:#081224; border-radius:8px; overflow:hidden; position:relative; }
    .simulation-controls{ position:absolute; top:10px; left:10px; z-index:100; display:flex; gap:8px; }
    .simulation-info{ position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,0.6); color:white; padding:8px 12px; border-radius:4px; font-size:0.8rem; }
    textarea{ width:100%; height:200px; resize:vertical; }
    .adv-toggle{ width:100%; padding:8px; border-radius:6px; background:#263244; color:var(--text); border:1px solid #334155; cursor:pointer; margin-top:10px; }
    .adv-section{ display:none; margin-top:10px; padding:10px; border:1px solid #334155; border-radius:8px; background:#07102a; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1 style="margin:0; color:var(--accent)">CNC AI â€” Raster Ø¯Ø§Ø®Ù„ Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±</h1>
      <div style="display:flex; gap:10px; align-items:center;">
        <div id="cvState"><span style="display:inline-block;width:14px;height:14px;border:2px solid var(--accent);border-radius:50%;margin-left:8px"></span> Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ OpenCV...</div>
      </div>
    </header>

    <div class="grid">
      <!-- left: previews -->
      <div class="panel">
        <div class="file-input-container">
          <input id="fileInput" type="file" accept="image/*" style="opacity:0; position:absolute; left:0; top:0; width:100%; height:100%; cursor:pointer;"/>
          <label class="file-input-label" for="fileInput">ğŸ“ Ø§Ø®ØªØ± ØµÙˆØ±Ø© Ù„Ù„ØªØ­Ù…ÙŠÙ„</label>
        </div>
        <div id="imageMeta" class="meta-line">Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ù…Ø­Ù…Ù„Ø©</div>

        <div class="tabs">
          <button data-tab="original" class="active">ğŸ–¼ï¸ Ø§Ù„Ø£ØµÙ„ÙŠØ©</button>
          <button data-tab="heatmap">ğŸ”¥ Heatmap</button>
          <button data-tab="contour">ğŸ“ Ø§Ù„Ø­ÙˆØ§Ù</button>
          <button data-tab="simulation">ğŸ¬ Ù…Ø­Ø§ÙƒØ§Ø© 3D</button>
        </div>

        <div id="original" class="tab-content active">
          <div class="canvas-placeholder" id="originalPlaceholder">Ø³ÙŠØªÙ… Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø© Ù‡Ù†Ø§</div>
          <canvas id="canvasOriginal" style="display:none;"></canvas>
        </div>

        <div id="heatmap" class="tab-content">
          <div class="canvas-placeholder" id="heatmapPlaceholder">Heatmap Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
          <canvas id="canvasHeatmap" style="display:none;"></canvas>
          <div class="controls-row" style="margin-top:8px;">
            <label style="width:100%;">Colormap:
              <select id="colormapSelect" style="width:100%;"><option value="jet">Jet</option><option value="hot">Hot</option><option value="cool">Cool</option><option value="gray">Gray</option></select>
            </label>
          </div>
        </div>

        <div id="contour" class="tab-content">
          <div class="canvas-placeholder" id="contourPlaceholder">Contour Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
          <canvas id="canvasContour" style="display:none;"></canvas>
          <div class="controls-row">
            <label><input type="checkbox" id="showAllContours" checked/> Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±Ø§Øª Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©</label>
          </div>
        </div>

        <div id="simulation" class="tab-content">
          <div id="threeContainer">
            <div class="canvas-placeholder" id="simulationPlaceholder">Ù…Ø­Ø§ÙƒØ§Ø© 3D Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªÙˆÙ„ÙŠØ¯ G-code</div>
          </div>
        </div>
      </div>

      <!-- right: settings -->
      <div class="panel">
        <h3 style="margin-top:0;color:var(--muted)">âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</h3>

        <label>Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</label>
        <select id="machineType"><option value="router">Router CNC</option><option value="laser">Laser Engraver</option><option value="plasma">Plasma Cutter</option></select>

        <label>Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù…Ù„ (Ø³Ù…)</label><input id="workWidth" type="number" value="30" step="0.1"/>
        <label>Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¹Ù…Ù„ (Ø³Ù…)</label><input id="workHeight" type="number" value="20" step="0.1"/>
        <label>Ø¹Ù…Ù‚ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label><input id="workDepth" type="number" value="3.0" step="0.1"/>

        <label>Ø³Ø±Ø¹Ø© Ø§Ù„ØªØºØ°ÙŠØ© (Ù…Ù…/Ø¯Ù‚ÙŠÙ‚Ø©)</label><input id="feedRate" type="number" value="800" />
        <label>Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø£Ù…Ø§Ù† (Ù…Ù…)</label><input id="safeZ" type="number" value="5" step="0.1"/>
        <label>Ø®Ø·ÙˆØ© Ø§Ù„Ù…Ø³Ø­ (Ù…Ù…)</label><input id="stepOver" type="number" value="5" step="0.1"/>
        <label>Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ (Ù…Ù…)</label><input id="maxDepth" type="number" value="3.0" step="0.1"/>

        <button class="adv-toggle" id="advToggle">âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© (Ø§Ø¶ØºØ· Ù„Ù„ÙØªØ­/Ø§Ù„ØºÙ„Ù‚)</button>
        <div class="adv-section" id="advSection">
          <label>ğŸª„ Ù†Ø¹ÙˆÙ…Ø© Ø§Ù„Ø³Ø·Ø­ (Smoothing)
            <select id="smoothing">
              <option value="none">Ø¨Ø¯ÙˆÙ†</option>
              <option value="low">Ù…Ù†Ø®ÙØ¶</option>
              <option value="medium">Ù…ØªÙˆØ³Ø·</option>
              <option value="high">Ø¹Ø§Ù„ÙŠ</option>
            </select>
          </label>

          <label>ğŸ“ Ù…Ù‚ÙŠØ§Ø³ Ø§Ù„Ø¹Ù…Ù‚ Z (Z Scale)
            <input id="zScale" type="number" value="1.0" step="0.1"/>
          </label>

          <label><input type="checkbox" id="invertZ"> Ø¹ÙƒØ³ Ø§Ù„Ø¹Ù…Ù‚ (Invert Z)</label>

          <label>â†”ï¸ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø³Ø­ (Scan Direction)
            <select id="scanDir"><option value="x">Ø£ÙÙ‚ÙŠ (X)</option><option value="y">Ø¹Ù…ÙˆØ¯ÙŠ (Y)</option><option value="diag">Ù‚Ø·Ø±ÙŠ</option></select>
          </label>

          <label><input type="checkbox" id="detailFilter"> ÙÙ„ØªØ±Ø© Ø§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØµØºÙŠØ±Ø© (Downsample)</label>
        </div>

        <div style="margin-top:12px;" class="controls-row">
          <button id="btnGen" class="primary">âš¡ ØªÙˆÙ„ÙŠØ¯ G-code (Raster Ø¯Ø§Ø®Ù„ Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±)</button>
          <button id="btnDownload" class="secondary">ğŸ’¾ ØªØ­Ù…ÙŠÙ„ G-code</button>
        </div>

        <div class="progress-bar" aria-hidden="true"><div class="progress-fill" id="procFill"></div></div>
        <div id="estTime" class="meta-line"></div>

        <label style="margin-top:12px">ğŸ“„ Ù…Ø®Ø±Ø¬Ø§Øª G-code</label>
        <textarea id="gcodeOut" readonly></textarea>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <script>
  // ======= UI helpers =======
  function showToast(msg, ms=2500){ const t=document.getElementById('toast'); t.textContent=msg; t.style.display='block'; clearTimeout(t._t); t._t=setTimeout(()=>t.style.display='none', ms); }

  // Tabs
  document.querySelectorAll('.tabs button').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      document.querySelectorAll('.tabs button').forEach(b=>b.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(tc=>tc.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById(btn.dataset.tab).classList.add('active');
      if(btn.dataset.tab==='simulation' && document.getElementById('gcodeOut').value) initSimulation();
    });
  });

  // Advanced toggle
  document.getElementById('advToggle').addEventListener('click', ()=> {
    const s = document.getElementById('advSection');
    s.style.display = s.style.display === 'block' ? 'none' : 'block';
  });

  // Zoom simple
  function applyZoom(canvasId, s){ const c=document.getElementById(canvasId); if(!c) return; c.style.transform=`scale(${s})`; c._scale=s; }
  // (optional add zoom buttons if needed)

  // ======= OpenCV readiness =======
  let cvReady=false;
  function onOpenCvReady(){ cvReady=true; document.getElementById('cvState').innerText='âœ… OpenCV Ø¬Ø§Ù‡Ø²'; showToast('OpenCV Ø¬Ø§Ù‡Ø²'); }
  (function waitCv(){ if(typeof cv!=='undefined' && cv.getBuildInformation){ if(cv.onRuntimeInitialized!==undefined) cv['onRuntimeInitialized']=onOpenCvReady; else onOpenCvReady(); } else setTimeout(waitCv,150); })();

  // ======= State =======
  let grayMat=null; // cv.Mat grayscale (after optional downsample)
  let origMat=null; // original rgba mat for reference
  let mainContour=null; // cv.Mat contour
  let extraContours=[]; // array of Mat
  let previewCanvas=document.getElementById('canvasOriginal');
  let currentImageName='image';

  // File input
  document.getElementById('fileInput').addEventListener('change', e=>{
    const f=e.target.files[0]; if(!f) return;
    currentImageName = (f.name||'image').replace(/\.[^/.]+$/,'').replace(/\s+/g,'_');
    const img=new Image();
    img.onload = ()=>{
      // draw to canvas
      previewCanvas.width = img.width; previewCanvas.height = img.height;
      const ctx = previewCanvas.getContext('2d');
      ctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
      ctx.drawImage(img,0,0);
      document.getElementById('originalPlaceholder').style.display='none';
      previewCanvas.style.display='block';
      document.getElementById('imageMeta').textContent = `Ø§Ù„Ù…Ù„Ù: ${f.name} â€” Ù…Ø¹Ø§ÙŠÙ†Ø©: ${img.width}Ã—${img.height}`;

      // cleanup mats
      try{ if(grayMat){ grayMat.delete(); grayMat=null; } }catch(e){}
      try{ if(origMat){ origMat.delete(); origMat=null; } }catch(e){}
      try{ if(mainContour){ mainContour.delete(); mainContour=null; } }catch(e){}
      extraContours.forEach(c=>{ try{ c.delete(); }catch(e){} }); extraContours=[];

      if(!cvReady){ showToast('Ø§Ù†ØªØ¸Ø§Ø± OpenCV...'); const t=setInterval(()=>{ if(cvReady){ clearInterval(t); detectContoursAndRender(); } },150); }
      else detectContoursAndRender();
    };
    img.onerror = ()=> showToast('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©');
    img.src = URL.createObjectURL(f);
  });

  // ======= Detect contours, build grayMat (with smoothing/downsample when previewing) =======
  function detectContoursAndRender() {
    try {
      const src = cv.imread(previewCanvas); // RGBA mat
      origMat = src.clone();
      // convert to grayscale full-res
      const gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

      // smoothing for contour detection: small blur to reduce noise (not user smoothing)
      const blur = new cv.Mat();
      cv.GaussianBlur(gray, blur, new cv.Size(3,3), 0);

      // edges
      const edges = new cv.Mat();
      const median = cv.mean(blur).w;
      const lower = Math.max(0,(1.0-0.33)*median);
      const upper = Math.min(255,(1.0+0.33)*median);
      cv.Canny(blur, edges, lower, upper);
      const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
      cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);

      // contours
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

      // filter by area
      const minArea = (gray.cols * gray.rows) * 0.002; // 0.2% min area threshold
      const valids=[];
      for(let i=0;i<contours.size();i++){
        const c=contours.get(i);
        const a = cv.contourArea(c);
        if(a>minArea) valids.push({contour:c, area:a});
        else c.delete();
      }

      if(valids.length===0){ showToast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙˆÙ†ØªÙˆØ± ÙƒØ§ÙÙ'); }
      else {
        valids.sort((a,b)=>b.area - a.area);
        mainContour = valids[0].contour; // keep mat
        extraContours = valids.slice(1).map(v=>v.contour);
        showToast(`ØªÙ… ÙƒØ´Ù ${valids.length} ÙƒÙˆÙ†ØªÙˆØ± â€” Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£ÙƒØ¨Ø±`);
      }

      // store grayMat for generation (not smoothed by user yet)
      if(grayMat) try{ grayMat.delete(); }catch(e){}
      grayMat = gray.clone();

      // render heatmap and contours
      renderHeatmap(grayMat);
      renderContours(grayMat, mainContour);

      // cleanup locals
      blur.delete(); edges.delete(); hierarchy.delete(); contours.delete(); kernel.delete();
      // keep src in origMat (deleted earlier if present)
      src.delete();
    } catch (err) {
      console.error(err); showToast('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ÙƒØ´Ù: '+(err.message||err));
    }
  }

  // ======= Heatmap rendering respecting smoothing selection =======
  function renderHeatmap(baseGrayMat) {
    if(!baseGrayMat) return;
    // apply user smoothing to a preview copy
    let tmp = new cv.Mat();
    const s = document.getElementById('smoothing').value;
    if(s==='low') cv.GaussianBlur(baseGrayMat, tmp, new cv.Size(3,3), 0);
    else if(s==='medium') cv.GaussianBlur(baseGrayMat, tmp, new cv.Size(5,5), 0);
    else if(s==='high') cv.GaussianBlur(baseGrayMat, tmp, new cv.Size(9,9), 0);
    else baseGrayMat.copyTo(tmp);

    const canvas = document.getElementById('canvasHeatmap');
    const ctx = canvas.getContext('2d');
    canvas.width = tmp.cols; canvas.height = tmp.rows;
    const imgData = ctx.createImageData(canvas.width, canvas.height);
    const dat = tmp.data;
    const cmap = document.getElementById('colormapSelect').value;
    for(let i=0;i<dat.length;i++){
      const v = dat[i];
      const idx = i*4;
      let r=0,g=0,b=0;
      if(cmap==='jet'){ r = Math.max(0,Math.min(255,(v-128)*2)); g = Math.max(0,Math.min(255,255 - Math.abs(v-128)*2)); b = Math.max(0,Math.min(255,(128-v)*2)); }
      else if(cmap==='hot'){ r=v; g=Math.round(v*0.5); b=Math.round(v*0.1); }
      else if(cmap==='cool'){ r=255-v; g=v; b=255; }
      else { r=g=b=v; }
      imgData.data[idx]=r; imgData.data[idx+1]=g; imgData.data[idx+2]=b; imgData.data[idx+3]=255;
    }
    ctx.putImageData(imgData,0,0);
    document.getElementById('heatmapPlaceholder').style.display='none'; canvas.style.display='block';
    tmp.delete();
  }

  // ======= Contour rendering =======
  function renderContours(baseGrayMat, mainCnt){
    const canvas = document.getElementById('canvasContour');
    const ctx = canvas.getContext('2d');
    canvas.width = baseGrayMat.cols; canvas.height = baseGrayMat.rows;
    // ensure heatmap background exists
    const heat = document.getElementById('canvasHeatmap');
    if (heat.width !== canvas.width || heat.height !== canvas.height) renderHeatmap(baseGrayMat);
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.drawImage(heat, 0, 0);
    if(mainCnt){
      ctx.strokeStyle='#00ff00'; ctx.lineWidth=2; ctx.beginPath();
      const d = mainCnt.data32S;
      for(let i=0;i<d.length;i+=2){ const x=d[i], y=d[i+1]; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      ctx.closePath(); ctx.stroke();
    }
    if(document.getElementById('showAllContours').checked){
      ctx.strokeStyle='#ffff00'; ctx.lineWidth=1;
      extraContours.forEach(cnt=>{
        ctx.beginPath(); const d=cnt.data32S;
        for(let i=0;i<d.length;i+=2){ const x=d[i], y=d[i+1]; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
        ctx.closePath(); ctx.stroke();
      });
    }
    document.getElementById('contourPlaceholder').style.display='none'; canvas.style.display='block';
  }

  // ======= Build mask (Uint8Array) inside mainContour using cv.pointPolygonTest =======
  // Returns Uint8Array length width*height with 1 for inside, 0 for outside
  function buildMaskFromContour(mat, contour) {
    const w = mat.cols, h = mat.rows;
    const mask = new Uint8Array(w*h);
    if(!contour) return mask;
    // bounding rect to speed up
    const rect = cv.boundingRect(contour);
    const minX = Math.max(0, rect.x), maxX = Math.min(w-1, rect.x+rect.width-1);
    const minY = Math.max(0, rect.y), maxY = Math.min(h-1, rect.y+rect.height-1);
    for(let y=minY;y<=maxY;y++){
      for(let x=minX;x<=maxX;x++){
        const pt = new cv.Point(x,y);
        const res = cv.pointPolygonTest(contour, pt, false);
        pt.delete();
        if(res >= 0) mask[y*w + x] = 1;
      }
    }
    return {mask, w, h};
  }

  // ======= Create Worker for G-code generation =======
  function createGcodeWorker() {
    const code = `
      onmessage = function(e){
        try{
          const { buf, mask, width, height, params } = e.data;
          const stepPx = params.stepPx;
          const feed = params.feed;
          const safeZ = params.safeZ;
          const maxDepth = params.maxDepth;
          const zScale = params.zScale;
          const invertZ = params.invertZ;
          const dir = params.dir; // 'x','y','diag'
          const includeComments = true;
          const lines = [];
          lines.push('; Generated by CNC AI (Raster inside contour)');
          lines.push('G21 G90 G17');
          lines.push('G0 Z' + safeZ.toFixed(2));
          const w = width, h = height;

          function sample(px,py){
            return buf[py*w + px];
          }

          if(dir==='x'){
            for(let y=0;y<h;y+=stepPx){
              let rowLines = [];
              for(let x=0;x<w;x++){
                if(mask[y*w + x]){
                  const pv = sample(x,y);
                  let z = -((255 - pv)/255.0) * maxDepth * zScale;
                  if(invertZ) z = -z;
                  rowLines.push({x,y,z});
                } else {
                  // mark gap with null separator
                  rowLines.push(null);
                }
              }
              // now convert contiguous segments into G-code
              let i=0;
              while(i<rowLines.length){
                // skip null
                while(i<rowLines.length && rowLines[i]==null) i++;
                if(i>=rowLines.length) break;
                // start segment
                const segStart = i;
                while(i<rowLines.length && rowLines[i]!=null) i++;
                const segEnd = i-1;
                // rapid move to start at safeZ
                const p0 = rowLines[segStart];
                lines.push(includeComments?('; Row Y='+y+' segStart='+segStart):'');
                lines.push('G0 X'+p0.x.toFixed(2)+' Y'+p0.y.toFixed(2)+' Z'+safeZ.toFixed(2));
                lines.push('G1 F'+feed.toFixed(0));
                for(let xi=segStart; xi<=segEnd; xi++){
                  const p = rowLines[xi];
                  lines.push('G1 X'+p.x.toFixed(2)+' Y'+p.y.toFixed(2)+' Z'+p.z.toFixed(3));
                }
                lines.push('G0 Z'+safeZ.toFixed(2));
              }
              // progress update approximate
              if(y % Math.max(1, Math.round(h/20)) === 0) postMessage({type:'progress', progress: Math.round((y/h)*100)});
            }
          } else if(dir==='y'){
            for(let x=0;x<w;x+=stepPx){
              let colLines=[];
              for(let y=0;y<h;y++){
                if(mask[y*w + x]){
                  const pv = sample(x,y);
                  let z = -((255 - pv)/255.0) * maxDepth * zScale;
                  if(invertZ) z=-z;
                  colLines.push({x,y,z});
                } else colLines.push(null);
              }
              let i=0;
              while(i<colLines.length){
                while(i<colLines.length && colLines[i]==null) i++;
                if(i>=colLines.length) break;
                const segStart=i; while(i<colLines.length && colLines[i]!=null) i++; const segEnd=i-1;
                const p0 = colLines[segStart];
                lines.push(includeComments?('; Col X='+x+' segStart='+segStart):'');
                lines.push('G0 X'+p0.x.toFixed(2)+' Y'+p0.y.toFixed(2)+' Z'+safeZ.toFixed(2));
                lines.push('G1 F'+feed.toFixed(0));
                for(let yi=segStart; yi<=segEnd; yi++){
                  const p = colLines[yi];
                  lines.push('G1 X'+p.x.toFixed(2)+' Y'+p.y.toFixed(2)+' Z'+p.z.toFixed(3));
                }
                lines.push('G0 Z'+safeZ.toFixed(2));
              }
              if(x % Math.max(1, Math.round(w/20)) ===0) postMessage({type:'progress', progress: Math.round((x/w)*100)});
            }
          } else { // diag simple: go along d from 0..w+h
            const maxd = w + h;
            for(let d=0; d<maxd; d+=stepPx){
              let diag=[];
              for(let x=0;x<=d;x++){
                const y = d-x;
                if(x<w && y<h){
                  if(mask[y*w + x]){
                    const pv = sample(x,y);
                    let z = -((255 - pv)/255.0) * maxDepth * zScale;
                    if(invertZ) z=-z;
                    diag.push({x,y,z});
                  } else diag.push(null);
                }
              }
              // segments
              let i=0;
              while(i<diag.length){
                while(i<diag.length && diag[i]==null) i++;
                if(i>=diag.length) break;
                const s=i; while(i<diag.length && diag[i]!=null) i++; const e=i-1;
                const p0 = diag[s];
                lines.push(includeComments?('; Diag d='+d+' segStart='+s):'');
                lines.push('G0 X'+p0.x.toFixed(2)+' Y'+p0.y.toFixed(2)+' Z'+safeZ.toFixed(2));
                lines.push('G1 F'+feed.toFixed(0));
                for(let k=s;k<=e;k++){ const p=diag[k]; lines.push('G1 X'+p.x.toFixed(2)+' Y'+p.y.toFixed(2)+' Z'+p.z.toFixed(3)); }
                lines.push('G0 Z'+safeZ.toFixed(2));
              }
              if(d % Math.max(1, Math.round(maxd/20)) === 0) postMessage({type:'progress', progress: Math.round((d/maxd)*100)});
            }
          }

          lines.push('M5'); lines.push('M30');
          postMessage({type:'done', gcode: lines.join('\\n')});
        }catch(err){
          postMessage({type:'error', message: err.message||err});
        }
      };
    `;
    const blob = new Blob([code], {type:'application/javascript'});
    return new Worker(URL.createObjectURL(blob));
  }

  // ======= Trigger G-code generation: prepare buffers, mask, pass to worker =======
  async function generateGcodeInsideContour(){
    if(!grayMat || !mainContour){ showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ø£Ùˆ ÙƒÙˆÙ†ØªÙˆØ± Ø¬Ø§Ù‡Ø² â€” Ø§Ø±ÙØ¹ ØµÙˆØ±Ø© Ø£Ùˆ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±'); return ''; }
    // apply user smoothing and optional downsample to build the generation matrix
    let procMat = new cv.Mat();
    const s = document.getElementById('smoothing').value;
    if(s==='low') cv.GaussianBlur(grayMat, procMat, new cv.Size(3,3), 0);
    else if(s==='medium') cv.GaussianBlur(grayMat, procMat, new cv.Size(5,5), 0);
    else if(s==='high') cv.GaussianBlur(grayMat, procMat, new cv.Size(9,9), 0);
    else grayMat.copyTo(procMat);

    // detailFilter = downsample by factor 2 (user option)
    const doDown = document.getElementById('detailFilter').checked;
    if(doDown){
      const tmp = new cv.Mat();
      cv.resize(procMat, tmp, new cv.Size(Math.max(1,Math.floor(procMat.cols/2)), Math.max(1,Math.floor(procMat.rows/2))), 0, 0, cv.INTER_AREA);
      procMat.delete();
      procMat = tmp;
    }

    // build mask from contour but must map contour coords to procMat if downsample used.
    // If downsample used, compute scale factors from orig grayMat to procMat
    const scaleX = procMat.cols / grayMat.cols;
    const scaleY = procMat.rows / grayMat.rows;

    // Prepare a transformed contour for mask if scaling happened: create a Mat of points scaled
    let contourForMask = null;
    if(doDown){
      // create new contour mat with scaled points
      const data = mainContour.data32S; // [x0,y0,x1,y1,...]
      const scaled = new Int32Array(data.length);
      for(let i=0;i<data.length;i+=2){
        scaled[i] = Math.round(data[i]*scaleX);
        scaled[i+1] = Math.round(data[i+1]*scaleY);
      }
      const mat = cv.matFromArray(data.length/2, 1, cv.CV_32SC2, scaled);
      contourForMask = mat;
    } else {
      contourForMask = mainContour;
    }

    // build mask in main thread
    const maskResult = buildMaskFromContour(procMat, contourForMask);
    const mask = maskResult.mask; const w = maskResult.w; const h = maskResult.h;

    // prepare grayscale buffer to send
    const buf = new Uint8ClampedArray(w*h);
    // copy from procMat (uchar)
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++) buf[y*w + x] = procMat.ucharPtr(y,x)[0];
    }

    // cleanup procMat (we made copy)
    procMat.delete();
    if(doDown && contourForMask !== mainContour) contourForMask.delete(); // delete scaled contour if created

    // compute pixel step from stepOver mm -> pixels using canvas scale:
    const workWidthMM = (parseFloat(document.getElementById('workWidth').value) || 30) * 10;
    const workHeightMM = (parseFloat(document.getElementById('workHeight').value) || 20) * 10;
    const pixelPerMMx = w / workWidthMM;
    const pixelPerMMy = h / workHeightMM;
    // approximate stepPx using average of x/y scale
    const avgPPM = (pixelPerMMx + pixelPerMMy)/2;
    const stepOverMM = parseFloat(document.getElementById('stepOver').value) || 5;
    const stepPx = Math.max(1, Math.round(stepOverMM * avgPPM));

    // worker params
    const feed = parseFloat(document.getElementById('feedRate').value) || 800;
    const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
    const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
    const zScale = parseFloat(document.getElementById('zScale').value) || 1.0;
    const invertZ = document.getElementById('invertZ').checked;
    const dir = document.getElementById('scanDir').value;

    // spawn worker
    const worker = createGcodeWorker();
    document.getElementById('procFill').style.width='0%';

    return new Promise((resolve) => {
      worker.onmessage = function(ev){
        const d = ev.data;
        if(d.type==='progress') document.getElementById('procFill').style.width = d.progress + '%';
        else if(d.type==='done'){
          document.getElementById('procFill').style.width = '100%';
          // Convert pixel X,Y to machine mm coordinates (scale to workWidth/workHeight)
          const scaleXM = workWidthMM / w;
          const scaleYM = workHeightMM / h;
          let g = d.gcode.split('\\n').map(line=>{
            const xm = line.match(/X([\\d.-]+)/); const ym = line.match(/Y([\\d.-]+)/);
            if(xm && ym){
              const px = parseFloat(xm[1]), py = parseFloat(ym[1]);
              const mx = (px * scaleXM).toFixed(2);
              const my = (py * scaleYM).toFixed(2);
              line = line.replace(/X[\\d.-]+/, 'X' + mx);
              line = line.replace(/Y[\\d.-]+/, 'Y' + my);
            }
            return line;
          }).join('\\n');
          worker.terminate();
          resolve(g);
        } else if(d.type==='error'){
          showToast('Ø®Ø·Ø£ ÙÙŠ Worker: '+d.message);
          worker.terminate();
          resolve('');
        }
      };
      // post
      worker.postMessage({ buf, mask, width: w, height: h, params: { stepPx, feed, safeZ, maxDepth, zScale, invertZ, dir } });
    });
  }

  // ======= Button handlers =======
  document.getElementById('btnGen').addEventListener('click', async ()=>{
    document.getElementById('gcodeOut').value = '';
    showToast('Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ G-code â€” Ù‡Ø°Ø§ Ù‚Ø¯ ÙŠØ£Ø®Ø° Ø¨Ø¹Ø¶ Ø§Ù„ÙˆÙ‚Øª Ø­Ø³Ø¨ Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø©');
    const g = await generateGcodeInsideContour();
    if(g){
      document.getElementById('gcodeOut').value = g;
      showToast('ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code Ø¨Ù†Ø¬Ø§Ø­');
      document.querySelector('[data-tab="simulation"]').click();
    } else showToast('ÙØ´Ù„ ØªÙˆÙ„ÙŠØ¯ G-code');
  });

  document.getElementById('btnDownload').addEventListener('click', ()=>{
    const g = document.getElementById('gcodeOut').value;
    if(!g){ showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„ØªØ­Ù…ÙŠÙ„'); return; }
    const now = new Date(); const pad=n=>n.toString().padStart(2,'0');
    const stamp = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}`;
    const name = `cnc_${currentImageName}_${stamp}.gcode`;
    const blob = new Blob([g], {type:'text/plain'}); const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=name; document.body.appendChild(a); a.click(); document.body.removeChild(a);
    URL.revokeObjectURL(url); showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„: '+name);
  });

  // ======= Simulation (simple) =======
  let scene, camera, renderer, controls;
  function parseGcodeForSimulation(gcode){
    const lines = gcode.split('\\n'); const path=[];
    let pos={x:0,y:0,z:0};
    for(const L of lines){
      const t=L.trim();
      if(t.startsWith('G1')||t.startsWith('G0')){
        const xm=t.match(/X([\\d.-]+)/), ym=t.match(/Y([\\d.-]+)/), zm=t.match(/Z([\\d.-]+)/);
        if(xm) pos.x=parseFloat(xm[1]); if(ym) pos.y=parseFloat(ym[1]); if(zm) pos.z=parseFloat(zm[1]);
        path.push({...pos});
      }
    }
    return path;
  }

  function initSimulation(){
    const container=document.getElementById('threeContainer'); container.innerHTML='';
    const g = document.getElementById('gcodeOut').value;
    if(!g){ document.getElementById('simulationPlaceholder').style.display='flex'; showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø©'); return; }
    try{
      document.getElementById('simulationPlaceholder').style.display='none';
      scene = new THREE.Scene(); scene.background = new THREE.Color(0x081224);
      camera = new THREE.PerspectiveCamera(60, container.clientWidth/container.clientHeight, 0.1, 10000);
      camera.position.set(200,200,200);
      renderer = new THREE.WebGLRenderer({ antialias:true }); renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      const ambient = new THREE.AmbientLight(0x404040, 0.8); scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(50,200,100); scene.add(dir);
      const workW = (parseFloat(document.getElementById('workWidth').value)||30)*10;
      const workH = (parseFloat(document.getElementById('workHeight').value)||20)*10;
      const workD = parseFloat(document.getElementById('workDepth').value)||3;
      const geom = new THREE.BoxGeometry(workW, workD, workH);
      const mat = new THREE.MeshPhongMaterial({ color: 0x8B4513, transparent:true, opacity:0.95 });
      const box = new THREE.Mesh(geom, mat); box.position.y = workD/2; scene.add(box);
      const path = parseGcodeForSimulation(g);
      if(path.length>1){
        const pts = path.map(p=> new THREE.Vector3(p.x, p.z+5, p.y));
        const geometry = new THREE.BufferGeometry().setFromPoints(pts);
        const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        const line = new THREE.Line(geometry, material); scene.add(line);
      }
      const tool = new THREE.Mesh(new THREE.CylinderGeometry(2,2,20,12), new THREE.MeshPhongMaterial({ color:0xff4444 })); tool.position.set(0,50,0); scene.add(tool);
      const grid = new THREE.GridHelper(Math.max(workW, workH), 10); scene.add(grid);
      const axes = new THREE.AxesHelper(50); scene.add(axes);
      function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); } animate();
      showToast('ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
    }catch(err){ console.error(err); showToast('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©'); }
  }
  document.querySelector('[data-tab="simulation"]').addEventListener('click', ()=>{ if(document.getElementById('gcodeOut').value) initSimulation(); });

  // ======= Cleanup on unload =======
  window.addEventListener('beforeunload', ()=> {
    try{ if(grayMat) grayMat.delete(); }catch(e){}
    try{ if(origMat) origMat.delete(); }catch(e){}
    try{ if(mainContour) mainContour.delete(); }catch(e){}
    extraContours.forEach(c=>{ try{ c.delete(); }catch(e){} });
  });

  </script>
</body>
</html>
