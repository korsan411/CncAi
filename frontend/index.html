<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CNC AI â€” Perimeters & Heatmap Fixed</title>

  <!-- Clipper.js -->
  <script src="https://cdn.jsdelivr.net/npm/clipper-lib@6.4.2/clipper_unminified.js"></script>

  <style>
    :root{--primary:#1f78d1;--bg:#f4f6fa}
    body{margin:0;font-family:Tahoma,Arial;background:var(--bg);color:#222}
    header{background:linear-gradient(90deg,var(--primary),#63a7f5);color:#fff;padding:12px;text-align:center}
    .wrap{max-width:1200px;margin:12px auto;padding:10px;display:grid;grid-template-columns:1fr 380px;gap:12px}
    .panel{background:#fff;border-radius:10px;padding:12px;box-shadow:0 3px 8px rgba(0,0,0,0.06)}
    canvas{background:#fff;border-radius:6px;border:1px solid #e3eefc;max-width:100%}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .btn{padding:8px 12px;border-radius:8px;border:0;cursor:pointer}
    .btn-primary{background:var(--primary);color:#fff}
    .gcode{height:220px;overflow:auto;background:#0b1220;color:#cfe8ff;padding:8px;border-radius:8px;font-family:monospace}
    label{font-weight:700;margin-top:8px;display:block}
    input[type=number]{width:90px}
    .note{font-size:13px;color:#666}
    @media(max-width:960px){.wrap{grid-template-columns:1fr}}
  </style>
</head>
<body>
<header>ğŸ›  CNC AI â€” Ù…Ø­ÙŠØ·Ø§Øª ÙˆHeatmap (Ù…ØµØ­Ù‘Ø­)</header>

<div class="wrap">
  <section class="panel">
    <label>Ø±ÙØ¹ ØµÙˆØ±Ø© (JPEG/PNG)</label>
    <input id="fileInput" type="file" accept="image/*">

    <div class="row" style="margin-top:8px">
      <button id="btnAnalyze" class="btn btn-primary">ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù (Sobel â†’ MS)</button>
      <button id="btnGenPerims" class="btn">ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø­ÙŠØ·Ø§Øª (Clipper)</button>
      <button id="btnGenG" class="btn">ØªÙˆÙ„ÙŠØ¯ G-code</button>
      <button id="btnDownload" class="btn">ØªØ­Ù…ÙŠÙ„ G-code</button>
    </div>

    <label>Ù…Ø¹Ø§ÙŠÙ†Ø© 2D</label>
    <canvas id="preview" width="800" height="500"></canvas>

    <label>Heatmap (Ù…ØµØºÙ‘Ø± â€” Ù…Ø³Ø¨ÙˆØ¨Ø© Ù…Ù† Ø§Ù„Ø³Ø·ÙˆØ¹)</label>
    <canvas id="heatmap" width="360" height="240" style="display:block;margin-top:8px"></canvas>

    <div class="note" id="status" style="margin-top:8px">Ø§Ù„Ø­Ø§Ù„Ø©: Ø¬Ø§Ù‡Ø²</div>
  </section>

  <aside class="panel">
    <h3>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­ÙˆÙŠÙ„ ÙˆØ§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</h3>
    <div class="row">
      <div>
        Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù…Ù„ X (mm)<br><input id="workW" type="number" value="300">
      </div>
      <div>
        Ø¹Ù…Ù‚ Ø§Ù„Ø¹Ù…Ù„ Y (mm)<br><input id="workH" type="number" value="200">
      </div>
    </div>

    <label>Ù‚Ø·Ø± Ø§Ù„Ø§Ø¯Ø§Ø© (mm)</label>
    <input id="toolDia" type="number" value="3" step="0.1">

    <label>Stepover (%)</label>
    <input id="stepover" type="number" value="40">

    <label>Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ (mm)</label>
    <input id="maxDepth" type="number" value="3" step="0.1">

    <label>Ø¹Ù…Ù‚ ÙƒÙ„ Ù…Ø±ÙˆØ± (mm)</label>
    <input id="passDepth" type="number" value="0.5" step="0.1">

    <label>Feed Rate (mm/min)</label>
    <input id="feed" type="number" value="800">

    <div style="margin-top:8px">
      <label><input id="startFromEdge" type="checkbox" checked> Ø¨Ø¯Ø¡ Ù…Ù† Ø§Ù„Ø­ÙˆØ§Ù</label><br>
      <label><input id="useInfill" type="checkbox"> ØªÙˆÙ„ÙŠØ¯ Infill (Ø®Ø·ÙˆØ·)</label>
    </div>

    <hr>
    <label>Ù…Ø¹Ù„ÙˆÙ…Ø§Øª ÙˆØ§Ø®ØªØ¨Ø§Ø±Ø§Øª</label>
    <div class="note" id="info"></div>

    <label style="margin-top:8px">G-code Output</label>
    <div id="gcodeOut" class="gcode">// Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø´ÙŠØ¡ Ø¨Ø¹Ø¯</div>
  </aside>
</div>

<script>
(() => {
  // Ø¹Ù†Ø§ØµØ± DOM
  const fileInput = document.getElementById('fileInput');
  const preview = document.getElementById('preview');
  const ctx = preview.getContext('2d');
  const heatmap = document.getElementById('heatmap');
  const hctx = heatmap.getContext('2d');

  const btnAnalyze = document.getElementById('btnAnalyze');
  const btnGenPerims = document.getElementById('btnGenPerims');
  const btnGenG = document.getElementById('btnGenG');
  const btnDownload = document.getElementById('btnDownload');

  const statusEl = document.getElementById('status');
  const infoEl = document.getElementById('info');
  const gcodeOut = document.getElementById('gcodeOut');

  // Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
  const workWEl = document.getElementById('workW');
  const workHEl = document.getElementById('workH');
  const toolDiaEl = document.getElementById('toolDia');
  const stepoverEl = document.getElementById('stepover');
  const maxDepthEl = document.getElementById('maxDepth');
  const passDepthEl = document.getElementById('passDepth');
  const feedEl = document.getElementById('feed');
  const startFromEdgeEl = document.getElementById('startFromEdge');
  const useInfillEl = document.getElementById('useInfill');

  // Ø­Ø§Ù„Ø©
  let img = null;
  let heatW = 0, heatH = 0;
  let brightness = null; // Float32Array length heatW*heatH values 0..255
  let contours = []; // array of contours in heatmap coords [{x,y},...]
  let perimeters = []; // array of arrays (heatmap coords)
  let gcodeText = '';

  // Ø±Ø³Ø§Ø¦Ù„ Ø­Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø©
  function setStatus(t){ statusEl.textContent = 'Ø§Ù„Ø­Ø§Ù„Ø©: ' + t; console.log('STATUS:', t); }
  function setInfo(t){ infoEl.innerHTML = t; }

  // --- ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© ÙˆØªØ­Ø¶ÙŠØ± heatmap (grayscale brightness) ---
  fileInput.addEventListener('change', e=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return alert('Ø§Ø®ØªØ± ØµÙˆØ±Ø©');
    const reader = new FileReader();
    reader.onload = ev=>{
      const i = new Image();
      i.onload = ()=>{
        img = i;
        // Ø¶Ø¨Ø· preview: Ù†Ø­Ø¯Ø¯ Ø£Ù‚ØµÙ‰ Ø¹Ø±Ø¶ 1000px Ù„Ø±Ø§Ø­Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡
        const maxPreviewW = 1000;
        let pw = i.width, ph = i.height;
        if(pw > maxPreviewW){ ph = Math.round(ph * (maxPreviewW / pw)); pw = maxPreviewW; }
        preview.width = pw; preview.height = ph;
        ctx.clearRect(0,0,pw,ph);
        ctx.drawImage(i, 0, 0, pw, ph);

        // heatmap Ù…ØµØºÙ‘Ø±: Ù†Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ù†Ø³Ø¨Ø© Ø§Ù„ØµÙˆØ±Ø© Ù„ÙƒÙ† Ù†Ø­Ø¯ Ø§Ù„Ø¹Ø±Ø¶ Ø¥Ù„Ù‰ 360px (Ø£Ùˆ Ø£Ù‚Ù„)
        const targetHeatW = Math.min(512, Math.max(64, Math.round(pw * 0.45))); // heuristic
        heatW = targetHeatW;
        heatH = Math.round((i.height / i.width) * heatW);
        heatmap.width = heatW; heatmap.height = heatH;

        // Ù†Ø±Ø³Ù… Ø§Ù„ØµÙˆØ±Ø© Ø£ØµÙ„Ø§Ù‹ Ø¹Ù„Ù‰ heatmap Ø«Ù… Ù†ÙˆÙ„Ø¯ Ù…ØµÙÙˆÙØ© Ø§Ù„Ø³Ø·ÙˆØ¹
        hctx.clearRect(0,0,heatW,heatH);
        hctx.drawImage(i, 0, 0, heatW, heatH);

        const imgd = hctx.getImageData(0,0,heatW,heatH);
        brightness = new Float32Array(heatW * heatH);

        // Ù†Ø­Ø³Ø¨ Ø§Ù„Ø³Ø·ÙˆØ¹ ÙˆÙ†Ø®Ø²Ù†
        for(let y=0;y<heatH;y++){
          for(let x=0;x<heatW;x++){
            const idx = (y*heatW + x) * 4;
            const r = imgd.data[idx], g = imgd.data[idx+1], b = imgd.data[idx+2];
            const br = 0.34*r + 0.5*g + 0.16*b; // 0..255
            brightness[y*heatW + x] = br;
          }
        }
        // Ù†Ù†Ø´Ø¦ ØªÙ…Ø«ÙŠÙ„Ø§Ù‹ Ø¨ØµØ±ÙŠØ§Ù‹ Ù„Ù„Heatmap (Ù†Ø·Ø¨Ù‘Ù‚ colormap Ø¨Ø³ÙŠØ· "jet-like")
        const out = hctx.createImageData(heatW, heatH);
        for(let i2=0;i2<brightness.length;i2++){
          const v = brightness[i2]/255;
          const col = heatColorMap(v);
          out.data[i2*4] = col.r;
          out.data[i2*4+1] = col.g;
          out.data[i2*4+2] = col.b;
          out.data[i2*4+3] = 255;
        }
        hctx.putImageData(out, 0, 0);

        setStatus('Ø§Ù„ØµÙˆØ±Ø© ÙˆHeatmap Ø¬Ø§Ù‡Ø²Ø§Ù†');
        setInfo(`Heatmap: ${heatW}Ã—${heatH}. Preview: ${preview.width}Ã—${preview.height}`);
        contours = []; perimeters = []; gcodeText = ''; gcodeOut.textContent = '// Ù„Ù… ÙŠÙˆÙ„Ø¯ Ø´ÙŠØ¡ Ø¨Ø¹Ø¯';
      };
      i.onerror = ()=> alert('ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©');
      i.src = ev.target.result;
    };
    reader.readAsDataURL(f);
  });

  // simple jet-like colormap (v 0..1)
  function heatColorMap(v){
    // clamp
    v = Math.max(0, Math.min(1, v));
    // from blue -> cyan -> yellow -> red
    let r=0,g=0,b=0;
    if(v < 0.25){ r = 0; g = 4*v*255; b = 255; }           // blue->cyan
    else if(v < 0.5){ r = 0; g = 255; b = Math.round((1 - (v-0.25)/0.25)*255); } // cyan->greenish->yellowish
    else if(v < 0.75){ r = Math.round(4*(v-0.5)*255); g = 255; b = 0; } // green->yellow->orange
    else { r = 255; g = Math.round((1 - (v-0.75)/0.25)*255); b = 0; } // orange->red
    return {r:Math.round(r), g:Math.round(g), b:Math.round(b)};
  }

  // --- ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù: Sobel Ø¹Ù„Ù‰ brightness Ø«Ù… threshold Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ + Marching Squares Ù„Ø¨Ù†Ø§Ø¡ Ù…Ø­ÙŠØ·Ø§Øª ---
  btnAnalyze.addEventListener('click', ()=>{
    if(!brightness) return alert('Ø­Ù…Ù‘Ù„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹');
    setStatus('ØªØ´ØºÙŠÙ„ Sobel...');
    // Sobel
    const w = heatW, h = heatH;
    const gray = brightness; // Float32Array length w*h
    const sob = new Float32Array(w*h);
    const kx = [-1,0,1,-2,0,2,-1,0,1];
    const ky = [-1,-2,-1,0,0,0,1,2,1];
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        let gx=0, gy=0, idxk=0;
        for(let yy=-1;yy<=1;yy++){
          for(let xx=-1;xx<=1;xx++){
            const v = gray[(y+yy)*w + (x+xx)];
            gx += v * kx[idxk];
            gy += v * ky[idxk];
            idxk++;
          }
        }
        sob[y*w + x] = Math.hypot(gx, gy);
      }
    }
    // normalize sob to 0..255
    let min = Infinity, max = -Infinity;
    for(let i=0;i<sob.length;i++){ if(sob[i]<min) min=sob[i]; if(sob[i]>max) max=sob[i]; }
    const denom = (max - min) || 1;
    const sob8 = new Uint8ClampedArray(w*h);
    for(let i=0;i<sob.length;i++) sob8[i] = Math.round(255 * (sob[i]-min)/denom);

    // dynamic threshold: mean + 0.25*std or 35% of max whichever larger
    let sum=0;
    for(let i=0;i<sob8.length;i++) sum += sob8[i];
    const mean = sum / sob8.length;
    let varsum=0;
    for(let i=0;i<sob8.length;i++){ const d = sob8[i]-mean; varsum += d*d; }
    const std = Math.sqrt(varsum / sob8.length);
    const thresh = Math.max( Math.round(mean + 0.25*std), Math.round(0.35*255) );
    // binary
    const bin = new Uint8Array(w*h);
    for(let i=0;i<w*h;i++) bin[i] = sob8[i] >= thresh ? 1 : 0;

    setStatus('ØªØ´ØºÙŠÙ„ Marching Squares Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ù…Ø­ÙŠØ·Ø§Øª...');
    contours = marchingSquaresContours(bin, w, h);
    // simplify contours (RDP)
    contours = contours.map(c => rdpSimplify(c, 1.0)).filter(c => c.length >= 6);
    setStatus(`Ø§ÙƒØªÙØ´Ù ${contours.length} Ù…Ø­ÙŠØ·Ù‹Ø§ (heatmap coords)`);
    // Ø±Ø³Ù… Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶
    drawPreviewWithOverlays();
  });

  // --- Marching Squares implementation (returns contours in heatmap pixel coordinates) ---
  function marchingSquaresContours(bin, w, h){
    // build segments
    const segments = []; // each segment = [ {x,y}, {x,y} ] in pixel coordinates (floats)
    // helpers: midpoints on edges of cell at (x,y) representing square corners (x,y) .. (x+1,y+1)
    for(let y=0;y<h-1;y++){
      for(let x=0;x<w-1;x++){
        // bits: tl tr br bl in this order -> value 8*tl + 4*tr + 2*br + 1*bl
        const tl = bin[y*w + x] ? 1 : 0;
        const tr = bin[y*w + (x+1)] ? 1 : 0;
        const br = bin[(y+1)*w + (x+1)] ? 1 : 0;
        const bl = bin[(y+1)*w + x] ? 1 : 0;
        const code = (tl<<3) | (tr<<2) | (br<<1) | bl;
        // precompute midpoints
        const top = {x: x + 0.5, y: y};
        const right = {x: x+1, y: y + 0.5};
        const bottom = {x: x + 0.5, y: y+1};
        const left = {x: x, y: y + 0.5};
        // mapping cases (standard)
        switch(code){
          case 1: segments.push([left, bottom]); break;
          case 2: segments.push([bottom, right]); break;
          case 3: segments.push([left, right]); break;
          case 4: segments.push([top, right]); break;
          case 5: segments.push([top, left]); segments.push([bottom, right]); break; // ambiguous, add both
          case 6: segments.push([top, bottom]); break;
          case 7: segments.push([top, left]); break;
          case 8: segments.push([top, left]); break;
          case 9: segments.push([top, bottom]); break;
          case 10: segments.push([top, right]); segments.push([bottom, left]); break;
          case 11: segments.push([top, right]); break;
          case 12: segments.push([left, right]); break;
          case 13: segments.push([bottom, right]); break;
          case 14: segments.push([left, bottom]); break;
          default: break; // 0 or 15 -> no segments
        }
      }
    }
    // chain segments into polylines
    // build adjacency map with keys as rounded coords
    const key = (p) => `${p.x.toFixed(3)}|${p.y.toFixed(3)}`;
    const adj = new Map(); // key -> array of neighbor point objects
    const segMap = new Map(); // key -> list of segments starting at key
    for(const seg of segments){
      const a = {x: seg[0].x, y: seg[0].y};
      const b = {x: seg[1].x, y: seg[1].y};
      const ka = key(a), kb = key(b);
      if(!adj.has(ka)) adj.set(ka, []);
      if(!adj.has(kb)) adj.set(kb, []);
      adj.get(ka).push(b);
      adj.get(kb).push(a);
      // store segments both ways
      if(!segMap.has(ka)) segMap.set(ka, []);
      segMap.get(ka).push({to: b, used:false});
      if(!segMap.has(kb)) segMap.set(kb, []);
      segMap.get(kb).push({to: a, used:false});
    }
    // function to pop a path starting at a key
    const visitedSeg = new Set();
    const contoursOut = [];
    const usedSegSet = new Set();
    for(const [k, list] of segMap.entries()){
      for(let i=0;i<list.length;i++){
        if(list[i].used) continue;
        // follow forward
        let path = [];
        let curKey = k;
        let curPoint = parseKey(curKey);
        path.push(curPoint);
        // forward traverse
        while(true){
          const segs = segMap.get(curKey) || [];
          let foundIdx = -1;
          for(let j=0;j<segs.length;j++){
            if(!segs[j].used){
              foundIdx = j; break;
            }
          }
          if(foundIdx === -1) break;
          const segObj = segs[foundIdx];
          segObj.used = true;
          const next = segObj.to;
          const nextK = key(next);
          // append next
          path.push(next);
          curKey = nextK;
          // stop if closed
          if(Math.abs(path[0].x - next.x) < 1e-6 && Math.abs(path[0].y - next.y) < 1e-6) break;
          // safety
          if(path.length > 10000) break;
        }
        if(path.length >= 3){
          // ensure closed: if start and end not equal, try to close by adding start
          if(Math.abs(path[0].x - path[path.length-1].x) > 1e-6 || Math.abs(path[0].y - path[path.length-1].y) > 1e-6){
            // skip non-closed short paths
            // but we can attempt to keep open paths as contours too
          }
          contoursOut.push(path);
        }
      }
    }

    // post-process: remove tiny contours and convert to integer pixel coords
    const filtered = contoursOut
      .map(c => c.map(p => ({x: p.x, y: p.y})))
      .filter(c => {
        // compute bounding box size as proxy for significance
        let minx=Infinity, miny=Infinity, maxx=-Infinity, maxy=-Infinity;
        c.forEach(p => { if(p.x<minx) minx=p.x; if(p.x>maxx) maxx=p.x; if(p.y<miny) miny=p.y; if(p.y>maxy) maxy=p.y; });
        const wbox = maxx-minx, hbox = maxy-miny;
        return Math.max(wbox,hbox) >= 2; // keep contours with extent >= 2 pixels
      });
    return filtered;
  }

  // RDP simplification
  function rdpSimplify(points, eps){
    if(points.length < 3) return points.slice();
    let dmax = 0, index = 0;
    const start = points[0], end = points[points.length-1];
    for(let i=1;i<points.length-1;i++){
      const d = pointLineDistance(points[i], start, end);
      if(d > dmax){ dmax = d; index = i; }
    }
    if(dmax > eps){
      const l1 = rdpSimplify(points.slice(0, index+1), eps);
      const l2 = rdpSimplify(points.slice(index), eps);
      return l1.slice(0, -1).concat(l2);
    } else {
      return [start, end];
    }
  }
  function pointLineDistance(p, v, w){
    const l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y);
    if(l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
    let t = ((p.x - v.x)*(w.x - v.x) + (p.y - v.y)*(w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    const projx = v.x + t*(w.x - v.x), projy = v.y + t*(w.y - v.y);
    return Math.hypot(p.x - projx, p.y - projy);
  }

  // --- Ø±Ø³Ù… Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ù…Ø¹ overlays (contours + perimeters) ---
  function drawPreviewWithOverlays(){
    if(!img) return;
    ctx.clearRect(0,0,preview.width, preview.height);
    ctx.drawImage(img, 0, 0, preview.width, preview.height);
    // overlay heatmap translucent
    ctx.globalAlpha = 0.45;
    ctx.drawImage(heatmap, 0, 0, preview.width, preview.height);
    ctx.globalAlpha = 1;

    // contours (red)
    ctx.strokeStyle = '#ff3300'; ctx.lineWidth = 1.6;
    contours.forEach(c => {
      ctx.beginPath();
      for(let i=0;i<c.length;i++){
        const p = c[i];
        const px = (p.x / heatW) * preview.width;
        const py = (p.y / heatH) * preview.height;
        if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
      }
      ctx.closePath();
      ctx.stroke();
    });

    // perimeters (if exist)
    if(perimeters && perimeters.length){
      ctx.strokeStyle = '#00aaee'; ctx.lineWidth = 1.2;
      perimeters.forEach(poly => {
        ctx.beginPath();
        for(let i=0;i<poly.length;i++){
          const p = poly[i];
          const px = (p.x / heatW) * preview.width;
          const py = (p.y / heatH) * preview.height;
          if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.closePath(); ctx.stroke();
      });
    }
  }

  // --- ØªÙˆÙ„ÙŠØ¯ Ù…Ø­ÙŠØ·Ø§Øª Ø¯Ù‚ÙŠÙ‚Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Clipper (Ø¹Ø¯Ø© offsets) ---
  btnGenPerims.addEventListener('click', ()=>{
    if(!contours || contours.length===0) return alert('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø­ÙŠØ·Ø§Øª Ù…ÙƒØªØ´ÙØ© â€” Ø´ØºÙ‘Ù„ "ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù" Ø£ÙˆÙ„Ø§Ù‹');
    setStatus('ØªØ­Ø¶ÙŠØ± Clipper Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø­ÙŠØ·Ø§Øª...');
    perimeters = [];
    // Ù…Ø¹Ø§ÙŠÙŠØ±
    const workWmm = parseFloat(workWEl.value) || 300;
    const toolDia = parseFloat(toolDiaEl.value) || 3;
    const stepoverPct = parseFloat(stepoverEl.value) || 40;
    // ØªØ­ÙˆÙŠÙ„ mm -> pixels (heatmap domain)
    const pxPerMm = heatW / workWmm; // pixels per mm
    const toolDiaPx = toolDia * pxPerMm;
    const stepPx = toolDiaPx * (stepoverPct / 100);
    // Clipper scaling
    const clipScale = 100; // multiplier to get integers
    // process each contour: produce offsets inward until too small or limit reached
    let totalOffsets = 0;
    for(const base of contours){
      // base is array of {x,y} in heatmap pixels possibly fractional
      // convert to Clipper path
      const path = base.map(p => ({ X: Math.round(p.x * clipScale), Y: Math.round(p.y * clipScale) }));
      // attempt offsets: start at tool radius inward, then each stepover
      const offsetsForThis = [];
      const maxOffsets = 10;
      for(let i=0;i<maxOffsets;i++){
        const deltaPx = - Math.round((toolDiaPx/2 + i * stepPx) * clipScale); // negative=inward
        if(Math.abs(deltaPx) < 1) break;
        const co = new ClipperLib.ClipperOffset();
        try {
          co.AddPath(path, ClipperLib.JoinType.jtRound, ClipperLib.EndType.etClosedPolygon);
          const solution = new ClipperLib.Paths();
          co.Execute(solution, deltaPx);
          if(!solution || solution.length === 0) {
            // failed to produce offset (shape vanished or too large offset). Try smaller delta (reduce by half) once
            // don't break immediate: try smaller delta as fallback
            // attempt fallback smaller delta (50%)
            const fallbackDelta = Math.round(deltaPx / 2);
            if(Math.abs(fallbackDelta) >= 1){
              const co2 = new ClipperLib.ClipperOffset();
              co2.AddPath(path, ClipperLib.JoinType.jtRound, ClipperLib.EndType.etClosedPolygon);
              const sol2 = new ClipperLib.Paths();
              try { co2.Execute(sol2, fallbackDelta); if(sol2 && sol2.length) {
                // take largest polygon in sol2
                const largest = pickLargestPolygon(sol2);
                if(largest) offsetsForThis.push(largest.map(pt => ({ x: pt.X / clipScale, y: pt.Y / clipScale })));
                totalOffsets++;
                continue;
              } catch(_){} }
            }
            // nothing produced -> stop trying further outward offsets
            break;
          } else {
            // select largest polygon(s) from solution (filter tiny ones)
            const solPolys = [];
            for(const sol of solution){
              const poly = sol.map(pt => ({ x: pt.X / clipScale, y: pt.Y / clipScale }));
              // compute area in pixel^2
              const area = polygonArea(poly);
              if(area >= 4) solPolys.push({poly,area});
            }
            if(solPolys.length === 0) break;
            // choose the largest polygon (most likely main offset)
            solPolys.sort((a,b)=>b.area - a.area);
            offsetsForThis.push(solPolys[0].poly);
            totalOffsets++;
          }
        } catch(err){
          console.warn('Clipper offset error', err);
          break;
        }
      }
      // store: base contour (in heatmap coords) then offsets
      // convert base coordinates to ensure consistent format
      const baseCopy = base.map(p => ({x: p.x, y: p.y}));
      perimeters.push({ base: baseCopy, offsets: offsetsForThis });
    }

    setStatus(`ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø­ÙŠØ·Ø§Øª (Ø§Ù„Ù…Ø¬Ù…ÙˆØ¹: ${totalOffsets} offset polygons)` );
    drawPreviewWithOverlays();
  });

  // helper: pick largest polygon from ClipperLib.Paths (in scaled ints)
  function pickLargestPolygon(paths){
    if(!paths || paths.length === 0) return null;
    let best = null; let bestArea = 0;
    for(const p of paths){
      let area = 0;
      for(let i=0;i<p.length;i++){
        const a = p[i], b = p[(i+1)%p.length];
        area += a.X*b.Y - b.X*a.Y;
      }
      area = Math.abs(area) / 2;
      if(area > bestArea){ bestArea = area; best = p; }
    }
    return best;
  }

  function polygonArea(poly){
    if(!poly || poly.length < 3) return 0;
    let a = 0;
    for(let i=0;i<poly.length;i++){
      const p = poly[i], q = poly[(i+1)%poly.length];
      a += p.x * q.y - q.x * p.y;
    }
    return Math.abs(a) / 2;
  }

  // --- Generate G-code with correct mm conversion and step-down passes ---
  btnGenG.addEventListener('click', ()=>{
    if(!perimeters || perimeters.length === 0) return alert('Ù„Ø§ Ù…Ø­ÙŠØ·Ø§Øª Ù…ÙˆÙ„Ù‘Ø¯Ø©Ø› Ø´ØºÙ‘Ù„ "ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø­ÙŠØ·Ø§Øª" Ø£ÙˆÙ„Ø§Ù‹');
    const workWmm = parseFloat(workWEl.value) || 300;
    const workHmm = parseFloat(workHEl.value) || 200;
    const feed = parseFloat(feedEl.value) || 800;
    const safeZ = 5;
    const passDepth = parseFloat(passDepthEl.value) || 0.5;
    const maxDepth = parseFloat(maxDepthEl.value) || 3;
    const pxToMmX = workWmm / heatW;
    const pxToMmY = workHmm / heatH;
    const lines = [];
    lines.push('; G-code generated by CNC AI (perimeters from heatmap)');
    lines.push('G21');
    lines.push('G90');
    lines.push(`G0 Z${safeZ.toFixed(3)}`);

    // helper to convert heatmap pixel point -> machine mm coords
    function toMM(p){
      return { X: (p.x * pxToMmX), Y: (p.y * pxToMmY) };
    }

    // iterate per each group (base + offsets)
    for(const group of perimeters){
      const seqs = [ group.base ].concat(group.offsets || []);
      for(const seq of seqs){
        if(!seq || seq.length < 2) continue;
        // calculate per-point depth
        const zs = seq.map(p => {
          // sample brightness at nearest pixel (p.x in heatmap coords)
          const ix = Math.max(0, Math.min(heatW-1, Math.round(p.x)));
          const iy = Math.max(0, Math.min(heatH-1, Math.round(p.y)));
          const br = brightness[iy*heatW + ix];
          const z = (1 - (br / 255)) * maxDepth; // mm
          return z;
        });
        const maxZ = Math.max(...zs);
        if(maxZ <= 1e-6) continue;
        const nPasses = Math.max(1, Math.ceil(maxZ / passDepth));
        // move rapid to first point XY
        const mm0 = toMM(seq[0]);
        lines.push(`G0 X${mm0.X.toFixed(3)} Y${mm0.Y.toFixed(3)} Z${safeZ.toFixed(3)}`);
        for(let pass=1; pass<=nPasses; pass++){
          const thisDepth = Math.min(pass * passDepth, maxZ);
          // plunge a bit at feed/4 to target depth
          lines.push(`G1 Z-${thisDepth.toFixed(3)} F${Math.max(100, Math.round(feed/4))}`);
          // follow path
          for(let i=0;i<seq.length;i++){
            const p = seq[i];
            const mm = toMM(p);
            const localZ = Math.min(zs[i], thisDepth);
            lines.push(`G1 X${mm.X.toFixed(3)} Y${mm.Y.toFixed(3)} Z-${localZ.toFixed(3)} F${feed}`);
          }
          // retract slightly between passes
          lines.push(`G0 Z${(safeZ/2).toFixed(3)}`);
        }
        // final retract
        lines.push(`G0 Z${safeZ.toFixed(3)}`);
      }
    }

    lines.push('G0 X0 Y0');
    lines.push('M30');
    gcodeText = lines.join('\n');
    gcodeOut.textContent = gcodeText;
    setStatus('ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code â€” Ø§ÙØ­Øµ Ø§Ù„Ù†Ø§ØªØ¬ Ø¬ÙŠØ¯Ù‹Ø§ Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„Ù…Ø§ÙƒÙŠÙ†Ø©');
  });

  btnDownload.addEventListener('click', ()=>{
    if(!gcodeText) return alert('Ù„Ù… ÙŠÙÙˆÙ„Ù‘ÙØ¯ G-code Ø¨Ø¹Ø¯');
    const blob = new Blob([gcodeText], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'cnc_ai_output.nc';
    a.click();
  });

  // --- Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø© ØµØºÙŠØ±Ø© ---
  function round3(v){ return Math.round(v*1000)/1000; }
  function parseKey(k){
    const parts = k.split('|'); return {x: parseFloat(parts[0]), y: parseFloat(parts[1])};
  }

  // Ù†Ù‚Ø·Ø© ØªÙØªÙŠØ´ Ø³Ø±ÙŠØ¹Ø© Ù„Ø¹Ø±Ø¶ Ø¨Ø¹Ø¶ Ø§Ù„ØªÙØ§ØµÙŠÙ„
  function debugInfo(){
    setInfo(`Heatmap: ${heatW}Ã—${heatH} â€” Contours: ${contours.length} â€” Perimeter groups: ${perimeters.length}`);
  }

  // Ø¹Ø±Ø¶ Ø£ÙˆÙ„ÙŠ Ø¹Ù†Ø¯Ù…Ø§ ØªØªØºÙŠØ± Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  const obs = new MutationObserver(() => debugInfo());
  obs.observe(infoEl, {childList:true, subtree:true});

})();
</script>
</body>
</html>
