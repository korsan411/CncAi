<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CNC AI - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…ØªØ·ÙˆØ±Ø© Ù…Ø¹ Ø§Ù„ØªØ­Ù„ÙŠÙ„Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</title>
  <style>
    :root {
      --primary-color: #4a90e2;
      --secondary-color: #67b0f5;
      --bg-color: #f8f9fa;
      --text-color: #212529;
      --card-bg: #ffffff;
      --border-color: #dee2e6;
      --header-bg: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      --header-text: #ffffff;
      --button-bg: #e9ecef;
      --button-hover: #dee2e6;
      --success-color: #28a745;
      --warning-color: #ffc107;
      --error-color: #dc3545;
      --ai-color: #9c27b0;
      --wood-color: #8b4513;
      --tab-inactive: #e9ecef;
      --tab-active: var(--primary-color);
      --analysis-color: #17a2b8;
      --roughing-color: #8b4513;
      --finishing-color: #5a2d0c;
      --smoothing-color: #3d2108;
      --drawing-color: #ff5722;
    }

    body.dark {
      --bg-color: #121212;
      --text-color: #e0e0e0;
      --card-bg: #1e1e1e;
      --border-color: #444;
      --header-bg: linear-gradient(90deg, #2c2c2c, #444);
      --button-bg: #333;
      --button-hover: #555;
      --ai-color: #ba68c8;
      --wood-color: #a0522d;
      --tab-inactive: #333;
      --tab-active: #4a90e2;
      --analysis-color: #138496;
      --roughing-color: #a0522d;
      --finishing-color: #8b4513;
      --smoothing-color: #5a2d0c;
      --drawing-color: #ff8a65;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      line-height: 1.6;
      transition: all 0.3s ease;
      padding: 0;
      margin: 0;
    }

    .container {
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      background: var(--header-bg);
      color: var(--header-text);
      padding: 1rem;
      text-align: center;
      border-radius: 0 0 10px 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      margin-bottom: 2rem;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 1400px;
    }

    h1 {
      font-size: 1.8rem;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .controls {
      display: flex;
      gap: 15px;
      align-items: center;
    }

    #themeToggle {
      background: transparent;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--header-text);
      transition: transform 0.3s;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #themeToggle:hover {
      transform: scale(1.1);
      background: rgba(255, 255, 255, 0.2);
    }

    /* ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ø¨Ø§Øª */
    .tabs {
      display: flex;
      margin-bottom: 20px;
      background: var(--card-bg);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .tab {
      padding: 12px 20px;
      cursor: pointer;
      background: var(--tab-inactive);
      transition: all 0.3s;
      text-align: center;
      flex: 1;
      font-weight: 500;
    }

    .tab.active {
      background: var(--tab-active);
      color: white;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØªØ§Ø¨Ø§Øª */
    .upload-section {
      background: var(--card-bg);
      padding: 2rem;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      text-align: center;
      border: 1px solid var(--border-color);
    }

    .previews-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 2rem;
    }

    @media (min-width: 992px) {
      .previews-container {
        grid-template-columns: 1fr 1fr;
      }
    }

    .preview-block {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 1px solid var(--border-color);
    }

    .preview-title {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--primary-color);
    }

    .preview-content {
      width: 100%;
      display: flex;
      justify-content: center;
      margin-bottom: 1rem;
    }

    canvas {
      max-width: 100%;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    #preview3d {
      width: 100%;
      height: 300px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      position: relative;
    }

    .options {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
      width: 100%;
      margin-top: 1rem;
    }

    .option-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .option-group label {
      font-size: 0.9rem;
      font-weight: 500;
    }

    input[type="range"] {
      width: 150px;
      accent-color: var(--primary-color);
    }

    .settings-panel {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .settings-group {
      margin-bottom: 1.5rem;
    }

    .settings-group h3 {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border-color);
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
    }

    .form-group select, 
    .form-group input {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 5px;
      background: var(--bg-color);
      color: var(--text-color);
    }

    .gcode-output {
      background: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 15px;
      height: 200px;
      overflow-y: auto;
      font-family: monospace;
      white-space: pre-wrap;
      margin-top: 1rem;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn-primary {
      background: var(--primary-color);
      color: white;
    }

    .btn-primary:hover {
      background: var(--secondary-color);
    }

    .btn-secondary {
      background: var(--button-bg);
      color: var(--text-color);
    }

    .btn-secondary:hover {
      background: var(--button-hover);
    }

    .btn-ai {
      background: var(--ai-color);
      color: white;
    }

    .btn-ai:hover {
      background: #7b1fa2;
    }

    .btn-analysis {
      background: var(--analysis-color);
      color: white;
    }

    .btn-analysis:hover {
      background: #138496;
    }

    .btn-roughing {
      background: var(--roughing-color);
      color: white;
    }

    .btn-finishing {
      background: var(--finishing-color);
      color: white;
    }

    .btn-smoothing {
      background: var(--smoothing-color);
      color: white;
    }

    .btn-drawing {
      background: var(--drawing-color);
      color: white;
    }

    .action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 1rem;
      flex-wrap: wrap;
    }

    footer {
      text-align: center;
      margin-top: 3rem;
      padding: 1.5rem;
      color: var(--text-color);
      font-size: 0.9rem;
      border-top: 1px solid var(--border-color);
    }

    .image-enhancement {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }

    .enhancement-btn {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 5px;
      background: var(--button-bg);
      color: var(--text-color);
      cursor: pointer;
      text-align: center;
      transition: all 0.3s;
    }

    .enhancement-btn:hover {
      background: var(--button-hover);
    }

    .loading {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      z-index: 100;
      border-radius: 8px;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 8px;
      background: var(--success-color);
      color: white;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transform: translateX(100%);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .notification.show {
      transform: translateX(0);
      opacity: 1;
    }

    .notification.error {
      background: var(--error-color);
    }

    .notification.ai {
      background: var(--ai-color);
    }

    .notification.analysis {
      background: var(--analysis-color);
    }

    .ai-options {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .path-optimization {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1rem;
    }

    .optimization-option {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .optimization-option input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }

    .progress-container {
      width: 100%;
      background-color: var(--border-color);
      border-radius: 5px;
      margin: 15px 0;
      display: none;
    }

    .progress-bar {
      width: 0%;
      height: 20px;
      background-color: var(--primary-color);
      border-radius: 5px;
      transition: width 0.3s ease;
    }

    .edge-detection {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }

    .analysis-panel {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      display: none;
    }

    .analysis-results {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .analysis-item {
      background: var(--bg-color);
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .analysis-item h4 {
      margin-bottom: 0.5rem;
      color: var(--analysis-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .analysis-value {
      font-size: 1.2rem;
      font-weight: bold;
    }

    .gcode-preview {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      display: none;
    }

    .gcode-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .stat-item {
      background: var(--bg-color);
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      text-align: center;
    }

    .stat-item h4 {
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: bold;
    }

    .wood-stages {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-top: 1.5rem;
    }

    .wood-stage {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      border: 1px solid var(--border-color);
    }

    .wood-stage h3 {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border-color);
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .advanced-settings {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .path-preview {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .path-preview-content {
      width: 100%;
      height: 300px;
      display: flex;
      justify-content: center;
      align-items: center;
      background: var(--bg-color);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      margin-top: 1rem;
      position: relative;
      overflow: hidden;
    }

    .path-svg {
      width: 100%;
      height: 100%;
    }

    .path-controls {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      justify-content: center;
    }

    .drawing-tools {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin: 1rem 0;
      padding: 1rem;
      background: var(--card-bg);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .drawing-controls {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .drawing-instructions {
      font-size: 0.9rem;
      color: var(--text-color);
      text-align: center;
      margin-top: 0.5rem;
    }

    .drawing-canvas-container {
      position: relative;
      width: 100%;
      height: 300px;
      margin-top: 1rem;
    }

    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
      border: 1px solid var(--border-color);
      border-radius: 8px;
    }

    .manual-selection {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 1.4rem;
      }
      
      .header-content {
        flex-direction: column;
        gap: 15px;
      }
      
      .preview-block {
        padding: 1rem;
      }
      
      .options {
        flex-direction: column;
        align-items: center;
      }
      
      .action-buttons {
        flex-direction: column;
      }
      
      .analysis-results, .gcode-stats {
        grid-template-columns: 1fr;
      }

      .wood-stages {
        grid-template-columns: 1fr;
      }

      .drawing-controls {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <h1><span>ğŸ› ï¸</span> CNC AI - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø©</h1>
      <div class="controls">
        <button id="themeToggle">ğŸŒ™</button>
      </div>
    </div>
  </header>

  <div class="container">
    <!-- Ø§Ù„ØªØ§Ø¨Ø§Øª -->
    <div class="tabs">
      <div class="tab active" data-tab="preview">Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ØµÙˆØ±Ø©</div>
      <div class="tab" data-tab="gcode">G-code Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</div>
      <div class="tab" data-tab="advanced">Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</div>
    </div>

    <!-- ØªØ§Ø¨ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© -->
    <div class="tab-content active" id="preview-tab">
      <section class="upload-section">
        <h2 class="upload-title">ğŸ“¤ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©</h2>
        <div class="file-upload">
          <input type="file" id="fileInput" accept="image/*">
          <label for="fileInput"><span>ğŸ“</span> Ø§Ø®ØªØ± ØµÙˆØ±Ø©</label>
          <div class="file-name" id="fileName">Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø£ÙŠ ØµÙˆØ±Ø© Ø¨Ø¹Ø¯</div>
        </div>

        <div class="progress-container" id="progressContainer">
          <div class="progress-bar" id="progressBar"></div>
        </div>

        <div class="image-enhancement">
          <div class="enhancement-btn" onclick="applyEnhancement('brightness')">ğŸ”† Ø³Ø·ÙˆØ¹</div>
          <div class="enhancement-btn" onclick="applyEnhancement('contrast')">ğŸŒ“ ØªØ¨Ø§ÙŠÙ†</div>
          <div class="enhancement-btn" onclick="applyEnhancement('sharpen')">ğŸ” Ø­Ø¯Ø©</div>
          <div class="enhancement-btn" onclick="applyEnhancement('smooth')">ğŸ”„ Ù†Ø¹ÙˆÙ…Ø©</div>
          <div class="enhancement-btn" onclick="applyEnhancement('grayscale')">âš« ØªØ¯Ø±Ø¬ Ø±Ù…Ø§Ø¯ÙŠ</div>
          <div class="enhancement-btn" onclick="applyEnhancement('reset')">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</div>
        </div>

        <div class="edge-detection">
          <div class="enhancement-btn" onclick="detectEdges('sobel')">ğŸ” ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù (Sobel)</div>
          <div class="enhancement-btn" onclick="detectEdges('canny')">ğŸ” ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù (Canny)</div>
          <div class="enhancement-btn" onclick="detectEdges('laplacian')">ğŸ” ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù (Laplacian)</div>
        </div>
      </section>

      <div class="previews-container">
        <!-- Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© -->
        <div class="preview-block">
          <h3 class="preview-title">ğŸ“· Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</h3>
          <div class="preview-content">
            <canvas id="preview2d"></canvas>
          </div>
        </div>

        <!-- Ù…Ø¹Ø§ÙŠÙ†Ø© 3D -->
        <div class="preview-block">
          <h3 class="preview-title">ğŸŒ€ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</h3>
          <div class="preview-content">
            <div id="preview3d">
              <div class="loading" id="loading3d">
                <div class="loading-spinner"></div>
                <p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬...</p>
              </div>
            </div>
          </div>
          <div class="options">
            <div class="option-group">
              <label for="rotationSpeed">ğŸ”„ Ø³Ø±Ø¹Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†</label>
              <input type="range" id="rotationSpeed" min="0" max="0.05" step="0.001" value="0.01">
            </div>
            <div class="option-group">
              <label for="zoomControl">ğŸ” Ø²ÙˆÙ…</label>
              <input type="range" id="zoomControl" min="50" max="500" step="10" value="200">
            </div>
            <div class="option-group">
              <label for="heightIntensity">ğŸ“ Ø´Ø¯Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹</label>
              <input type="range" id="heightIntensity" min="20" max="200" step="5" value="80">
            </div>
          </div>
        </div>

        <!-- Heatmap -->
        <div class="preview-block">
          <h3 class="preview-title">ğŸŒˆ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª (Heatmap)</h3>
          <div class="preview-content">
            <canvas id="heatmap"></canvas>
          </div>
          <div class="colormap-controls">
            <button class="btn btn-secondary" onclick="setColormap('jet')"><span>ğŸŒˆ</span> Jet</button>
            <button class="btn btn-secondary" onclick="setColormap('hot')"><span>ğŸ”¥</span> Hot</button>
            <button class="btn btn-secondary" onclick="setColormap('cool')"><span>â„ï¸</span> Cool</button>
            <button class="btn btn-secondary" onclick="setColormap('gray')"><span>âšª</span> Gray</button>
          </div>
        </div>

        <!-- Ø­ÙˆØ§Ù Ø§Ù„ØµÙˆØ±Ø© -->
        <div class="preview-block">
          <h3 class="preview-title">ğŸ” Ø­ÙˆØ§Ù Ø§Ù„ØµÙˆØ±Ø©</h3>
          <div class="preview-content">
            <canvas id="edgesCanvas"></canvas>
          </div>
          <div class="options">
            <div class="option-group">
              <label for="edgeThreshold">ğŸ“Š Ø¹ØªØ¨Ø© Ø§Ù„Ø­ÙˆØ§Ù</label>
              <input type="range" id="edgeThreshold" min="1" max="100" step="1" value="50" oninput="updateEdgeDetection()">
            </div>
          </div>
        </div>

        <!-- ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ ÙŠØ¯ÙˆÙŠØ§Ù‹ -->
        <div class="preview-block">
          <h3 class="preview-title">âœï¸ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ ÙŠØ¯ÙˆÙŠØ§Ù‹</h3>
          <div class="preview-content">
            <div class="drawing-canvas-container">
              <canvas id="drawingCanvas"></canvas>
            </div>
          </div>
          <div class="drawing-tools">
            <div class="drawing-controls">
              <button class="btn btn-drawing" id="startDrawing">
                <span>âœï¸</span> Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù…
              </button>
              <button class="btn btn-secondary" id="clearDrawing">
                <span>ğŸ—‘ï¸</span> Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ù…
              </button>
              <button class="btn btn-primary" id="applyDrawing">
                <span>âœ…</span> ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø³Ù…
              </button>
            </div>
            <div class="drawing-instructions">
              <p>Ø§Ø±Ø³Ù… Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ù‚Ø·Ø¹Ù‡Ø§. Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù…" Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù…ØŒ Ø«Ù… Ø§Ù†Ù‚Ø± ÙˆØ§Ø³Ø­Ø¨ Ù„Ø±Ø³Ù… Ø§Ù„Ù…Ù†Ø·Ù‚Ø©.</p>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="brushSize">ğŸ“ Ø­Ø¬Ù… Ø§Ù„ÙØ±Ø´Ø§Ø©</label>
                <input type="range" id="brushSize" min="1" max="20" step="1" value="5">
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ØªØ§Ø¨ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª G-code -->
    <div class="tab-content" id="gcode-tab">
      <div class="ai-options">
        <h3><span>ğŸ¤–</span> Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ</h3>
        <div class="path-optimization">
          <div class="optimization-option">
            <input type="checkbox" id="optimizePaths" checked>
            <label for="optimizePaths">ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ù„ØªÙ‚Ù„ÙŠÙ„ ÙˆÙ‚Øª Ø§Ù„Ù‚Ø·Ø¹</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="smoothEdges" checked>
            <label for="smoothEdges">ØªÙ†Ø¹ÙŠÙ… Ø§Ù„Ø­ÙˆØ§Ù Ù„Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø£ÙØ¶Ù„</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="adaptivePrecision">
            <label for="adaptivePrecision">Ø§Ù„Ø¯Ù‚Ø© Ø§Ù„ØªÙƒÙŠÙÙŠØ© (ØªÙ„Ù‚Ø§Ø¦ÙŠØ©)</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="useEdges" checked>
            <label for="useEdges">Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­ÙˆØ§Ù Ø§Ù„ØµÙˆØ±Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="startFromEdges" checked>
            <label for="startFromEdges">Ø¨Ø¯Ø¡ Ø§Ù„Ù‚Ø·Ø¹ Ù…Ù† Ø§Ù„Ø­ÙˆØ§Ù</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="useManualSelection">
            <label for="useManualSelection">Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ Ù„Ù„Ù…Ù†Ø§Ø·Ù‚</label>
          </div>
        </div>
      </div>

      <div class="settings-panel">
        <div class="settings-group">
          <h3><span>ğŸ­</span> Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</h3>
          <div class="form-group">
            <label for="machineType">Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</label>
            <select id="machineType">
              <option value="cnc">CNC Router</option>
              <option value="laser">Laser Cutter</option>
              <option value="3dprinter">3D Printer</option>
            </select>
          </div>
        </div>

        <div class="settings-group">
          <h3><span>ğŸ“¦</span> Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø®Ø§Ù…Ø©</h3>
          <div class="form-group">
            <label for="materialType">Ù†ÙˆØ¹ Ø§Ù„Ø®Ø§Ù…Ø©</label>
            <select id="materialType">
              <option value="wood">Ø®Ø´Ø¨</option>
              <option value="acrylic">Ø£ÙƒØ±ÙŠÙ„ÙŠÙƒ</option>
              <option value="aluminum">Ø£Ù„ÙˆÙ…Ù†ÙŠÙˆÙ…</option>
              <option value="steel">ØµÙ„Ø¨</option>
              <option value="pla">PLA (Ø¨Ù„Ø§Ø³ØªÙŠÙƒ)</option>
              <option value="abs">ABS (Ø¨Ù„Ø§Ø³ØªÙŠÙƒ)</option>
            </select>
          </div>
        </div>

        <div class="settings-group">
          <h3><span>âš™ï¸</span> Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù‚Ø·Ø¹</h3>
          <div class="form-group">
            <label for="feedRate">Ø³Ø±Ø¹Ø© Ø§Ù„ØªØºØ°ÙŠØ© (mm/min)</label>
            <input type="number" id="feedRate" value="1000">
          </div>
          <div class="form-group">
            <label for="spindleSpeed">Ø³Ø±Ø¹Ø© Ø§Ù„Ù…ØºØ²Ù„ (RPM)</label>
            <input type="number" id="spindleSpeed" value="10000">
          </div>
          <div class="form-group">
            <label for="cutDepth">Ø¹Ù…Ù‚ Ø§Ù„Ù‚Ø·Ø¹ (mm)</label>
            <input type="number" id="cutDepth" value="2" step="0.1">
          </div>
          <div class="form-group">
            <label for="passDepth">Ø¹Ù…Ù‚ Ø§Ù„ØªÙ…Ø±ÙŠØ±Ø© (mm)</label>
            <input type="number" id="passDepth" value="0.5" step="0.1">
          </div>
        </div>

        <div class="settings-group">
          <h3><span>ğŸ”§</span> Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª G-code</h3>
          <div class="form-group">
            <label for="gcodeType">Ù†ÙˆØ¹ Ø§Ù„Ù…Ø®Ø±Ø¬Ø§Øª</label>
            <select id="gcodeType">
              <option value="heatmap">Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Heatmap</option>
              <option value="3dmodel">Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</option>
              <option value="edges">Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø­ÙˆØ§Ù Ø§Ù„ØµÙˆØ±Ø©</option>
              <option value="manual">Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ</option>
            </select>
          </div>
          <div class="form-group">
            <label for="gcodePrecision">Ø¯Ù‚Ø© Ø§Ù„ØªÙˆÙ„ÙŠØ¯</label>
            <select id="gcodePrecision">
              <option value="low">Ù…Ù†Ø®ÙØ¶Ø© (Ø£Ø³Ø±Ø¹)</option>
              <option value="medium" selected>Ù…ØªÙˆØ³Ø·Ø©</option>
              <option value="high">Ø¹Ø§Ù„ÙŠØ© (Ø£Ø¨Ø·Ø£)</option>
            </select>
          </div>
        </div>

        <div class="action-buttons">
          <button class="btn btn-analysis" onclick="analyzeImage()">
            <span>ğŸ”</span> ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
          </button>
          <button class="btn btn-primary" onclick="generateGcode()">
            <span>âš¡</span> ØªÙˆÙ„ÙŠØ¯ G-code
          </button>
          <button class="btn btn-secondary" onclick="downloadGcode()">
            <span>ğŸ’¾</span> Ø­ÙØ¸ G-code
          </button>
        </div>
      </div>

      <!-- Ù…Ø¹Ø§ÙŠÙ†Ø© Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù‚Ø·Ø¹ -->
      <div class="path-preview">
        <h3><span>ğŸ”„</span> Ù…Ø¹Ø§ÙŠÙ†Ø© Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù‚Ø·Ø¹</h3>
        <div class="path-preview-content" id="pathPreview">
          <svg class="path-svg" id="pathSvg"></svg>
        </div>
        <div class="path-controls">
          <button class="btn btn-secondary" onclick="updatePathPreview()">
            <span>ğŸ”„</span> ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
          </button>
          <button class="btn btn-primary" onclick="optimizePaths()">
            <span>ğŸ”</span> ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
          </button>
        </div>
      </div>

      <div class="analysis-panel" id="analysisPanel">
        <h3><span>ğŸ“Š</span> Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØ­Ù„ÙŠÙ„</h3>
        <div class="analysis-results" id="analysisResults">
          <!-- Ø³ÙŠØªÙ… Ù…Ù„Ø¤Ù‡Ø§ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠÙ‹Ø§ -->
        </div>
      </div>

      <div class="gcode-preview" id="gcodePreview">
        <h3><span>ğŸ“‹</span> Ù…Ø¹Ø§ÙŠÙ†Ø© G-code</h3>
        <div class="gcode-stats" id="gcodeStats">
          <!-- Ø³ÙŠØªÙ… Ù…Ù„Ø¤Ù‡Ø§ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠÙ‹Ø§ -->
        </div>
        <div class="gcode-output" id="gcodeOutput">
// Ø³ÙŠØ¸Ù‡Ø± ÙƒÙˆØ¯ G-code Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙˆÙ„ÙŠØ¯
// Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "ØªÙˆÙ„ÙŠØ¯ G-code" Ù„Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªÙˆÙ„ÙŠØ¯
        </div>
      </div>

      <!-- Ù…Ø±Ø§Ø­Ù„ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø®Ø´Ø¨ -->
      <div class="wood-stages" id="woodStages" style="display: none;">
        <div class="wood-stage">
          <h3><span>ğŸ”¨</span> Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªÙ†Ø¬ÙŠØ±</h3>
          <div class="form-group">
            <label for="roughingFeedRate">Ø³Ø±Ø¹Ø© Ø§Ù„ØªØºØ°ÙŠØ© (mm/min)</label>
            <input type="number" id="roughingFeedRate" value="1500">
          </div>
          <div class="form-group">
            <label for="roughingSpindleSpeed">Ø³Ø±Ø¹Ø© Ø§Ù„Ù…ØºØ²Ù„ (RPM)</label>
            <input type="number" id="roughingSpindleSpeed" value="8000">
          </div>
          <div class="form-group">
            <label for="roughingDepth">Ø¹Ù…Ù‚ Ø§Ù„Ù‚Ø·Ø¹ (mm)</label>
            <input type="number" id="roughingDepth" value="3" step="0.1">
          </div>
          <button class="btn btn-roughing" onclick="generateStageGcode('roughing')">
            <span>âš¡</span> ØªÙˆÙ„ÙŠØ¯ G-code Ù„Ù„ØªÙ†Ø¬ÙŠØ±
          </button>
          <button class="btn btn-roughing" onclick="downloadStageGcode('roughing')">
            <span>ğŸ’¾</span> Ø­ÙØ¸ Ù…Ù„Ù Ø§Ù„ØªÙ†Ø¬ÙŠØ±
          </button>
        </div>

        <div class="wood-stage">
          <h3><span>âœ‚ï¸</span> Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªØ´Ø·ÙŠØ¨</h3>
          <div class="form-group">
            <label for="finishingFeedRate">Ø³Ø±Ø¹Ø© Ø§Ù„ØªØºØ°ÙŠØ© (mm/min)</label>
            <input type="number" id="finishingFeedRate" value="1000">
          </div>
          <div class="form-group">
            <label for="finishingSpindleSpeed">Ø³Ø±Ø¹Ø© Ø§Ù„Ù…ØºØ²Ù„ (RPM)</label>
            <input type="number" id="finishingSpindleSpeed" value="12000">
          </div>
          <div class="form-group">
            <label for="finishingDepth">Ø¹Ù…Ù‚ Ø§Ù„Ù‚Ø·Ø¹ (mm)</label>
            <input type="number" id="finishingDepth" value="1" step="0.1">
          </div>
          <button class="btn btn-finishing" onclick="generateStageGcode('finishing')">
            <span>âš¡</span> ØªÙˆÙ„ÙŠØ¯ G-code Ù„Ù„ØªØ´Ø·ÙŠØ¨
          </button>
          <button class="btn btn-finishing" onclick="downloadStageGcode('finishing')">
            <span>ğŸ’¾</span> Ø­ÙØ¸ Ù…Ù„Ù Ø§Ù„ØªØ´Ø·ÙŠØ¨
          </button>
        </div>

        <div class="wood-stage">
          <h3><span>âœ¨</span> Ù…Ø±Ø­Ù„Ø© Ø§Ù„ØªÙ†Ø¹ÙŠÙ…</h3>
          <div class="form-group">
            <label for="smoothingFeedRate">Ø³Ø±Ø¹Ø© Ø§Ù„ØªØºØ°ÙŠØ© (mm/min)</label>
            <input type="number" id="smoothingFeedRate" value="800">
          </div>
          <div class="form-group">
            <label for="smoothingSpindleSpeed">Ø³Ø±Ø¹Ø© Ø§Ù„Ù…ØºØ²Ù„ (RPM)</label>
            <input type="number" id="smoothingSpindleSpeed" value="15000">
          </div>
          <div class="form-group">
            <label for="smoothingDepth">Ø¹Ù…Ù‚ Ø§Ù„Ù‚Ø·Ø¹ (mm)</label>
            <input type="number" id="smoothingDepth" value="0.5" step="0.1">
          </div>
          <button class="btn btn-smoothing" onclick="generateStageGcode('smoothing')">
            <span>âš¡</span> ØªÙˆÙ„ÙŠØ¯ G-code Ù„Ù„ØªÙ†Ø¹ÙŠÙ…
          </button>
          <button class="btn btn-smoothing" onclick="downloadStageGcode('smoothing')">
            <span>ğŸ’¾</span> Ø­ÙØ¸ Ù…Ù„Ù Ø§Ù„ØªÙ†Ø¹ÙŠÙ…
          </button>
        </div>
      </div>
    </div>

    <!-- ØªØ§Ø¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© -->
    <div class="tab-content" id="advanced-tab">
      <div class="advanced-settings">
        <h2><span>âš™ï¸</span> Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„Ù…Ø§ÙƒÙŠÙ†Ø§Øª</h2>
        
        <div class="settings-group">
          <h3><span>ğŸ”§</span> Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø­Ø§ÙˆØ±</h3>
          <div class="form-group">
            <label for="xSpeed">Ø§Ù„Ø³Ø±Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­ÙˆØ± X (mm/min)</label>
            <input type="number" id="xSpeed" value="3000">
          </div>
          <div class="form-group">
            <label for="ySpeed">Ø§Ù„Ø³Ø±Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­ÙˆØ± Y (mm/min)</label>
            <input type="number" id="ySpeed" value="3000">
          </div>
          <div class="form-group">
            <label for="zSpeed">Ø§Ù„Ø³Ø±Ø¹Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø­ÙˆØ± Z (mm/min)</label>
            <input type="number" id="zSpeed" value="1000">
          </div>
          <div class="form-group">
            <label for="acceleration">Ø§Ù„ØªØ³Ø§Ø±Ø¹ (mm/sÂ²)</label>
            <input type="number" id="acceleration" value="500">
          </div>
        </div>

        <div class="settings-group">
          <h3><span>ğŸ“</span> Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¯Ù‚Ø©</h3>
          <div class="form-group">
            <label for="tolerance">Ø§Ù„ØªØ­Ù…Ù„ (mm)</label>
            <input type="number" id="tolerance" value="0.01" step="0.001">
          </div>
          <div class="form-group">
            <label for="stepover">Ø§Ù„ØªØ¯Ø§Ø®Ù„ Ø¨ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª (%)</label>
            <input type="number" id="stepover" value="50" min="10" max="90">
          </div>
          <div class="form-group">
            <label for="resolution">Ø¯Ù‚Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</label>
            <select id="resolution">
              <option value="low">Ù…Ù†Ø®ÙØ¶Ø©</option>
              <option value="medium" selected>Ù…ØªÙˆØ³Ø·Ø©</option>
              <option value="high">Ø¹Ø§Ù„ÙŠØ©</option>
            </select>
          </div>
        </div>

        <div class="settings-group">
          <h3><span>ğŸ”„</span> Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ­Ø³ÙŠÙ†</h3>
          <div class="form-group">
            <label for="retractDistance">Ù…Ø³Ø§ÙØ© Ø§Ù„Ø³Ø­Ø¨ (mm)</label>
            <input type="number" id="retractDistance" value="5" step="0.1">
          </div>
          <div class="form-group">
            <label for="retractSpeed">Ø³Ø±Ø¹Ø© Ø§Ù„Ø³Ø­Ø¨ (mm/min)</label>
            <input type="number" id="retractSpeed" value="1200">
          </div>
          <div class="form-group">
            <label for="plungeSpeed">Ø³Ø±Ø¹Ø© Ø§Ù„ØºÙˆØµ (mm/min)</label>
            <input type="number" id="plungeSpeed" value="300">
          </div>
          <div class="form-group">
            <label for="coolant">Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ¨Ø±ÙŠØ¯</label>
            <select id="coolant">
              <option value="none">Ø¨Ø¯ÙˆÙ†</option>
              <option value="mist">Ø±Ø°Ø§Ø°</option>
              <option value="flood">ØºÙ…Ø±</option>
            </select>
          </div>
        </div>

        <div class="action-buttons">
          <button class="btn btn-primary" onclick="saveAdvancedSettings()">
            <span>ğŸ’¾</span> Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
          </button>
          <button class="btn btn-secondary" onclick="loadDefaultAdvancedSettings()">
            <span>ğŸ”„</span> Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
          </button>
        </div>
      </div>

      <div class="path-preview">
        <h3><span>ğŸ”„</span> ØªØ­Ø³ÙŠÙ† Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©</h3>
        <div class="path-optimization">
          <div class="optimization-option">
            <input type="checkbox" id="adaptivePaths" checked>
            <label for="adaptivePaths">Ù…Ø³Ø§Ø±Ø§Øª ØªÙƒÙŠÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="reduceLift" checked>
            <label for="reduceLift">ØªÙ‚Ù„ÙŠÙ„ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø±ÙØ¹</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="optimizeOrder" checked>
            <label for="optimizeOrder">ØªØ­Ø³ÙŠÙ† ØªØ±ØªÙŠØ¨ Ø§Ù„Ù‚Ø·Ø¹</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="minimizeTravel" checked>
            <label for="minimizeTravel">ØªÙ‚Ù„ÙŠÙ„ Ù…Ø³Ø§ÙØ§Øª Ø§Ù„ØªÙ†Ù‚Ù„</label>
          </div>
        </div>
        
        <div class="path-preview-content" id="advancedPathPreview">
          <svg class="path-svg" id="advancedPathSvg"></svg>
        </div>
        
        <div class="path-controls">
          <button class="btn btn-primary" onclick="generateAdvancedPaths()">
            <span>ğŸ”</span> ØªÙˆÙ„ÙŠØ¯ Ù…Ø³Ø§Ø±Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
          </button>
          <button class="btn btn-analysis" onclick="analyzePaths()">
            <span>ğŸ“Š</span> ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
          </button>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <p>ØªÙ… Ø§Ù„ØªØ·ÙˆÙŠØ± Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Three.js Ùˆ TensorFlow.js - Ù…Ø´Ø±ÙˆØ¹ CncAI Ù…Ø¹ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„ØµÙˆØ±</p>
  </footer>

  <div class="notification" id="notification">ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­!</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
  <script>
    // Ø¹Ù†Ø§ØµØ± DOM
    const fileInput = document.getElementById('fileInput');
    const fileName = document.getElementById('fileName');
    const canvas2d = document.getElementById('preview2d');
    const ctx2d = canvas2d.getContext('2d');
    const heatmap = document.getElementById('heatmap');
    const ctxHeat = heatmap.getContext('2d');
    const edgesCanvas = document.getElementById('edgesCanvas');
    const ctxEdges = edgesCanvas.getContext('2d');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const ctxDrawing = drawingCanvas.getContext('2d');
    const preview3d = document.getElementById('preview3d');
    const rotationSpeedInput = document.getElementById('rotationSpeed');
    const zoomControl = document.getElementById('zoomControl');
    const heightIntensity = document.getElementById('heightIntensity');
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    const gcodeOutput = document.getElementById('gcodeOutput');
    const notification = document.getElementById('notification');
    const loading3d = document.getElementById('loading3d');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const edgeThreshold = document.getElementById('edgeThreshold');
    const analysisPanel = document.getElementById('analysisPanel');
    const analysisResults = document.getElementById('analysisResults');
    const gcodePreview = document.getElementById('gcodePreview');
    const gcodeStats = document.getElementById('gcodeStats');
    const woodStages = document.getElementById('woodStages');
    const pathSvg = document.getElementById('pathSvg');
    const advancedPathSvg = document.getElementById('advancedPathSvg');
    const materialType = document.getElementById('materialType');
    const startDrawingBtn = document.getElementById('startDrawing');
    const clearDrawingBtn = document.getElementById('clearDrawing');
    const applyDrawingBtn = document.getElementById('applyDrawing');
    const brushSizeInput = document.getElementById('brushSize');

    // Ø¥Ø¹Ø¯Ø§Ø¯ Three.js Ù„Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    const camera = new THREE.PerspectiveCamera(45, preview3d.offsetWidth / preview3d.offsetHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(preview3d.offsetWidth, preview3d.offsetHeight);
    preview3d.appendChild(renderer.domElement);

    // Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯
    function setupLights(scene) {
      const ambientLight = new THREE.AmbientLight(0x404040, 1);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);
      
      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight2.position.set(-1, -1, -1);
      scene.add(directionalLight2);
    }

    setupLights(scene);

    camera.position.z = 200;

    let mesh;
    let rotationSpeed = 0.01;
    let currentColormap = 'jet';
    let heightFactor = 80;
    let heightMapData = null;
    let originalImageData = null;
    let edgesImageData = null;
    let generatedGcode = '';
    let analysisData = null;
    let toolPaths = [];
    let advancedToolPaths = [];
    let stageGcodes = {
      roughing: '',
      finishing: '',
      smoothing: ''
    };

    // Ù…ØªØºÙŠØ±Ø§Øª Ù„Ù„Ø±Ø³Ù… Ø§Ù„ÙŠØ¯ÙˆÙŠ
    let isDrawing = false;
    let manualSelectionData = null;
    let lastX = 0;
    let lastY = 0;

    // ============== Ø¯ÙˆØ§Ù„ Ø§Ù„Ø±Ø³Ù… Ø§Ù„ÙŠØ¯ÙˆÙŠ ==============

    // ØªÙ‡ÙŠØ¦Ø© Ù„ÙˆØ­Ø© Ø§Ù„Ø±Ø³Ù…
    function initDrawingCanvas() {
      drawingCanvas.width = canvas2d.width;
      drawingCanvas.height = canvas2d.height;
      ctxDrawing.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctxDrawing.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }

    // Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù…
    function startDrawing() {
      isDrawing = true;
      startDrawingBtn.textContent = 'â¹ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø±Ø³Ù…';
      startDrawingBtn.classList.remove('btn-drawing');
      startDrawingBtn.classList.add('btn-secondary');
      drawingCanvas.style.cursor = 'crosshair';
      showNotification('Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù…: Ø§Ø±Ø³Ù… Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©', false, 'analysis');
    }

    // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø±Ø³Ù…
    function stopDrawing() {
      isDrawing = false;
      startDrawingBtn.textContent = 'âœï¸ Ø¨Ø¯Ø¡ Ø§Ù„Ø±Ø³Ù…';
      startDrawingBtn.classList.remove('btn-secondary');
      startDrawingBtn.classList.add('btn-drawing');
      drawingCanvas.style.cursor = 'default';
      showNotification('ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø±Ø³Ù…', false, 'analysis');
    }

    // Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ù…
    function clearDrawing() {
      ctxDrawing.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      ctxDrawing.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctxDrawing.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      manualSelectionData = null;
      showNotification('ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ù…', false, 'analysis');
    }

    // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø³Ù… Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø©
    function applyDrawing() {
      if (!originalImageData) {
        showNotification('ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹', true);
        return;
      }

      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³Ù…
      const drawingData = ctxDrawing.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
      
      // Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ
      manualSelectionData = drawingData;
      
      // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø³Ù… Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©
      const combinedData = new ImageData(drawingCanvas.width, drawingCanvas.height);
      const originalData = originalImageData.data;
      
      for (let i = 0; i < originalData.length; i += 4) {
        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ù…Ø±Ø³ÙˆÙ…Ø© (ØºÙŠØ± Ø´ÙØ§ÙØ©)
        if (drawingData.data[i+3] > 50) {
          // ØªØ¹Ø²ÙŠØ² Ø§Ù„Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø±Ø³ÙˆÙ…Ø©
          combinedData.data[i] = Math.min(255, originalData[i] * 1.2);
          combinedData.data[i+1] = Math.min(255, originalData[i+1] * 1.2);
          combinedData.data[i+2] = Math.min(255, originalData[i+2] * 1.2);
          combinedData.data[i+3] = 255;
        } else {
          // ØªØ®ÙÙŠÙ Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ ØºÙŠØ± Ø§Ù„Ù…Ø±Ø³ÙˆÙ…Ø©
          combinedData.data[i] = originalData[i] * 0.7;
          combinedData.data[i+1] = originalData[i+1] * 0.7;
          combinedData.data[i+2] = originalData[i+2] * 0.7;
          combinedData.data[i+3] = 255;
        }
      }
      
      // Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¹Ø¯Ù„Ø©
      ctx2d.putImageData(combinedData, 0, 0);
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ø§Ø±ØªÙØ§Ø¹ Ø¬Ø¯ÙŠØ¯Ø©
      createHeightMapFromCanvas(canvas2d);
      
      showNotification('ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø±Ø³Ù… Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø©', false, 'analysis');
    }

    // Ø±Ø³Ù… Ø¹Ù„Ù‰ Ø§Ù„Ù„ÙˆØ­Ø©
    function drawOnCanvas(e) {
      if (!isDrawing) return;
      
      const rect = drawingCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const brushSize = parseInt(brushSizeInput.value);
      
      ctxDrawing.lineJoin = 'round';
      ctxDrawing.lineCap = 'round';
      ctxDrawing.lineWidth = brushSize;
      ctxDrawing.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      
      ctxDrawing.beginPath();
      ctxDrawing.moveTo(lastX, lastY);
      ctxDrawing.lineTo(x, y);
      ctxDrawing.stroke();
      
      lastX = x;
      lastY = y;
    }

    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø±Ø³Ù…
    drawingCanvas.addEventListener('mousedown', (e) => {
      if (!isDrawing) return;
      
      const rect = drawingCanvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
      
      // Ø±Ø³Ù… Ù†Ù‚Ø·Ø© Ø¹Ù†Ø¯ Ø§Ù„Ù†Ù‚Ø±
      const brushSize = parseInt(brushSizeInput.value);
      ctxDrawing.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctxDrawing.beginPath();
      ctxDrawing.arc(lastX, lastY, brushSize/2, 0, Math.PI * 2);
      ctxDrawing.fill();
      
      drawingCanvas.addEventListener('mousemove', drawOnCanvas);
    });

    drawingCanvas.addEventListener('mouseup', () => {
      drawingCanvas.removeEventListener('mousemove', drawOnCanvas);
    });

    drawingCanvas.addEventListener('mouseleave', () => {
      drawingCanvas.removeEventListener('mousemove', drawOnCanvas);
    });

    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø±Ø³Ù…
    startDrawingBtn.addEventListener('click', () => {
      if (!originalImageData) {
        showNotification('ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹', true);
        return;
      }
      
      if (isDrawing) {
        stopDrawing();
      } else {
        startDrawing();
      }
    });

    clearDrawingBtn.addEventListener('click', clearDrawing);
    applyDrawingBtn.addEventListener('click', applyDrawing);

    // ============== Ù†Ù‡Ø§ÙŠØ© Ø¯ÙˆØ§Ù„ Ø§Ù„Ø±Ø³Ù… Ø§Ù„ÙŠØ¯ÙˆÙŠ ==============

    // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ØªØ§Ø¨Ø§Øª
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const tabId = tab.getAttribute('data-tab');
        
        // Ø¥Ù„ØºØ§Ø¡ ØªÙØ¹ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ§Ø¨Ø§Øª
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(tc => tc.classList.remove('active'));
        
        // ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ§Ø¨ Ø§Ù„Ù…Ø­Ø¯Ø¯
        tab.classList.add('active');
        document.getElementById(`${tabId}-tab`).classList.add('active');
      });
    });

    // ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø®Ø´Ø¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§Ø¯Ø©
    materialType.addEventListener('change', function() {
      if (this.value === 'wood') {
        woodStages.style.display = 'grid';
      } else {
        woodStages.style.display = 'none';
      }
    });

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„ØµÙˆØ±Ø©
    function applyEnhancement(type) {
      if (!originalImageData) {
        showNotification('ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹', true);
        return;
      }

      const canvas = document.createElement('canvas');
      canvas.width = canvas2d.width;
      canvas.height = canvas2d.height;
      const ctx = canvas.getContext('2d');
      ctx.putImageData(originalImageData, 0, 0);

      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      switch(type) {
        case 'brightness':
          // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø·ÙˆØ¹
          for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, data[i] + 30);
            data[i+1] = Math.min(255, data[i+1] + 30);
            data[i+2] = Math.min(255, data[i+2] + 30);
          }
          break;
        case 'contrast':
          // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ¨Ø§ÙŠÙ†
          const factor = 1.2;
          for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));
            data[i+1] = Math.min(255, Math.max(0, factor * (data[i+1] - 128) + 128));
            data[i+2] = Math.min(255, Math.max(0, factor * (data[i+2] - 128) + 128));
          }
          break;
        case 'sharpen':
          // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø­Ø¯Ø© (ØªØµÙÙŠØ© Ø¨Ø³ÙŠØ·Ø©)
          const weights = [0, -1, 0, -1, 5, -1, 0, -1, 0];
          const tempData = new Uint8ClampedArray(data);
          for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
              for (let c = 0; c < 3; c++) {
                let sum = 0;
                for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                    const idx = ((y + ky) * canvas.width + (x + kx)) * 4 + c;
                    const weight = weights[(ky + 1) * 3 + (kx + 1)];
                    sum += tempData[idx] * weight;
                  }
                }
                const idx = (y * canvas.width + x) * 4 + c;
                data[idx] = Math.min(255, Math.max(0, sum));
              }
            }
          }
          break;
        case 'smooth':
          // ØªØ·Ø¨ÙŠÙ‚ Ù†Ø¹ÙˆÙ…Ø© (ØªØµÙÙŠØ© Gaussian Ø¨Ø³ÙŠØ·Ø©)
          for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
              for (let c = 0; c < 3; c++) {
                let sum = 0;
                for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                    const idx = ((y + ky) * canvas.width + (x + kx)) * 4 + c;
                    sum += data[idx];
                  }
                }
                const idx = (y * canvas.width + x) * 4 + c;
                data[idx] = sum / 9;
              }
            }
          }
          break;
        case 'grayscale':
          // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ ØªØ¯Ø±Ø¬ Ø±Ù…Ø§Ø¯ÙŠ
          for (let i = 0; i < data.length; i += 4) {
            const avg = 0.3 * data[i] + 0.59 * data[i+1] + 0.11 * data[i+2];
            data[i] = data[i+1] = data[i+2] = avg;
          }
          break;
        case 'reset':
          // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©
          ctx.putImageData(originalImageData, 0, 0);
          break;
      }

      ctx.putImageData(imageData, 0, 0);
      ctx2d.clearRect(0, 0, canvas2d.width, canvas2d.height);
      ctx2d.drawImage(canvas, 0, 0);
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ø§Ø±ØªÙØ§Ø¹ Ø¬Ø¯ÙŠØ¯Ø© Ù…Ù† Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø­Ø³Ù†Ø©
      createHeightMapFromCanvas(canvas);
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ø§Ø±ØªÙØ§Ø¹ Ù…Ù† canvas
    function createHeightMapFromCanvas(canvas) {
      loading3d.style.display = 'flex';
      
      setTimeout(() => {
        const img = new Image();
        img.onload = () => {
          createHeightMap(img);
          loading3d.style.display = 'none';
        };
        img.src = canvas.toDataURL();
      }, 100);
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹
    function createHeightMap(image) {
      const w = Math.min(image.width, 100);
      const h = Math.min(image.height, 100);
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = w; 
      tempCanvas.height = h;
      const tctx = tempCanvas.getContext('2d');
      tctx.drawImage(image, 0, 0, w, h);
      const imgData = tctx.getImageData(0, 0, w, h).data;

      // Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù„Ø§Ø­Ù‚Ø§Ù‹ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ G-code
      heightMapData = {
        data: new Uint8Array(imgData),
        width: w,
        height: h
      };

      // Ø¥Ù†Ø´Ø§Ø¡ Ø´Ø¨ÙƒØ© 3D
      const geometry = new THREE.PlaneGeometry(100, 100, w-1, h-1);
      let min = 255, max = 0;
      const colors = [];
      
      for (let i = 0; i < geometry.attributes.position.count; i++) {
        const stride = i * 3;
        const x = i % w;
        const y = Math.floor(i / w);
        const idx = (y * w + x) * 4;
        const brightness = 0.34 * imgData[idx] + 0.5 * imgData[idx+1] + 0.16 * imgData[idx+2]; // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ grayscale
        min = Math.min(min, brightness);
        max = Math.max(max, brightness);
        geometry.attributes.position.array[stride + 2] = brightness / heightFactor;

        const norm = (brightness - min) / (max - min || 1);
        const color = getHeatColor(norm, currentColormap);
        colors.push(color.r/255, color.g/255, color.b/255);
      }
      
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.computeVertexNormals();

      const material = new THREE.MeshLambertMaterial({ 
        vertexColors: true, 
        side: THREE.DoubleSide,
        wireframe: false
      });
      
      if (mesh) scene.remove(mesh);
      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      drawHeatmap(imgData, w, h, min, max);
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø±Ø³Ù… Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø©
    function drawHeatmap(imgData, w, h, min, max) {
      heatmap.width = w;
      heatmap.height = h;
      const heatData = ctxHeat.createImageData(w, h);
      
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = (y * w + x) * 4;
          const brightness = 0.34 * imgData[idx] + 0.5 * imgData[idx+1] + 0.16 * imgData[idx+2]; // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ grayscale
          const norm = (brightness - min) / (max - min || 1);
          const color = getHeatColor(norm, currentColormap);
          heatData.data[idx] = color.r;
          heatData.data[idx+1] = color.g;
          heatData.data[idx+2] = color.b;
          heatData.data[idx+3] = 255;
        }
      }
      
      ctxHeat.putImageData(heatData, 0, 0);
    }

    // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù„ÙˆÙ† Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø­Ø±Ø§Ø±ÙŠØ©
    function getHeatColor(value, map) {
      let r=0, g=0, b=0;
      
      if(map === 'jet'){ 
        r = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-3),1),0));
        g = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-2),1),0));
        b = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-1),1),0));
      } else if(map === 'hot'){ 
        r = Math.floor(255 * Math.min(1, 3*value));
        g = Math.floor(255 * Math.min(1, 3*value-1));
        g = Math.max(g,0);
        b = Math.floor(255 * Math.min(1, 3*value-2));
        b = Math.max(b,0);
      } else if(map === 'cool'){
        r = Math.floor(255 * value);
        g = Math.floor(255 * (1-value));
        b = 255;
      } else if(map === 'gray'){
        r = g = b = Math.floor(255 * value);
      }
      
      return {r, g, b};
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ¹ÙŠÙŠÙ† Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø£Ù„ÙˆØ§Ù†
    function setColormap(map) {
      currentColormap = map;
      
      if(fileInput.files[0]){
        const img = new Image();
        img.onload = () => createHeightMap(img);
        img.src = URL.createObjectURL(fileInput.files[0]);
      }
    }

    // Ø¯ÙˆØ±Ø© Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
    function animate() {
      requestAnimationFrame(animate);
      if (mesh) mesh.rotation.y += rotationSpeed;
      renderer.render(scene, camera);
    }
    animate();

    // Ø£Ø­Ø¯Ø§Ø« Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ…
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      fileName.textContent = file.name;
      
      const img = new Image();
      img.onload = () => {
        canvas2d.width = img.width;
        canvas2d.height = img.height;
        edgesCanvas.width = img.width;
        edgesCanvas.height = img.height;
        drawingCanvas.width = img.width;
        drawingCanvas.height = img.height;
        ctx2d.drawImage(img, 0, 0, canvas2d.width, canvas2d.height);
        
        // Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©
        originalImageData = ctx2d.getImageData(0, 0, canvas2d.width, canvas2d.height);
        
        // ØªÙ‡ÙŠØ¦Ø© Ù„ÙˆØ­Ø© Ø§Ù„Ø±Ø³Ù…
        initDrawingCanvas();
        
        createHeightMap(img);
        showNotification('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­');
      };
      img.src = URL.createObjectURL(file);
    });

    rotationSpeedInput.addEventListener('input', () => {
      rotationSpeed = parseFloat(rotationSpeedInput.value);
    });

    zoomControl.addEventListener('input', () => {
      camera.position.z = parseFloat(zoomControl.value);
    });

    heightIntensity.addEventListener('input', () => {
      heightFactor = parseFloat(heightIntensity.value);
      if(fileInput.files[0]){
        const img = new Image();
        img.onload = () => createHeightMap(img);
        img.src = URL.createObjectURL(fileInput.files[0]);
      }
    });

    // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ/Ø§Ù„Ù†Ù‡Ø§Ø±ÙŠ
    const themeToggle = document.getElementById('themeToggle');
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark');
      themeToggle.textContent = document.body.classList.contains('dark') ? "â˜€ï¸" : "ğŸŒ™";
      
      // ØªØ­Ø¯ÙŠØ« Ù„ÙˆÙ† Ø®Ù„ÙÙŠØ© Ø§Ù„Ù…Ø´Ù‡Ø¯ Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
      scene.background = new THREE.Color(document.body.classList.contains('dark') ? 0x121212 : 0xf0f0f0);
    });

    // Ø¬Ø¹Ù„ Ø§Ù„Ù†Ù…Ø§Ø°Ø¬ Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ù…ØªØ¬Ø§ÙˆØ¨Ø©
    window.addEventListener('resize', () => {
      renderer.setSize(preview3d.offsetWidth, preview3d.offsetHeight);
      camera.aspect = preview3d.offsetWidth / preview3d.offsetHeight;
      camera.updateProjectionMatrix();
    });

    // Ø¯Ø§Ù„Ø© Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
    function showNotification(message, isError = false, type = '') {
      notification.textContent = message;
      notification.className = 'notification';
      if (isError) {
        notification.classList.add('error');
      } else if (type === 'ai') {
        notification.classList.add('ai');
      } else if (type === 'analysis') {
        notification.classList.add('analysis');
      }
      notification.classList.add('show');
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, 3000);
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù…
    function updateProgress(percent) {
      progressContainer.style.display = 'block';
      progressBar.style.width = percent + '%';
      
      if (percent >= 100) {
        setTimeout(() => {
          progressContainer.style.display = 'none';
        }, 500);
      }
    }

    // ============== Ø¯ÙˆØ§Ù„ ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù ==============

    // Ø¯Ø§Ù„Ø© Ù„ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Sobel
    function detectEdges(algorithm) {
      if (!originalImageData) {
        showNotification('ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹', true);
        return;
      }

      updateProgress(10);
      
      setTimeout(() => {
        const width = canvas2d.width;
        const height = canvas2d.height;
        
        // Ø¥Ù†Ø´Ø§Ø¡ canvas Ù…Ø¤Ù‚Øª
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(originalImageData, 0, 0);
        
        const imageData = tempCtx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        updateProgress(30);
        
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ ØªØ¯Ø±Ø¬ Ø±Ù…Ø§Ø¯ÙŠ Ø£ÙˆÙ„Ø§Ù‹
        const grayData = new Uint8ClampedArray(width * height);
        for (let i = 0; i < data.length; i += 4) {
          const gray = 0.3 * data[i] + 0.59 * data[i+1] + 0.11 * data[i+2];
          grayData[i/4] = gray;
        }
        
        updateProgress(50);
        
        let edgeData;
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©
        switch(algorithm) {
          case 'sobel':
            edgeData = applySobel(grayData, width, height);
            break;
          case 'canny':
            edgeData = applyCanny(grayData, width, height);
            break;
          case 'laplacian':
            edgeData = applyLaplacian(grayData, width, height);
            break;
          default:
            edgeData = applySobel(grayData, width, height);
        }
        
        updateProgress(80);
        
        // Ø±Ø³Ù… Ø§Ù„Ø­ÙˆØ§Ù Ø¹Ù„Ù‰ canvas Ø§Ù„Ø­ÙˆØ§Ù
        const edgeImageData = new ImageData(width, height);
        const threshold = parseInt(edgeThreshold.value);
        
        for (let i = 0; i < edgeData.length; i++) {
          const value = edgeData[i] > threshold ? 255 : 0;
          const idx = i * 4;
          edgeImageData.data[idx] = value;
          edgeImageData.data[idx+1] = value;
          edgeImageData.data[idx+2] = value;
          edgeImageData.data[idx+3] = 255;
        }
        
        ctxEdges.putImageData(edgeImageData, 0, 0);
        
        // Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø­ÙˆØ§Ù Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù„Ø§Ø­Ù‚Ø§Ù‹
        edgesImageData = edgeImageData;
        
        updateProgress(100);
        showNotification('ØªÙ… ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ø¨Ù†Ø¬Ø§Ø­ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ' + algorithm);
      }, 100);
    }

    // ØªØ·Ø¨ÙŠÙ‚ ÙƒØ§Ø´Ù Sobel
    function applySobel(grayData, width, height) {
      const sobelData = new Uint8ClampedArray(width * height);
      
      // Ù…Ø±Ø´Ø­Ø§Øª Sobel
      const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
      const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          let gx = 0;
          let gy = 0;
          
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx = (y + ky) * width + (x + kx);
              const kernelIdx = (ky + 1) * 3 + (kx + 1);
              
              gx += grayData[idx] * sobelX[kernelIdx];
              gy += grayData[idx] * sobelY[kernelIdx];
            }
          }
          
          const magnitude = Math.sqrt(gx * gx + gy * gy);
          sobelData[y * width + x] = magnitude;
        }
      }
      
      return sobelData;
    }

    // ØªØ·Ø¨ÙŠÙ‚ ÙƒØ§Ø´Ù Canny Ø§Ù„Ù…Ø¨Ø³Ø·
    function applyCanny(grayData, width, height) {
      // Ø£ÙˆÙ„Ø§Ù‹ Ù†Ø·Ø¨Ù‚ Sobel Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù‚Ø¯Ø§Ø± ÙˆØ§Ù„Ø§ØªØ¬Ø§Ù‡
      const sobelData = applySobel(grayData, width, height);
      
      // Ø«Ù… Ù†Ù‚ÙˆÙ… Ø¨Ù‚Ù…Ø¹ ØºÙŠØ± Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù‚ØµÙˆÙ‰ (ØªØ¨Ø³ÙŠØ· Ù„Ù„Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ©)
      const cannyData = new Uint8ClampedArray(width * height);
      
      for (let y = 2; y < height - 2; y++) {
        for (let x = 2; x < width - 2; x++) {
          const idx = y * width + x;
          const value = sobelData[idx];
          
          // Ù‚Ù…Ø¹ ØºÙŠØ± Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ù‚ØµÙˆÙ‰ (ØªØ¨Ø³ÙŠØ·)
          if (value > sobelData[idx - 1] && value > sobelData[idx + 1]) {
            cannyData[idx] = value;
          } else {
            cannyData[idx] = 0;
          }
        }
      }
      
      return cannyData;
    }

    // ØªØ·Ø¨ÙŠÙ‚ ÙƒØ§Ø´Ù Laplacian
    function applyLaplacian(grayData, width, height) {
      const laplacianData = new Uint8ClampedArray(width * height);
      const laplacianKernel = [0, 1, 0, 1, -4, 1, 0, 1, 0];
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          let sum = 0;
          
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx = (y + ky) * width + (x + kx);
              const kernelIdx = (ky + 1) * 3 + (kx + 1);
              
              sum += grayData[idx] * laplacianKernel[kernelIdx];
            }
          }
          
          laplacianData[y * width + x] = Math.abs(sum);
        }
      }
      
      return laplacianData;
    }

    // ØªØ­Ø¯ÙŠØ« ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø¹ØªØ¨Ø©
    function updateEdgeDetection() {
      if (!edgesImageData) return;
      
      const width = edgesCanvas.width;
      const height = edgesCanvas.height;
      const threshold = parseInt(edgeThreshold.value);
      const newImageData = new ImageData(width, height);
      
      for (let i = 0; i < edgesImageData.data.length; i += 4) {
        const value = edgesImageData.data[i] > threshold ? 255 : 0;
        newImageData.data[i] = value;
        newImageData.data[i+1] = value;
        newImageData.data[i+2] = value;
        newImageData.data[i+3] = 255;
      }
      
      ctxEdges.putImageData(newImageData, 0, 0);
    }

    // ============== Ø¯ÙˆØ§Ù„ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© ==============

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
    async function analyzeImage() {
      if (!originalImageData) {
        showNotification('ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹', true);
        return;
      }

      showNotification('Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...', false, 'analysis');
      updateProgress(10);
      
      try {
        // Ù…Ø­Ø§ÙƒØ§Ø© Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ù„ÙŠÙ„
        await new Promise(resolve => setTimeout(resolve, 1000));
        updateProgress(30);
        
        // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª ÙˆØ§Ù„Ù…Ù†Ø­Ø¯Ø±Ø§Øª
        const analysis = await analyzeHeightsAndSlopes();
        updateProgress(70);
        
        // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­ÙˆØ§Ù
        const edgeAnalysis = await analyzeEdges();
        updateProgress(90);
        
        // Ø¯Ù…Ø¬ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØ­Ù„ÙŠÙ„
        analysisData = {
          ...analysis,
          ...edgeAnalysis,
          complexity: calculateComplexity(analysis, edgeAnalysis)
        };
        
        // Ø¹Ø±Ø¶ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØ­Ù„ÙŠÙ„
        displayAnalysisResults(analysisData);
        updateProgress(100);
        
        showNotification('ØªÙ… ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­', false, 'analysis');
      } catch (error) {
        console.error('Error analyzing image:', error);
        showNotification('ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©', true);
      }
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª ÙˆØ§Ù„Ù…Ù†Ø­Ø¯Ø±Ø§Øª
    async function analyzeHeightsAndSlopes() {
      if (!heightMapData) return {};
      
      const width = heightMapData.width;
      const height = heightMapData.height;
      const data = heightMapData.data;
      
      let minHeight = 255;
      let maxHeight = 0;
      let totalHeight = 0;
      let slopeSum = 0;
      let slopeCount = 0;
      
      // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª
      for (let i = 0; i < data.length; i += 4) {
        const pixelHeight = 0.34 * data[i] + 0.5 * data[i+1] + 0.16 * data[i+2];
        minHeight = Math.min(minHeight, pixelHeight);
        maxHeight = Math.max(maxHeight, pixelHeight);
        totalHeight += pixelHeight;
      }
      
      const avgHeight = totalHeight / (data.length / 4);
      
      // ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ù†Ø­Ø¯Ø±Ø§Øª
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = (y * width + x) * 4;
          const center = 0.34 * data[idx] + 0.5 * data[idx+1] + 0.16 * data[idx+2];
          
          // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ù†Ø­Ø¯Ø± Ù…Ø¹ Ø§Ù„Ø¬ÙŠØ±Ø§Ù†
          const right = 0.34 * data[idx+4] + 0.5 * data[idx+5] + 0.16 * data[idx+6];
          const bottom = 0.34 * data[idx+width*4] + 0.5 * data[idx+width*4+1] + 0.16 * data[idx+width*4+2];
          
          const slopeX = Math.abs(center - right);
          const slopeY = Math.abs(center - bottom);
          
          slopeSum += (slopeX + slopeY) / 2;
          slopeCount++;
        }
      }
      
      const avgSlope = slopeSum / slopeCount;
      
      return {
        minHeight: minHeight,
        maxHeight: maxHeight,
        avgHeight: avgHeight,
        heightRange: maxHeight - minHeight,
        avgSlope: avgSlope
      };
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø­ÙˆØ§Ù
    async function analyzeEdges() {
      if (!edgesImageData) return {};
      
      const width = edgesCanvas.width;
      const height = edgesCanvas.height;
      const data = edgesImageData.data;
      
      let edgePixels = 0;
      let totalPixels = width * height;
      
      for (let i = 0; i < data.length; i += 4) {
        if (data[i] > 128) { // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø¨ÙŠÙƒØ³Ù„ ÙŠØ¹ØªØ¨Ø± Ø­Ø§ÙØ©
          edgePixels++;
        }
      }
      
      const edgeDensity = edgePixels / totalPixels;
      
      return {
        edgePixels: edgePixels,
        edgeDensity: edgeDensity
      };
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø­Ø³Ø§Ø¨ ØªØ¹Ù‚ÙŠØ¯ Ø§Ù„ØµÙˆØ±Ø©
    function calculateComplexity(heightAnalysis, edgeAnalysis) {
      if (!heightAnalysis || !edgeAnalysis) return 0;
      
      // Ø­Ø³Ø§Ø¨ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†Ø·Ø§Ù‚ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ ÙˆÙƒØ«Ø§ÙØ© Ø§Ù„Ø­ÙˆØ§Ù
      const heightComplexity = heightAnalysis.heightRange / 255; // ØªØ·Ø¨ÙŠØ¹ Ø¨ÙŠÙ† 0 Ùˆ1
      const edgeComplexity = edgeAnalysis.edgeDensity * 10; // ØªØ¶Ø®ÙŠÙ… Ø§Ù„ØªØ£Ø«ÙŠØ±
      const slopeComplexity = heightAnalysis.avgSlope / 100; // ØªØ·Ø¨ÙŠØ¹
      
      // Ø¯Ù…Ø¬ Ø§Ù„Ø¹ÙˆØ§Ù…Ù„ Ù…Ø¹ Ø£ÙˆØ²Ø§Ù† Ù…Ø®ØªÙ„ÙØ©
      const complexity = (heightComplexity * 0.4) + (edgeComplexity * 0.4) + (slopeComplexity * 0.2);
      
      // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø¨ÙŠÙ† 0 Ùˆ1
      return Math.min(1, Math.max(0, complexity));
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø¹Ø±Ø¶ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„ØªØ­Ù„ÙŠÙ„
    function displayAnalysisResults(analysis) {
      analysisPanel.style.display = 'block';
      
      analysisResults.innerHTML = `
        <div class="analysis-item">
          <h4>ğŸ“ Ù†Ø·Ø§Ù‚ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹</h4>
          <div class="analysis-value">${analysis.heightRange ? analysis.heightRange.toFixed(1) : 'N/A'}</div>
          <div>Ù…Ù† ${analysis.minHeight ? analysis.minHeight.toFixed(1) : 'N/A'} Ø¥Ù„Ù‰ ${analysis.maxHeight ? analysis.maxHeight.toFixed(1) : 'N/A'}</div>
        </div>
        <div class="analysis-item">
          <h4>ğŸ“ˆ Ù…ØªÙˆØ³Ø· Ø§Ù„Ø§Ø±ØªÙØ§Ø¹</h4>
          <div class="analysis-value">${analysis.avgHeight ? analysis.avgHeight.toFixed(1) : 'N/A'}</div>
          <div>Ù…Ù† 255</div>
        </div>
        <div class="analysis-item">
          <h4>ğŸ”„ Ù…ØªÙˆØ³Ø· Ø§Ù„Ù…Ù†Ø­Ø¯Ø±</h4>
          <div class="analysis-value">${analysis.avgSlope ? analysis.avgSlope.toFixed(2) : 'N/A'}</div>
          <div>Ø¯Ø±Ø¬Ø© Ø§Ù„Ø§Ù†Ø­Ø¯Ø§Ø±</div>
        </div>
        <div class="analysis-item">
          <h4>ğŸ” ÙƒØ«Ø§ÙØ© Ø§Ù„Ø­ÙˆØ§Ù</h4>
          <div class="analysis-value">${analysis.edgeDensity ? (analysis.edgeDensity * 100).toFixed(1) + '%' : 'N/A'}</div>
          <div>${analysis.edgePixels || 'N/A'} Ø¨ÙŠÙƒØ³Ù„</div>
        </div>
        <div class="analysis-item">
          <h4>ğŸ§© Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯</h4>
          <div class="analysis-value">${analysis.complexity ? (analysis.complexity * 100).toFixed(1) + '%' : 'N/A'}</div>
          <div>${getComplexityLevel(analysis.complexity)}</div>
        </div>
      `;
    }

    // Ø¯Ø§Ù„Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ¹Ù‚ÙŠØ¯ ÙƒÙ†Øµ
    function getComplexityLevel(complexity) {
      if (complexity < 0.3) return 'Ù…Ù†Ø®ÙØ¶';
      if (complexity < 0.6) return 'Ù…ØªÙˆØ³Ø·';
      return 'Ø¹Ø§Ù„ÙŠ';
    }

    // ============== Ø¯ÙˆØ§Ù„ ØªÙˆÙ„ÙŠØ¯ G-code Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ==============

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¥Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ø±ØªÙØ§Ø¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… TensorFlow.js
    async function processImageWithAI(imageData) {
      showNotification('Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...', false, 'ai');
      updateProgress(10);
      
      // ØªØ­ÙˆÙŠÙ„ ImageData Ø¥Ù„Ù‰ tensor
      const tensor = tf.browser.fromPixels(imageData);
      updateProgress(20);
      
      // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ ØªØ¯Ø±Ø¬ Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ
      let processed = tensor.mean(2).expandDims(2);
      updateProgress(30);
      
      // ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±Ø´Ø­ Gaussian Ù„ØªØ®ÙÙŠÙ Ø§Ù„Ø¶ÙˆØ¶Ø§Ø¡
      processed = tf.tidy(() => {
        const kernel = tf.tensor2d([
          [1, 2, 1],
          [2, 4, 2],
          [1, 2, 1]
        ], [3, 3]).div(16);
        
        return tf.depthwiseConv2d(
          processed, 
          kernel.expandDims(2).expandDims(3), 
          1, 
          'same'
        );
      });
      updateProgress(50);
      
      // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„ØªØ¨Ø§ÙŠÙ† Ù„ØªØ­Ø³ÙŠÙ† Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù‚Ø·Ø¹
      processed = tf.tidy(() => {
        const mean = processed.mean();
        const std = processed.sub(mean).square().mean().sqrt();
        return processed.sub(mean).div(std.add(1e-7)).clipByValue(-2, 2).add(2).div(4);
      });
      updateProgress(70);
      
      // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
      const data = await processed.squeeze().array();
      updateProgress(90);
      
      // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
      tensor.dispose();
      processed.dispose();
      updateProgress(100);
      
      return data;
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© TSP Ø§Ù„Ù…Ø¨Ø³Ø·Ø©
    function optimizeToolpaths(points) {
      if (points.length <= 1) return points;
      
      // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø£Ù‚Ø±Ø¨ Ø§Ù„Ø¬Ø§Ø± Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±
      const optimized = [points[0]];
      const remaining = points.slice(1);
      
      while (remaining.length > 0) {
        const lastPoint = optimized[optimized.length - 1];
        let closestIdx = 0;
        let minDist = Infinity;
        
        for (let i = 0; i < remaining.length; i++) {
          const dist = Math.sqrt(
            Math.pow(lastPoint.x - remaining[i].x, 2) + 
            Math.pow(lastPoint.y - remaining[i].y, 2)
          );
          
          if (dist < minDist) {
            minDist = dist;
            closestIdx = i;
          }
        }
        
        optimized.push(remaining[closestIdx]);
        remaining.splice(closestIdx, 1);
      }
      
      return optimized;
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†Ù‚Ø§Ø· Ø§Ù„Ø­ÙˆØ§Ù Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµÙˆØ±Ø©
    function extractEdgePoints(edgeData, width, height, cutDepth) {
      const points = [];
      const threshold = parseInt(edgeThreshold.value);
      
      for (let y = 0; y < height; y += 2) { // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¹ÙŠÙ†Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡
        for (let x = 0; x < width; x += 2) {
          const idx = y * width + x;
          if (edgeData[idx] > threshold) {
            points.push({
              x: (x / width) * 100 - 50, // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù…Ù† -50 Ø¥Ù„Ù‰ 50
              y: (y / height) * 100 - 50,
              z: -cutDepth
            });
          }
        }
      }
      
      return points;
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†Ù‚Ø§Ø· Ù…Ù† Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ
    function extractManualSelectionPoints(manualData, width, height, cutDepth) {
      const points = [];
      const threshold = 50; // Ø¹ØªØ¨Ø© Ø§Ù„Ø´ÙØ§ÙÙŠØ©
      
      for (let y = 0; y < height; y += 2) { // ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¹ÙŠÙ†Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡
        for (let x = 0; x < width; x += 2) {
          const idx = (y * width + x) * 4 + 3; // Ù‚Ù†Ø§Ø© Ø§Ù„Ø´ÙØ§ÙÙŠØ©
          if (manualData.data[idx] > threshold) {
            points.push({
              x: (x / width) * 100 - 50, // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù…Ù† -50 Ø¥Ù„Ù‰ 50
              y: (y / height) * 100 - 50,
              z: -cutDepth
            });
          }
        }
      }
      
      return points;
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ G-code Ø­Ù‚ÙŠÙ‚ÙŠ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµÙˆØ±Ø©
    async function generateRealGcode(stage = null) {
      if (!heightMapData || !originalImageData) {
        showNotification('ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹', true);
        return '';
      }

      const machineType = document.getElementById('machineType').value;
      const materialType = document.getElementById('materialType').value;
      let feedRate = parseInt(document.getElementById('feedRate').value);
      let spindleSpeed = parseInt(document.getElementById('spindleSpeed').value);
      let cutDepth = parseFloat(document.getElementById('cutDepth').value);
      let passDepth = parseFloat(document.getElementById('passDepth').value);
      const gcodePrecision = document.getElementById('gcodePrecision').value;
      const gcodeType = document.getElementById('gcodeType').value;
      const optimizePaths = document.getElementById('optimizePaths').checked;
      const smoothEdges = document.getElementById('smoothEdges').checked;
      const useEdges = document.getElementById('useEdges').checked;
      const startFromEdges = document.getElementById('startFromEdges').checked;
      const useManualSelection = document.getElementById('useManualSelection').checked;
      
      // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…Ø±Ø­Ù„Ø© Ù…Ø­Ø¯Ø¯Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¥Ø¹Ø¯Ø§Ø¯Ø§ØªÙ‡Ø§
      if (stage) {
        if (stage === 'roughing') {
          feedRate = parseInt(document.getElementById('roughingFeedRate').value);
          spindleSpeed = parseInt(document.getElementById('roughingSpindleSpeed').value);
          cutDepth = parseFloat(document.getElementById('roughingDepth').value);
        } else if (stage === 'finishing') {
          feedRate = parseInt(document.getElementById('finishingFeedRate').value);
          spindleSpeed = parseInt(document.getElementById('finishingSpindleSpeed').value);
          cutDepth = parseFloat(document.getElementById('finishingDepth').value);
        } else if (stage === 'smoothing') {
          feedRate = parseInt(document.getElementById('smoothingFeedRate').value);
          spindleSpeed = parseInt(document.getElementById('smoothingSpindleSpeed').value);
          cutDepth = parseFloat(document.getElementById('smoothingDepth').value);
        }
      }
      
      // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¯Ù‚Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
      let resolution = 5; // Ù…Ù†Ø®ÙØ¶Ø©
      if (gcodePrecision === 'medium') resolution = 3;
      if (gcodePrecision === 'high') resolution = 1;
      
      updateProgress(10);
      
      let points = [];
      
      if (useManualSelection && manualSelectionData && gcodeType === 'manual') {
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙŠØ¯ÙˆÙŠ Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
        points = extractManualSelectionPoints(manualSelectionData, canvas2d.width, canvas2d.height, cutDepth);
        updateProgress(50);
      } else if (useEdges && edgesImageData && gcodeType === 'edges') {
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­ÙˆØ§Ù Ø§Ù„ØµÙˆØ±Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
        const width = edgesCanvas.width;
        const height = edgesCanvas.height;
        const edgeData = new Uint8ClampedArray(width * height);
        
        for (let i = 0; i < edgesImageData.data.length; i += 4) {
          edgeData[i/4] = edgesImageData.data[i];
        }
        
        points = extractEdgePoints(edgeData, width, height, cutDepth);
        updateProgress(50);
      } else {
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„ØªÙ‚Ù„ÙŠØ¯ÙŠØ©
        const heightData = await processImageWithAI(originalImageData);
        updateProgress(50);
        
        const width = canvas2d.width;
        const height = canvas2d.height;
        
        for (let y = 0; y < height; y += resolution) {
          for (let x = 0; x < width; x += resolution) {
            const idx = Math.floor(y) * width + Math.floor(x);
            if (idx < heightData.length * width) {
              const pixelValue = heightData[Math.floor(y)][Math.floor(x)] || 0;
              // ØªØ­ÙˆÙŠÙ„ Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¨ÙŠÙƒØ³Ù„ Ø¥Ù„Ù‰ Ø¹Ù…Ù‚ Ù‚Ø·Ø¹ (Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø£ØºÙ…Ù‚ = Ù‚Ø·Ø¹ Ø£Ø¹Ù…Ù‚)
              const depth = (1 - pixelValue) * cutDepth;
              
              points.push({
                x: (x / width) * 100 - 50, // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù…Ù† -50 Ø¥Ù„Ù‰ 50
                y: (y / height) * 100 - 50,
                z: -depth
              });
            }
          }
        }
      }
      
      updateProgress(70);
      
      // Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø§Ù„Ø­ÙˆØ§Ù Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø®ÙŠØ§Ø± Ù…ÙØ¹Ù„Ø§Ù‹
      if (startFromEdges && edgesImageData) {
        points = sortPointsFromEdges(points);
      }
      
      // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø®ÙŠØ§Ø± Ù…ÙØ¹Ù„Ø§Ù‹
      toolPaths = optimizePaths ? optimizeToolpaths(points) : points;
      updateProgress(80);
      
      // ØªÙˆÙ„ÙŠØ¯ G-code
      let gcode = `; G-code generated by CNC AI with TensorFlow.js\n`;
      gcode += `; Machine: ${machineType}\n`;
      gcode += `; Material: ${materialType}\n`;
      if (stage) gcode += `; Stage: ${stage}\n`;
      gcode += `; Feed rate: ${feedRate} mm/min\n`;
      gcode += `; Spindle speed: ${spindleSpeed} RPM\n`;
      gcode += `; Total points: ${toolPaths.length}\n\n`;
      
      gcode += `G21 ; Set units to millimeters\n`;
      gcode += `G90 ; Absolute positioning\n`;
      gcode += `G0 Z5 ; Lift spindle\n`;
      gcode += `M3 S${spindleSpeed} ; Spindle on\n`;
      gcode += `G4 P2 ; Wait for spindle to reach speed\n\n`;
      
      gcode += `; Start cutting path\n`;
      gcode += `G0 X${toolPaths[0].x.toFixed(3)} Y${toolPaths[0].y.toFixed(3)} ; Move to start position\n`;
      
      // Ø¥Ø¶Ø§ÙØ© Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ø­Ø±ÙƒØ©
      for (let i = 0; i < toolPaths.length; i++) {
        const point = toolPaths[i];
        gcode += `G1 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} Z${point.z.toFixed(3)} F${feedRate}\n`;
      }
      
      gcode += `\nG0 Z5 ; Lift spindle\n`;
      gcode += `M5 ; Spindle off\n`;
      gcode += `G0 X0 Y0 ; Return to home\n`;
      gcode += `M30 ; End program\n`;
      
      updateProgress(100);
      return gcode;
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¨Ø¯Ø¡Ù‹Ø§ Ù…Ù† Ø§Ù„Ø­ÙˆØ§Ù
    function sortPointsFromEdges(points) {
      if (!edgesImageData || points.length === 0) return points;
      
      // Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ù…Ù† Ø§Ù„Ù†Ù‚Ø§Ø·
      const sortedPoints = [...points];
      
      // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„ØªÙŠ ØªÙ‚Ø¹ Ø¹Ù„Ù‰ Ø§Ù„Ø­ÙˆØ§Ù
      const edgePoints = [];
      const nonEdgePoints = [];
      
      const width = edgesCanvas.width;
      const height = edgesCanvas.height;
      
      for (const point of sortedPoints) {
        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„ØµÙˆØ±Ø©
        const x = Math.floor((point.x + 50) * width / 100);
        const y = Math.floor((point.y + 50) * height / 100);
        
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const idx = (y * width + x) * 4;
          if (edgesImageData.data[idx] > 128) {
            edgePoints.push(point);
          } else {
            nonEdgePoints.push(point);
          }
        } else {
          nonEdgePoints.push(point);
        }
      }
      
      // Ø§Ù„Ø¬Ù…Ø¹ Ø¨ÙŠÙ† Ø§Ù„Ù†Ù‚Ø§Ø· Ù…Ø¹ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨Ø§Ù„Ø­ÙˆØ§Ù
      return [...edgePoints, ...nonEdgePoints];
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ G-code
    async function generateGcode() {
      if (!heightMapData) {
        showNotification('ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹', true);
        return;
      }

      gcodeOutput.textContent = "â³ Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ G-code Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...";
      progressContainer.style.display = 'block';
      
      try {
        const gcode = await generateRealGcode();
        generatedGcode = gcode;
        gcodeOutput.textContent = gcode;
        
        // Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª G-code
        displayGcodeStats(gcode);
        
        // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
        updatePathPreview();
        
        showNotification('ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code Ø¨Ù†Ø¬Ø§Ø­ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ', false, 'ai');
      } catch (error) {
        console.error('Error generating G-code:', error);
        showNotification('ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ G-code', true);
      }
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ G-code Ù„Ù…Ø±Ø­Ù„Ø© Ù…Ø­Ø¯Ø¯Ø©
    async function generateStageGcode(stage) {
      if (!heightMapData) {
        showNotification('ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹', true);
        return;
      }

      showNotification(`Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ G-code Ù„Ù…Ø±Ø­Ù„Ø© ${stage}...`, false, 'analysis');
      progressContainer.style.display = 'block';
      
      try {
        const gcode = await generateRealGcode(stage);
        stageGcodes[stage] = gcode;
        
        showNotification(`ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code Ù„Ù…Ø±Ø­Ù„Ø© ${stage} Ø¨Ù†Ø¬Ø§Ø­`, false, 'analysis');
      } catch (error) {
        console.error(`Error generating ${stage} G-code:`, error);
        showNotification(`ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ G-code Ù„Ù…Ø±Ø­Ù„Ø© ${stage}`, true);
      }
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù…ÙŠÙ„ G-code Ù„Ù…Ø±Ø­Ù„Ø© Ù…Ø­Ø¯Ø¯Ø©
    function downloadStageGcode(stage) {
      if (!stageGcodes[stage]) {
        showNotification(`Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„Ù…Ø±Ø­Ù„Ø© ${stage}`, true);
        return;
      }
      
      const blob = new Blob([stageGcodes[stage]], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cnc-ai-${stage}.gcode`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showNotification(`ØªÙ… ØªØ­Ù…ÙŠÙ„ Ù…Ù„Ù ${stage} Ø¨Ù†Ø¬Ø§Ø­`);
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª G-code
    function displayGcodeStats(gcode) {
      gcodePreview.style.display = 'block';
      
      // ØªØ­Ù„ÙŠÙ„ G-code Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
      const lines = gcode.split('\n');
      const commandLines = lines.filter(line => line.startsWith('G0') || line.startsWith('G1'));
      const totalDistance = calculateTotalDistance(commandLines);
      const estimatedTime = calculateEstimatedTime(totalDistance);
      
      gcodeStats.innerHTML = `
        <div class="stat-item">
          <h4>ğŸ“ Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª</h4>
          <div class="stat-value">${commandLines.length}</div>
          <div>Ù…Ø³Ø§Ø± Ù‚Ø·Ø¹</div>
        </div>
        <div class="stat-item">
          <h4>ğŸ“ Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ©</h4>
          <div class="stat-value">${totalDistance.toFixed(2)}</div>
          <div>Ù…Ù„Ù…</div>
        </div>
        <div class="stat-item">
          <h4>â± Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹</h4>
          <div class="stat-value">${estimatedTime.toFixed(1)}</div>
          <div>Ø¯Ù‚ÙŠÙ‚Ø©</div>
        </div>
        <div class="stat-item">
          <h4>ğŸ“Š Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù</h4>
          <div class="stat-value">${(gcode.length / 1024).toFixed(2)}</div>
          <div>ÙƒÙŠÙ„ÙˆØ¨Ø§ì´íŠ¸</div>
        </div>
      `;
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠØ© Ù…Ù† Ø£ÙˆØ§Ù…Ø± G-code
    function calculateTotalDistance(commandLines) {
      let totalDistance = 0;
      let lastX = 0;
      let lastY = 0;
      let lastZ = 0;
      
      for (const line of commandLines) {
        const xMatch = line.match(/X([-\d.]+)/);
        const yMatch = line.match(/Y([-\d.]+)/);
        const zMatch = line.match(/Z([-\d.]+)/);
        
        const x = xMatch ? parseFloat(xMatch[1]) : lastX;
        const y = yMatch ? parseFloat(yMatch[1]) : lastY;
        const z = zMatch ? parseFloat(zMatch[1]) : lastZ;
        
        const distance = Math.sqrt(
          Math.pow(x - lastX, 2) + 
          Math.pow(y - lastY, 2) + 
          Math.pow(z - lastZ, 2)
        );
        
        totalDistance += distance;
        
        lastX = x;
        lastY = y;
        lastZ = z;
      }
      
      return totalDistance;
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø­Ø³Ø§Ø¨ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ Ù„Ù„Ù‚Ø·Ø¹
    function calculateEstimatedTime(totalDistance) {
      const feedRate = parseInt(document.getElementById('feedRate').value);
      return totalDistance / feedRate * 60; // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¯Ù‚Ø§Ø¦Ù‚
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù…ÙŠÙ„ G-code
    function downloadGcode() {
      if (!generatedGcode) {
        showNotification('Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„ØªØ­Ù…ÙŠÙ„Ù‡', true);
        return;
      }
      
      const blob = new Blob([generatedGcode], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'cnc-ai-program.gcode';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showNotification('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­');
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø§ÙŠÙ†Ø© Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù‚Ø·Ø¹
    function updatePathPreview() {
      if (toolPaths.length === 0) return;
      
      const svg = document.getElementById('pathSvg');
      svg.innerHTML = '';
      
      const width = 400;
      const height = 300;
      const padding = 20;
      
      // Ø¥Ø¹Ø¯Ø§Ø¯ Ø¹Ù†ØµØ± SVG
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      
      // Ø­Ø³Ø§Ø¨ Ù†Ø·Ø§Ù‚ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      
      for (const point of toolPaths) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
      
      // ØªØ­Ø¬ÙŠÙ… Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù„ØªÙ†Ø§Ø³Ø¨ SVG
      const scaleX = (width - 2 * padding) / (maxX - minX);
      const scaleY = (height - 2 * padding) / (maxY - minY);
      const scale = Math.min(scaleX, scaleY);
      
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª SVG
      const svgPoints = toolPaths.map(point => {
        const x = padding + (point.x - minX) * scale;
        const y = height - padding - (point.y - minY) * scale;
        return { x, y, z: point.z };
      });
      
      // Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      let d = `M ${svgPoints[0].x} ${svgPoints[0].y}`;
      
      for (let i = 1; i < svgPoints.length; i++) {
        d += ` L ${svgPoints[i].x} ${svgPoints[i].y}`;
      }
      
      path.setAttribute('d', d);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', '#4a90e2');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('stroke-linejoin', 'round');
      
      svg.appendChild(path);
      
      // Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø§Ø·
      for (let i = 0; i < svgPoints.length; i += Math.floor(svgPoints.length / 50)) {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', svgPoints[i].x);
        circle.setAttribute('cy', svgPoints[i].y);
        circle.setAttribute('r', '2');
        circle.setAttribute('fill', '#e74c3c');
        svg.appendChild(circle);
      }
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
    function optimizePaths() {
      if (toolPaths.length === 0) {
        showNotification('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø±Ø§Øª Ù„ØªØ­Ø³ÙŠÙ†Ù‡Ø§', true);
        return;
      }
      
      showNotification('Ø¬Ø§Ø±ÙŠ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª...', false, 'analysis');
      
      // Ù…Ø­Ø§ÙƒØ§Ø© Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ø³ÙŠÙ†
      setTimeout(() => {
        toolPaths = optimizeToolpaths(toolPaths);
        updatePathPreview();
        showNotification('ØªÙ… ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø¨Ù†Ø¬Ø§Ø­', false, 'analysis');
      }, 1000);
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªÙˆÙ„ÙŠØ¯ Ù…Ø³Ø§Ø±Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©
    function generateAdvancedPaths() {
      if (toolPaths.length === 0) {
        showNotification('ÙŠØ¬Ø¨ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø£ÙˆÙ„Ø§Ù‹', true);
        return;
      }
      
      showNotification('Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ Ù…Ø³Ø§Ø±Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©...', false, 'analysis');
      
      // Ù…Ø­Ø§ÙƒØ§Ø© Ø¹Ù…Ù„ÙŠØ© ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
      setTimeout(() => {
        advancedToolPaths = [...toolPaths];
        
        // ØªØ·Ø¨ÙŠÙ‚ ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©
        if (document.getElementById('adaptivePaths').checked) {
          advancedToolPaths = applyAdaptivePaths(advancedToolPaths);
        }
        
        if (document.getElementById('reduceLift').checked) {
          advancedToolPaths = reduceLiftMoves(advancedToolPaths);
        }
        
        if (document.getElementById('optimizeOrder').checked) {
          advancedToolPaths = optimizePathOrder(advancedToolPaths);
        }
        
        if (document.getElementById('minimizeTravel').checked) {
          advancedToolPaths = minimizeTravelDistance(advancedToolPaths);
        }
        
        // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
        updateAdvancedPathPreview();
        
        showNotification('ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­', false, 'analysis');
      }, 1500);
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ø³Ø§Ø±Ø§Øª ØªÙƒÙŠÙÙŠØ©
    function applyAdaptivePaths(paths) {
      // Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„ØªÙƒÙŠÙÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹
      return paths.map(point => {
        // ØªÙ‚Ù„ÙŠÙ„ ÙƒØ«Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø· ÙÙŠ Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ù…Ø³Ø·Ø­Ø©
        const intensity = Math.abs(point.z) / 10;
        return {
          ...point,
          x: point.x + (Math.random() * 2 - 1) * intensity,
          y: point.y + (Math.random() * 2 - 1) * intensity
        };
      });
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªÙ‚Ù„ÙŠÙ„ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø±ÙØ¹
    function reduceLiftMoves(paths) {
      // Ù…Ø­Ø§ÙƒØ§Ø© ØªÙ‚Ù„ÙŠÙ„ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø±ÙØ¹
      const newPaths = [];
      let lastZ = 0;
      
      for (const point of paths) {
        if (Math.abs(point.z - lastZ) < 2) {
          newPaths.push(point);
        } else {
          // Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø·Ø© ÙˆØ³ÙŠØ·Ø© Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø±ÙØ¹ Ø§Ù„Ù…ÙØ§Ø¬Ø¦
          newPaths.push({ x: point.x, y: point.y, z: lastZ + (point.z - lastZ) / 2 });
          newPaths.push(point);
        }
        lastZ = point.z;
      }
      
      return newPaths;
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø³ÙŠÙ† ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
    function optimizePathOrder(paths) {
      // Ù…Ø­Ø§ÙƒØ§Ø© ØªØ­Ø³ÙŠÙ† ØªØ±ØªÙŠØ¨ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
      return [...paths].sort((a, b) => {
        // ØªØ±ØªÙŠØ¨ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„ÙƒÙØ§Ø¡Ø©
        if (a.x !== b.x) return a.x - b.x;
        if (a.y !== b.y) return a.y - b.y;
        return a.z - b.z;
      });
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªÙ‚Ù„ÙŠÙ„ Ù…Ø³Ø§ÙØ§Øª Ø§Ù„ØªÙ†Ù‚Ù„
    function minimizeTravelDistance(paths) {
      // Ù…Ø­Ø§ÙƒØ§Ø© ØªÙ‚Ù„ÙŠÙ„ Ù…Ø³Ø§ÙØ§Øª Ø§Ù„ØªÙ†Ù‚Ù„
      if (paths.length <= 1) return paths;
      
      const optimized = [paths[0]];
      const remaining = paths.slice(1);
      
      while (remaining.length > 0) {
        const lastPoint = optimized[optimized.length - 1];
        let closestIdx = 0;
        let minDist = Infinity;
        
        for (let i = 0; i < remaining.length; i++) {
          const dist = Math.sqrt(
            Math.pow(lastPoint.x - remaining[i].x, 2) + 
            Math.pow(lastPoint.y - remaining[i].y, 2) + 
            Math.pow(lastPoint.z - remaining[i].z, 2)
          );
          
          if (dist < minDist) {
            minDist = dist;
            closestIdx = i;
          }
        }
        
        optimized.push(remaining[closestIdx]);
        remaining.splice(closestIdx, 1);
      }
      
      return optimized;
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
    function updateAdvancedPathPreview() {
      if (advancedToolPaths.length === 0) return;
      
      const svg = document.getElementById('advancedPathSvg');
      svg.innerHTML = '';
      
      const width = 400;
      const height = 300;
      const padding = 20;
      
      // Ø¥Ø¹Ø¯Ø§Ø¯ Ø¹Ù†ØµØ± SVG
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      
      // Ø­Ø³Ø§Ø¨ Ù†Ø·Ø§Ù‚ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      
      for (const point of advancedToolPaths) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
      
      // ØªØ­Ø¬ÙŠÙ… Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù„ØªÙ†Ø§Ø³Ø¨ SVG
      const scaleX = (width - 2 * padding) / (maxX - minX);
      const scaleY = (height - 2 * padding) / (maxY - minY);
      const scale = Math.min(scaleX, scaleY);
      
      // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª SVG
      const svgPoints = advancedToolPaths.map(point => {
        const x = padding + (point.x - minX) * scale;
        const y = height - padding - (point.y - minY) * scale;
        return { x, y, z: point.z };
      });
      
      // Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      let d = `M ${svgPoints[0].x} ${svgPoints[0].y}`;
      
      for (let i = 1; i < svgPoints.length; i++) {
        d += ` L ${svgPoints[i].x} ${svgPoints[i].y}`;
      }
      
      path.setAttribute('d', d);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', '#9c27b0');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('stroke-linejoin', 'round');
      
      svg.appendChild(path);
      
      // Ø±Ø³Ù… Ø§Ù„Ù†Ù‚Ø§Ø·
      for (let i = 0; i < svgPoints.length; i += Math.floor(svgPoints.length / 50)) {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', svgPoints[i].x);
        circle.setAttribute('cy', svgPoints[i].y);
        circle.setAttribute('r', '2');
        circle.setAttribute('fill', '#e74c3c');
        svg.appendChild(circle);
      }
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
    function analyzePaths() {
      if (advancedToolPaths.length === 0) {
        showNotification('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø³Ø§Ø±Ø§Øª Ù„ØªØ­Ù„ÙŠÙ„Ù‡Ø§', true);
        return;
      }
      
      showNotification('Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª...', false, 'analysis');
      
      // Ù…Ø­Ø§ÙƒØ§Ø© Ø¹Ù…Ù„ÙŠØ© Ø§Ù„ØªØ­Ù„ÙŠÙ„
      setTimeout(() => {
        const totalDistance = calculatePathsDistance(advancedToolPaths);
        const efficiency = calculatePathsEfficiency(advancedToolPaths);
        
        showNotification(`ØªÙ… ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª: Ø§Ù„Ù…Ø³Ø§ÙØ© ${totalDistance.toFixed(2)} Ù…Ù„Ù…ØŒ Ø§Ù„ÙƒÙØ§Ø¡Ø© ${efficiency.toFixed(1)}%`, false, 'analysis');
      }, 1000);
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§ÙØ© Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
    function calculatePathsDistance(paths) {
      let totalDistance = 0;
      
      for (let i = 1; i < paths.length; i++) {
        const dist = Math.sqrt(
          Math.pow(paths[i].x - paths[i-1].x, 2) + 
          Math.pow(paths[i].y - paths[i-1].y, 2) + 
          Math.pow(paths[i].z - paths[i-1].z, 2)
        );
        totalDistance += dist;
      }
      
      return totalDistance;
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø­Ø³Ø§Ø¨ ÙƒÙØ§Ø¡Ø© Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
    function calculatePathsEfficiency(paths) {
      if (paths.length <= 1) return 100;
      
      // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„ÙØ¹Ù„ÙŠØ©
      const actualDistance = calculatePathsDistance(paths);
      
      // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ© Ø§Ù„Ù…Ø«Ø§Ù„ÙŠØ© (Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø£ÙˆÙ„ ÙˆØ¢Ø®Ø± Ù†Ù‚Ø·Ø©)
      const idealDistance = Math.sqrt(
        Math.pow(paths[paths.length-1].x - paths[0].x, 2) + 
        Math.pow(paths[paths.length-1].y - paths[0].y, 2) + 
        Math.pow(paths[paths.length-1].z - paths[0].z, 2)
      );
      
      // Ø­Ø³Ø§Ø¨ Ø§Ù„ÙƒÙØ§Ø¡Ø©
      return (idealDistance / actualDistance) * 100;
    }

    // Ø¯Ø§Ù„Ø© Ù„Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
    function saveAdvancedSettings() {
      const settings = {
        xSpeed: document.getElementById('xSpeed').value,
        ySpeed: document.getElementById('ySpeed').value,
        zSpeed: document.getElementById('zSpeed').value,
        acceleration: document.getElementById('acceleration').value,
        tolerance: document.getElementById('tolerance').value,
        stepover: document.getElementById('stepover').value,
        resolution: document.getElementById('resolution').value,
        retractDistance: document.getElementById('retractDistance').value,
        retractSpeed: document.getElementById('retractSpeed').value,
        plungeSpeed: document.getElementById('plungeSpeed').value,
        coolant: document.getElementById('coolant').value
      };
      
      localStorage.setItem('cncAdvancedSettings', JSON.stringify(settings));
      showNotification('ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø¨Ù†Ø¬Ø§Ø­');
    }

    // Ø¯Ø§Ù„Ø© Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    function loadDefaultAdvancedSettings() {
      document.getElementById('xSpeed').value = 3000;
      document.getElementById('ySpeed').value = 3000;
      document.getElementById('zSpeed').value = 1000;
      document.getElementById('acceleration').value = 500;
      document.getElementById('tolerance').value = 0.01;
      document.getElementById('stepover').value = 50;
      document.getElementById('resolution').value = 'medium';
      document.getElementById('retractDistance').value = 5;
      document.getElementById('retractSpeed').value = 1200;
      document.getElementById('plungeSpeed').value = 300;
      document.getElementById('coolant').value = 'none';
      
      showNotification('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©');
    }

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©
    window.addEventListener('load', () => {
      const savedSettings = localStorage.getItem('cncAdvancedSettings');
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        document.getElementById('xSpeed').value = settings.xSpeed;
        document.getElementById('ySpeed').value = settings.ySpeed;
        document.getElementById('zSpeed').value = settings.zSpeed;
        document.getElementById('acceleration').value = settings.acceleration;
        document.getElementById('tolerance').value = settings.tolerance;
        document.getElementById('stepover').value = settings.stepover;
        document.getElementById('resolution').value = settings.resolution;
        document.getElementById('retractDistance').value = settings.retractDistance;
        document.getElementById('retractSpeed').value = settings.retractSpeed;
        document.getElementById('plungeSpeed').value = settings.plungeSpeed;
        document.getElementById('coolant').value = settings.coolant;
      }
    });

    // ØªØ­Ø¯ÙŠØ« Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø®Ø§Ù…Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©
    document.getElementById('machineType').addEventListener('change', function() {
      const materialSelect = document.getElementById('materialType');
      const machineType = this.value;
      
      // Ù…Ø³Ø­ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø­Ø§Ù„ÙŠØ©
      materialSelect.innerHTML = '';
      
      // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©
      if (machineType === 'cnc') {
        materialSelect.innerHTML = `
          <option value="wood">Ø®Ø´Ø¨</option>
          <option value="acrylic">Ø£ÙƒØ±ÙŠÙ„ÙŠÙƒ</option>
          <option value="aluminum">Ø£Ù„ÙˆÙ…Ù†ÙŠÙˆÙ…</option>
          <option value="steel">ØµÙ„Ø¨</option>
        `;
      } else if (machineType === 'laser') {
        materialSelect.innerHTML = `
          <option value="wood">Ø®Ø´Ø¨</option>
          <option value="acrylic">Ø£ÙƒØ±ÙŠÙ„ÙŠÙƒ</option>
          <option value="leather">Ø¬Ù„Ø¯</option>
          <option value="fabric">Ù‚Ù…Ø§Ø´</option>
        `;
      } else if (machineType === '3dprinter') {
        materialSelect.innerHTML = `
          <option value="pla">PLA (Ø¨Ù„Ø§Ø³ØªÙŠÙƒ)</option>
          <option value="abs">ABS (Ø¨Ù„Ø§Ø³ØªÙŠÙƒ)</option>
          <option value="petg">PETG (Ø¨Ù„Ø§Ø³ØªÙŠÙƒ)</option>
          <option value="tpu">TPU (Ù…Ø·Ø§Ø·ÙŠ)</option>
        `;
      }
    });

    // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙØ­Ø©
    window.addEventListener('beforeunload', () => {
      // ØªÙ†Ø¸ÙŠÙ Tensors Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù…ÙˆØ¬ÙˆØ¯Ø©
      if (tf && tf.memory) {
        tf.disposeVariables();
      }
      
      // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù…Ù† Three.js
      if (mesh) {
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
        mesh = null;
      }
      
      // ØªÙ†Ø¸ÙŠÙ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµÙˆØ±
      originalImageData = null;
      edgesImageData = null;
      manualSelectionData = null;
      heightMapData = null;
      
      // Ø¥Ù„ØºØ§Ø¡ Ø¹Ù†Ø§ØµØ± DOM Ø§Ù„Ù…Ø®ØµØµØ©
      URL.revokeObjectURL(fileInput.src);
    });

    // ØªØ­Ø³ÙŠÙ† Ø£Ø¯Ø§Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Web Workers
    function createImageProcessingWorker() {
      const workerCode = `
        self.addEventListener('message', function(e) {
          const { data, width, height, type } = e.data;
          let result = new Uint8ClampedArray(data);
          
          switch(type) {
            case 'brightness':
              for (let i = 0; i < data.length; i += 4) {
                result[i] = Math.min(255, data[i] + 30);
                result[i+1] = Math.min(255, data[i+1] + 30);
                result[i+2] = Math.min(255, data[i+2] + 30);
                result[i+3] = data[i+3];
              }
              break;
            case 'contrast':
              const factor = 1.2;
              for (let i = 0; i < data.length; i += 4) {
                result[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));
                result[i+1] = Math.min(255, Math.max(0, factor * (data[i+1] - 128) + 128));
                result[i+2] = Math.min(255, Math.max(0, factor * (data[i+2] - 128) + 128));
                result[i+3] = data[i+3];
              }
              break;
            // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‡Ù†Ø§
          }
          
          self.postMessage({ result: result.buffer }, [result.buffer]);
        });
      `;
      
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      return new Worker(URL.createObjectURL(blob));
    }

    // Ø§Ø³ØªØ®Ø¯Ø§Ù… Web Worker Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ØªØ§Ø­Ù‹Ø§
    let imageWorker = null;
    if (window.Worker) {
      imageWorker = createImageProcessingWorker();
      imageWorker.onmessage = function(e) {
        const processedData = new Uint8ClampedArray(e.data.result);
        const imageData = new ImageData(processedData, canvas2d.width, canvas2d.height);
        ctx2d.putImageData(imageData, 0, 0);
        createHeightMapFromCanvas(canvas2d);
      };
    }
  </script>
</body>
</html>
