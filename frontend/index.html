<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>CNC AI â€” Multi Machine Raster Engraving (With Debug Overlay)</title>

  <!-- Ù…ÙƒØªØ¨Ø§Øª -->
  <script src="https://docs.opencv.org/4.8.0/opencv.js" async></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

  <style>
    /* ØªÙ†Ø³ÙŠÙ‚Ø§Øª Ø£Ø³Ø§Ø³ÙŠØ© (Ù…Ø­Ø§ÙØ¸Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¸Ù‡Ø± Ø§Ù„Ø£ØµÙ„ÙŠ) */
    * { box-sizing: border-box; }
    body { margin: 0; font-family: Arial, Segoe UI, system-ui; background: #041022; color:#e6eef6; line-height:1.5 }
    .app { max-width:1400px; margin:16px auto; padding:14px }
    header { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #1e293b }
    .grid { display:grid; grid-template-columns:1fr 480px; gap:16px }
    @media (max-width:1000px){ .grid{ grid-template-columns:1fr } }
    .panel { background:#0b1320; padding:16px; border-radius:10px; border:1px solid #1e293b }
    .tabs { display:flex; margin-top:12px; border-bottom:1px solid #1e293b }
    .tabs button { margin-left:6px; padding:8px 14px; border:none; border-radius:6px 6px 0 0; cursor:pointer; background:transparent; color:#9bb0c8; font-size:0.9rem }
    .tabs button.active { background:#06b6d4; color:#021 }
    .tab-content { display:none; margin-top:12px }
    .tab-content.active { display:block }
    canvas { max-width:100%; border-radius:6px; background:#000; display:block; margin:0 auto; border:1px solid #334155 }
    #threeContainer { width:100%; height:400px; background:#081224; border-radius:8px; overflow:hidden; position:relative }
    label { display:block; margin-top:12px; color:#cfeaf2; font-weight:bold }
    input, select, textarea, button { font-size:0.9rem }
    input, select { width:100%; padding:8px 10px; border-radius:6px; border:1px solid #1e293b; background:#0f172a; color:#e6eef6; margin-top:6px }
    .button-group { display:flex; flex-direction:column; gap:8px; margin-top:16px }
    button { background:#1e293b; color:#e6eef6; border:none; padding:10px; border-radius:8px; cursor:pointer }
    button.primary { background:#06b6d4; color:#021; font-weight:bold }
    #toast { position:fixed; left:16px; bottom:16px; background:rgba(0,0,0,0.85); color:#fff; padding:10px 14px; border-radius:8px; display:none; z-index:10000 }
    .canvas-placeholder { width:100%; height:300px; background:#000; border-radius:6px; display:flex; align-items:center; justify-content:center; color:#9bb0c8; border:1px solid #334155 }

    /* Debug overlay */
    #debugOverlay {
      position: fixed;
      right: 16px;
      bottom: 16px;
      width: 360px;
      max-height: 50vh;
      background: rgba(2,6,23,0.85);
      color: #e6eef6;
      border: 1px solid rgba(102, 126, 234, 0.08);
      border-radius: 8px;
      font-size: 13px;
      z-index: 20000;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 8px 30px rgba(0,0,0,0.6);
    }
    #debugHeader {
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:8px 10px;
      border-bottom:1px solid rgba(255,255,255,0.03);
      background: linear-gradient(90deg, rgba(6,182,212,0.06), rgba(8,145,178,0.02));
    }
    #debugHeader b { color:#aee8f2; }
    #debugControls { display:flex; gap:6px; align-items:center; }
    .dbg-btn { background:transparent; border:1px solid rgba(255,255,255,0.06); color:#cfeaf2; padding:6px 8px; border-radius:6px; cursor:pointer; font-size:12px; }
    #debugList { overflow:auto; padding:8px; display:flex; flex-direction:column; gap:6px; }
    .dbg-item { padding:8px; border-radius:6px; background:rgba(255,255,255,0.02); line-height:1.2; max-height:120px; overflow:auto; font-family:monospace; font-size:12px; }
    .dbg-time { opacity:0.7; font-size:11px; margin-bottom:6px; display:block; }
    .dbg-error { border-left:4px solid #ef4444; }
    .dbg-warn { border-left:4px solid #f59e0b; }
    .dbg-info { border-left:4px solid #06b6d4; color:#cfeaf2; }
    .dbg-meta { opacity:0.75; font-size:11px; margin-top:6px; color:#9bb0c8; }
    #debugFooter { padding:6px 10px; border-top:1px solid rgba(255,255,255,0.02); text-align:right; font-size:12px; color:#9bb0c8; background:rgba(0,0,0,0.03); }

    .simulation-controls { position:absolute; top:10px; left:10px; z-index:100; display:flex; gap:8px }
    .simulation-controls button { background:rgba(0,0,0,0.7); color:white; border:1px solid #06b6d4; border-radius:4px; padding:6px 12px; cursor:pointer; font-size:0.8rem }

    @keyframes spin { 0%{transform:rotate(0)}100%{transform:rotate(360deg)} }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>CNC AI â€” Multi Machine Raster Engraving</h1>
      <div id="cvState">
        <span class="loading" style="display:inline-block;width:16px;height:16px;border:3px solid #f3f3f3;border-top:3px solid #06b6d4;border-radius:50%;animation:spin 1s linear infinite;margin-left:8px;"></span>
        Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ OpenCV...
      </div>
    </header>

    <div class="grid">
      <!-- Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„ÙŠØ³Ø±Ù‰: Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø§Øª -->
      <div class="panel">
        <div class="file-input-container" style="margin-bottom:12px">
          <input id="fileInput" type="file" accept="image/*"/>
          <label class="file-input-label" for="fileInput" style="display:block;padding:10px;background:#1e293b;border-radius:6px;color:#e6eef6;text-align:center;cursor:pointer;border:2px dashed #334155">ğŸ“ Ø§Ø®ØªØ± ØµÙˆØ±Ø© Ù„Ù„ØªØ­Ù…ÙŠÙ„</label>
        </div>

        <div class="tabs">
          <button data-tab="original" class="active">ğŸ–¼ï¸ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</button>
          <button data-tab="heatmap">ğŸ”¥ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø©</button>
          <button data-tab="contour">ğŸ“ Ø§Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ø­ÙˆØ§Ù</button>
          <button data-tab="simulation">ğŸ¬ Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ØªØ´ØºÙŠÙ„</button>
        </div>

        <div id="original" class="tab-content active">
          <div class="canvas-placeholder" id="originalPlaceholder">Ø³ÙŠØªÙ… Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø© Ù‡Ù†Ø§</div>
          <canvas id="canvasOriginal" style="display:none;"></canvas>
        </div>

        <div id="heatmap" class="tab-content">
          <div class="canvas-placeholder" id="heatmapPlaceholder">Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø© Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©</div>
          <canvas id="canvasHeatmap" style="display:none;"></canvas>
        </div>

        <div id="contour" class="tab-content">
          <div class="canvas-placeholder" id="contourPlaceholder">ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ø³ÙŠØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©</div>
          <canvas id="canvasContour" style="display:none;"></canvas>
        </div>

        <div id="simulation" class="tab-content">
          <div id="threeContainer">
            <div class="canvas-placeholder" id="simulationPlaceholder">Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªÙˆÙ„ÙŠØ¯ G-code</div>
          </div>
        </div>
      </div>

      <!-- Ø§Ù„Ù„ÙˆØ­Ø© Ø§Ù„ÙŠÙ…Ù†Ù‰: Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ§Ù„ØªØ­ÙƒÙ… -->
      <div class="panel">
        <div class="panel-section">
          <h3>âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</h3>
          <label for="machineType">Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</label>
          <select id="machineType">
            <option value="router">Router CNC</option>
            <option value="laser">Laser Engraver</option>
            <option value="plasma">Plasma Cutter</option>
            <option value="3dprinter">3D Printer</option>
          </select>
          <div class="info-text" id="machineDescription">Router CNC - Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ù†Ø­Øª Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø´Ø¨ ÙˆØ§Ù„Ø£ÙƒØ±ÙŠÙ„ÙŠÙƒ ÙˆØ§Ù„Ù…Ø¹Ø§Ø¯Ù† Ø§Ù„Ù„ÙŠÙ†Ø©</div>
        </div>

        <div class="panel-section">
          <h3>ğŸ“ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø­Ø¬Ù… Ø§Ù„Ø¹Ù…Ù„</h3>
          <div class="input-group" style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
            <div>
              <label for="workWidth">Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù…Ù„ (Ø³Ù…)</label>
              <input id="workWidth" type="number" value="30" step="0.1" min="1" max="200"/>
              <div class="dimension-info" id="widthMm">300.0 Ù…Ù…</div>
            </div>
            <div>
              <label for="workHeight">Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¹Ù…Ù„ (Ø³Ù…)</label>
              <input id="workHeight" type="number" value="20" step="0.1" min="1" max="200"/>
              <div class="dimension-info" id="heightMm">200.0 Ù…Ù…</div>
            </div>
          </div>

          <label for="workDepth">Ø¹Ù…Ù‚ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
          <input id="workDepth" type="number" value="3.0" step="0.1" min="0.1" max="50"/>

          <div class="settings-row" style="display:flex;gap:10px;align-items:end;margin-top:8px">
            <div class="input-group" style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
              <div>
                <label for="originX">Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„ X (Ø³Ù…)</label>
                <input id="originX" type="number" value="0" step="0.1"/>
              </div>
              <div>
                <label for="originY">Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„ Y (Ø³Ù…)</label>
                <input id="originY" type="number" value="0" step="0.1"/>
              </div>
            </div>
            <button id="btnCenterOrigin" class="secondary">ğŸ¯ ØªÙˆØ³ÙŠØ· Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„</button>
          </div>
        </div>

        <div class="panel-section">
          <h3>ğŸš€ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªØ´ØºÙŠÙ„</h3>
          <label for="feedRate">Ø³Ø±Ø¹Ø© Ø§Ù„ØªØºØ°ÙŠØ© (Ù…Ù…/Ø¯Ù‚ÙŠÙ‚Ø©)</label>
          <input id="feedRate" type="number" value="800" min="10" max="5000"/>
          <label for="safeZ">Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø£Ù…Ø§Ù† (Ù…Ù…)</label>
          <input id="safeZ" type="number" value="5" step="0.1" min="0" max="100"/>
          <label for="scanDir">Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª</label>
          <select id="scanDir">
            <option value="x">Ø£ÙÙ‚ÙŠ (X)</option>
            <option value="y">Ø±Ø£Ø³ÙŠ (Y)</option>
          </select>
          <label for="stepOver">Ø®Ø·ÙˆØ© Ø§Ù„Ù…Ø³Ø­ (Ù…Ù…)</label>
          <input id="stepOver" type="number" value="5" step="0.1" min="0.1" max="50"/>
          <label for="maxDepth">Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ (Ù…Ù…)</label>
          <input id="maxDepth" type="number" value="3.0" step="0.1" min="0.1" max="50"/>
        </div>

        <div class="button-group">
          <button id="btnGen" class="primary">âš¡ ØªÙˆÙ„ÙŠØ¯ G-code</button>
          <button id="btnQuick">ğŸ§ª Ø§Ø®ØªØ¨Ø§Ø± Ø³Ø±ÙŠØ¹</button>
          <button id="btnDownload">ğŸ’¾ ØªØ­Ù…ÙŠÙ„ G-code</button>
        </div>

        <div id="estTime" style="margin-top:12px;color:#9bb0c8;text-align:center;padding:8px;background:#0f172a;border-radius:6px"></div>

        <label for="gcodeOut" style="margin-top:16px">ğŸ“„ Ù…Ø®Ø±Ø¬Ø§Øª G-code</label>
        <textarea id="gcodeOut" readonly placeholder="Ø³ÙŠØ¸Ù‡Ø± G-code Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙˆÙ„ÙŠØ¯..." style="height:200px;background:#021024;color:#cfeaf2;border-radius:8px;padding:10px;"></textarea>

      </div>
    </div>
  </div>

  <!-- Debug Overlay -->
  <div id="debugOverlay" aria-live="polite" role="status">
    <div id="debugHeader">
      <div><b>Debug</b> â€” Console</div>
      <div id="debugControls">
        <button id="dbgCopy" class="dbg-btn" title="Ù†Ø³Ø® Ø§Ù„Ø³Ø¬Ù„">ğŸ“‹ Ù†Ø³Ø®</button>
        <button id="dbgClear" class="dbg-btn" title="Ù…Ø³Ø­ Ø§Ù„Ø³Ø¬Ù„">ğŸ§¹ Ù…Ø³Ø­</button>
      </div>
    </div>
    <div id="debugList"></div>
    <div id="debugFooter">Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ ÙˆØ§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
  </div>

  <div id="toast"></div>

  <script>
    // ========= Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø© =========
    let cvReady = false;
    let grayMat = null;
    let contour = null;
    let previewCanvas = null;
    let additionalContours = []; // array of {contour, area}
    let lastScanDir = 'x'; // Ù„Ø­ÙØ¸ Ø¢Ø®Ø± Ø§ØªØ¬Ø§Ù‡ Ù…Ø³Ø­ (Ù„ØªÙ„ÙˆÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø± Ø¨Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©)

    // Simulation
    let scene, camera, renderer, controls;
    let simulation = { isPlaying: false, animationId: null, tool: null, toolPath: null, currentIndex: 0 };

    // ========= Debug overlay system =========
    (function initDebugOverlay(){
      const debugList = document.getElementById('debugList');
      const dbgClear = document.getElementById('dbgClear');
      const dbgCopy = document.getElementById('dbgCopy');

      const logs = [];

      function formatTime(d) {
        return d.toISOString().slice(11, 23);
      }

      function addEntry(type, message, stack) {
        const time = new Date();
        const entry = { time, type, message, stack };
        logs.push(entry);

        const div = document.createElement('div');
        div.className = 'dbg-item ' + (type === 'error' ? 'dbg-error' : (type === 'warn' ? 'dbg-warn' : 'dbg-info'));
        const tspan = document.createElement('span');
        tspan.className = 'dbg-time';
        tspan.textContent = `[${formatTime(time)}] ${type.toUpperCase()}`;
        const msg = document.createElement('div');
        msg.textContent = message;
        div.appendChild(tspan);
        div.appendChild(msg);
        if (stack) {
          const meta = document.createElement('div');
          meta.className = 'dbg-meta';
          meta.textContent = stack.split('\n').slice(0,3).join(' | ');
          div.appendChild(meta);
        }
        debugList.prepend(div);
      }

      dbgClear.addEventListener('click', () => {
        debugList.innerHTML = '';
        logs.length = 0;
      });

      dbgCopy.addEventListener('click', async () => {
        try {
          const text = logs.map(l => `[${l.time.toISOString()}] ${l.type.toUpperCase()}: ${l.message}\n${l.stack||''}`).join('\n\n');
          await navigator.clipboard.writeText(text);
          addEntry('info', 'ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø³Ø¬Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©');
        } catch (e) {
          addEntry('error', 'ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ø³Ø¬Ù„: ' + (e.message || e));
        }
      });

      // override console methods
      const _log = console.log, _warn = console.warn, _error = console.error;
      console.log = function(...args) {
        try { addEntry('info', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' ')); } catch(e){}
        _log.apply(console, args);
      };
      console.warn = function(...args) {
        try { addEntry('warn', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' '), new Error().stack); } catch(e){}
        _warn.apply(console, args);
      };
      console.error = function(...args) {
        try { addEntry('error', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' '), new Error().stack); } catch(e){}
        _error.apply(console, args);
      };

      // global error handler
      window.addEventListener('error', function(ev){
        try { addEntry('error', ev.message + ' (' + ev.filename + ':' + ev.lineno + ')', ev.error && ev.error.stack ? ev.error.stack : ev.filename + ':' + ev.lineno); } catch(e){}
      });

      window.addEventListener('unhandledrejection', function(ev){
        try { addEntry('error', 'UnhandledRejection: ' + (ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason)), ev.reason && ev.reason.stack ? ev.reason.stack : ''); } catch(e){}
      });

      // Initially hidden if you prefer; keep shown for development
      // document.getElementById('debugOverlay').style.display = 'none';
    })();

    // ======= Helper UI funcs =======
    function showToast(msg, ms = 3000) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.style.display = 'block';
      clearTimeout(t._t);
      t._t = setTimeout(() => t.style.display = 'none', ms);
      // Log to debug too
      try { console.log(msg); } catch (e) {}
    }

    function cmToMm(cm) { return cm * 10; }

    function updateDimensionDisplay() {
      const widthCm = parseFloat(document.getElementById('workWidth').value) || 0;
      const heightCm = parseFloat(document.getElementById('workHeight').value) || 0;
      document.getElementById('widthMm').textContent = cmToMm(widthCm).toFixed(1) + ' Ù…Ù…';
      document.getElementById('heightMm').textContent = cmToMm(heightCm).toFixed(1) + ' Ù…Ù…';
    }

    function showElement(elementId, hidePlaceholderId) {
      const element = document.getElementById(elementId);
      const placeholder = document.getElementById(hidePlaceholderId);
      if (element && placeholder) {
        element.style.display = 'block';
        placeholder.style.display = 'none';
      }
    }

    // ========= ØªÙ†Ø¸ÙŠÙ Ù…ÙŠÙ…ÙˆØ±ÙŠ OpenCV =========
    function cleanupMats() {
      try {
        if (grayMat && !grayMat.isDeleted) { grayMat.delete(); grayMat = null; }
      } catch (e) { console.warn('cleanup grayMat', e); }

      try {
        if (contour && !contour.isDeleted && contour.delete) {
          contour.delete();
          contour = null;
        }
      } catch (e) { console.warn('cleanup contour', e); }

      try {
        additionalContours.forEach(item => {
          if (item && item.contour && !item.contour.isDeleted) {
            item.contour.delete();
          }
        });
      } catch (e) { console.warn('cleanup additionalContours', e); }
      additionalContours = [];
    }

    // ========= Ø§Ù†ØªØ¸Ø§Ø± ØªØ­Ù…ÙŠÙ„ OpenCV =========
    function waitForCv() {
      if (typeof cv !== 'undefined' && cv.getBuildInformation) {
        cvReady = true;
        document.getElementById('cvState').innerHTML = 'âœ… OpenCV Ø¬Ø§Ù‡Ø²';
        showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„ OpenCV Ø¨Ù†Ø¬Ø§Ø­', 1500);
      } else {
        setTimeout(waitForCv, 100);
      }
    }
    waitForCv();

    // ========= ØªØ¨ÙˆÙŠØ¨Ø§Øª Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© =========
    document.querySelectorAll('.tabs button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab).classList.add('active');

        if (btn.dataset.tab === 'simulation' && document.getElementById('gcodeOut').value) {
          initSimulation();
        }
      });
    });

    // ========= ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© =========
    document.getElementById('fileInput').addEventListener('change', async function (e) {
      const file = e.target.files[0];
      if (!file) return;
      if (!file.type.match('image.*')) {
        showToast('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù ØµÙˆØ±Ø© ÙÙ‚Ø·');
        return;
      }

      try {
        cleanupMats();

        // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø¹Ù†ØµØ± Image
        const img = new Image();
        img.src = URL.createObjectURL(file);
        await img.decode();

        previewCanvas = document.getElementById('canvasOriginal');
        const ctx = previewCanvas.getContext('2d');

        // ØªØ­Ø³ÙŠÙ† Ø£Ø­Ø¬Ø§Ù… Ø§Ù„ØµÙˆØ± Ø§Ù„ÙƒØ¨ÙŠØ±Ø© Ù„Ø­Ù…Ø§ÙŠØ© Ø§Ù„Ù…ØªØµÙØ­
        const maxPixels = 1024 * 1024; // 1MP
        let w = img.width, h = img.height;
        const currentPixels = w * h;
        if (currentPixels > maxPixels) {
          const ratio = Math.sqrt(maxPixels / currentPixels);
          w = Math.floor(w * ratio);
          h = Math.floor(h * ratio);
          showToast('ØªÙ… ØªØ­Ø³ÙŠÙ† Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø£ÙØ¶Ù„');
        }

        previewCanvas.width = w;
        previewCanvas.height = h;
        ctx.drawImage(img, 0, 0, w, h);

        showElement('canvasOriginal', 'originalPlaceholder');

        if (cvReady) {
          await detectContours();
        } else {
          showToast('ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± OpenCV...');
          setTimeout(async () => { if (cvReady) await detectContours(); }, 800);
        }

      } catch (error) {
        console.error('image load error', error);
        showToast('ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©');
      }
    });

    // ========= ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù ÙˆÙ…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© =========
    async function detectContours() {
      if (!cvReady) {
        showToast('OpenCV ØºÙŠØ± Ø¬Ø§Ù‡Ø² Ø¨Ø¹Ø¯');
        return;
      }

      try {
        // Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„Ù€ canvas
        const src = cv.imread(previewCanvas);

        // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø±Ù…Ø§Ø¯ÙŠ
        const gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        // ØªÙ…ÙˆÙŠÙ‡ Ù„ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¶ÙˆØ¶Ø§Ø¡
        const blurred = new cv.Mat();
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);

        // Ø­Ø³Ø§Ø¨ Ù…ØªÙˆØ³Ø· Ø§Ù„ØµÙˆØ±Ø© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ ÙƒÙ…Ø±Ø¬Ø¹ Ù„Ù„Ù€ Canny
        // === ØªØµØ­ÙŠØ­ Ù…Ù‡Ù… Ù‡Ù†Ø§ ===
        const median = cv.mean(blurred)[0];

        const lowerThreshold = Math.max(0, (1.0 - 0.33) * median);
        const upperThreshold = Math.min(255, (1.0 + 0.33) * median);

        const edges = new cv.Mat();
        cv.Canny(blurred, edges, lowerThreshold, upperThreshold);

        // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø­ÙˆØ§Ù
        const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
        cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);

        // Ø¥ÙŠØ¬Ø§Ø¯ Ø§Ù„ÙƒÙ†ØªÙˆØ±Ø§Øª
        const contours = new cv.MatVector();
        const hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

        // ØªØµÙÙŠØ© Ø§Ù„ÙƒÙ†ØªÙˆØ±Ø§Øª Ø­Ø³Ø¨ Ø§Ù„Ù…Ø³Ø§Ø­Ø© (Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ Ù„Ø§Ø­Ù‚Ø§Ù‹)
        const minArea = (gray.cols * gray.rows) * 0.01; // 1%
        const validContours = [];

        for (let i = 0; i < contours.size(); i++) {
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area > minArea) {
            validContours.push({ contour: cnt, area });
          } else {
            // Ø­Ø°Ù Ø§Ù„ÙƒÙ†ØªÙˆØ± Ø§Ù„ØµØºÙŠØ± ÙÙˆØ±Ø§Ù‹ Ù„ØªÙØ±ÙŠØº Ø§Ù„Ø°Ø§ÙƒØ±Ø©
            try { cnt.delete(); } catch (e) { /* ignore */ }
          }
        }

        if (validContours.length > 0) {
          validContours.sort((a, b) => b.area - a.area);
          // Ø§Ø­ØªÙØ¸ Ø¨Ø§Ù„Ù…Ø¤Ø´Ø± Ø§Ù„Ø£ÙƒØ¨Ø± ÙƒØ±Ø¦ÙŠØ³ÙŠØŒ ÙˆØ§Ù„Ø¨Ø§Ù‚ÙŠ Ù„Ù„ØªÙØ§ØµÙŠÙ„
          contour = validContours[0].contour;
          additionalContours = validContours.slice(1).map(v => ({ contour: v.contour, area: v.area }));
          showToast(`ØªÙ… ÙƒØ´Ù ${validContours.length} ÙƒÙˆÙ†ØªÙˆØ±`);
        } else {
          showToast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­ÙˆØ§Ù ÙˆØ§Ø¶Ø­Ø© ÙÙŠ Ø§Ù„ØµÙˆØ±Ø©');
          // ØªÙ†Ø¸ÙŠÙ
          src.delete(); blurred.delete(); edges.delete(); hierarchy.delete(); contours.delete(); kernel.delete();
          gray.delete();
          return;
        }

        // Ø­ÙØ¸ Ù†Ø³Ø®Ø© Ø±Ù…Ø§Ø¯ÙŠØ© Ù„Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù… Ù„Ø§Ø­Ù‚Ù‹Ø§
        if (grayMat) { try { grayMat.delete(); } catch (e) {} }
        grayMat = gray.clone();

        // Ø¹Ø±Ø¶ heatmap Ùˆ contour
        renderHeatmap(gray);
        renderContour(gray, contour);

        // ØªÙ†Ø¸ÙŠÙ Ù…Ø¤Ù‚Øª
        src.delete(); blurred.delete(); edges.delete(); hierarchy.delete(); kernel.delete(); contours.delete();
        // Ù†ÙØ­Ù’Ø±ÙØµ Ø¹Ù„Ù‰ Ø­Ø°Ù Ø§Ù„Ù€ gray ÙÙ‚Ø· Ø¨Ø¹Ø¯ clone (ØªÙ… Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ù†Ø³Ø®Ø©)
        gray.delete();

      } catch (error) {
        console.error('detectContours error', error);
        showToast('ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©');
      }
    }

    // ========= Ø¹Ø±Ø¶ Heatmap Ùˆ Contour =========
    function renderHeatmap(gray) {
      const heatCanvas = document.getElementById('canvasHeatmap');
      const ctx = heatCanvas.getContext('2d');
      heatCanvas.width = gray.cols;
      heatCanvas.height = gray.rows;
      const imgData = ctx.createImageData(heatCanvas.width, heatCanvas.height);
      const data = gray.data;
      for (let i = 0; i < data.length; i++) {
        const value = data[i];
        const idx = i * 4;
        // ØªØ¯Ø±Ø¬ Ø¨Ø³ÙŠØ·: Ø£Ø­Ù…Ø± / Ø£Ø²Ø±Ù‚
        imgData.data[idx] = value;           // R
        imgData.data[idx + 1] = 0;           // G
        imgData.data[idx + 2] = 255 - value; // B
        imgData.data[idx + 3] = 255;
      }
      ctx.putImageData(imgData, 0, 0);
      showElement('canvasHeatmap', 'heatmapPlaceholder');
    }

    function renderContour(gray, mainContour) {
      const contourCanvas = document.getElementById('canvasContour');
      const ctx = contourCanvas.getContext('2d');
      contourCanvas.width = gray.cols;
      contourCanvas.height = gray.rows;

      // Ø®Ù„ÙÙŠØ© Ù…Ù† heatmap
      const heatCanvas = document.getElementById('canvasHeatmap');
      ctx.drawImage(heatCanvas, 0, 0);

      // Ø±Ø³Ù… Ø§Ù„ÙƒÙ†ØªÙˆØ± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
      if (mainContour) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const data = mainContour.data32S;
        for (let i = 0; i < data.length; i += 2) {
          const x = data[i], y = data[i + 1];
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
      }

      // Ø¨Ø§Ù‚ÙŠ Ø§Ù„ÙƒÙ†ØªÙˆØ±Ø§Øª
      ctx.strokeStyle = '#ffff00';
      ctx.lineWidth = 1;
      additionalContours.forEach(ci => {
        try {
          const cnt = ci.contour;
          ctx.beginPath();
          const data = cnt.data32S;
          for (let i = 0; i < data.length; i += 2) {
            const x = data[i], y = data[i + 1];
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
          }
          ctx.closePath();
          ctx.stroke();
        } catch (e) {
          console.warn('renderContour extra error', e);
        }
      });

      showElement('canvasContour', 'contourPlaceholder');
    }

    // ========= Ø£Ø®Ø° Ø¹ÙŠÙ†Ø© Ø±Ù…Ø§Ø¯ÙŠØ© Ù…Ø¹ Ø§Ø³ØªÙŠÙØ§Ø¡ Ø«Ù†Ø§Ø¦ÙŠ =========
    function sampleGrayAt(x, y) {
      if (!grayMat) return 128;
      const gw = grayMat.cols, gh = grayMat.rows;
      const gx_f = (x / previewCanvas.width) * (gw - 1);
      const gy_f = (y / previewCanvas.height) * (gh - 1);
      const x0 = Math.floor(gx_f), y0 = Math.floor(gy_f);
      const x1 = Math.min(gw - 1, x0 + 1), y1 = Math.min(gh - 1, y0 + 1);
      const sx = gx_f - x0, sy = gy_f - y0;
      const v00 = grayMat.data[y0 * gw + x0];
      const v10 = grayMat.data[y0 * gw + x1];
      const v01 = grayMat.data[y1 * gw + x0];
      const v11 = grayMat.data[y1 * gw + x1];
      const v0 = v00 * (1 - sx) + v10 * sx;
      const v1 = v01 * (1 - sx) + v11 * sx;
      return Math.round(v0 * (1 - sy) + v1 * sy);
    }

    // ========= ØªÙˆÙ„ÙŠØ¯ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³Ø­ =========
    function addSegmentPoints(rowPoints, startX, endX, y, scaleX, scaleY, originX, originY, maxDepth, invertZ) {
      // ØªØ­Ø³ÙŠÙ† Ø¨Ø³ÙŠØ·: sampling ÙƒÙ„ 2 Ø¨ÙƒØ³Ù„ (Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„)
      for (let x = startX; x <= endX; x += 2) {
        const pv = sampleGrayAt(x, y);
        let z = -((255 - pv) / 255.0) * maxDepth;
        if (invertZ) z = -z;
        const scaledX = (x * scaleX) + originX;
        const scaledY = (y * scaleY) + originY;
        rowPoints.push({ x: scaledX, y: scaledY, z });
      }
    }

    function processRowPoints(rowPoints, lines, feed, safeZ, reverse) {
      if (reverse) rowPoints.reverse();
      // ØªØ­Ø±Ù‘Ùƒ Ø³Ø±ÙŠØ¹ Ø¥Ù„Ù‰ Ø£ÙˆÙ„ Ù†Ù‚Ø·Ø© Ø«Ù… Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªØºØ°ÙŠØ©
      lines.push('G0 X' + rowPoints[0].x.toFixed(2) + ' Y' + rowPoints[0].y.toFixed(2) + ' Z' + safeZ.toFixed(2));
      lines.push('G1 F' + feed.toFixed(0));
      for (let i = 0; i < rowPoints.length; i++) {
        const p = rowPoints[i];
        lines.push('G1 X' + p.x.toFixed(2) + ' Y' + p.y.toFixed(2) + ' Z' + p.z.toFixed(3));
      }
      lines.push('G0 Z' + safeZ.toFixed(2));
    }

    function calculateRowLength(rowPoints) {
      let length = 0;
      for (let i = 1; i < rowPoints.length; i++) {
        length += Math.hypot(rowPoints[i].x - rowPoints[i - 1].x, rowPoints[i].y - rowPoints[i - 1].y);
      }
      return length;
    }

    // ========= ØªÙˆÙ„ÙŠØ¯ G-code Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ =========
    function generateRasterGcode(scaleDown = false) {
      if (!grayMat || !contour) {
        showToast("Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©");
        return "";
      }

      try {
        const dir = document.getElementById('scanDir').value;
        lastScanDir = dir; // Ø­ÙØ¸ Ø§Ù„Ø§ØªØ¬Ø§Ù‡ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© (Ù„Ù„ØªÙ„ÙˆÙŠÙ†)
        const stepOver = parseFloat(document.getElementById('stepOver').value) || 5;
        const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
        const feed = parseFloat(document.getElementById('feedRate').value) || 800;
        const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
        const invertZ = false; // Ø§Ø­ØªÙØ¸Ù†Ø§ Ø¨Ø®ÙŠØ§Ø± ÙˆØ§Ø¬Ù‡Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠ (ÙŠÙ…ÙƒÙ† ØªÙˆØ³ÙŠØ¹Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹)

        const workWidth = cmToMm(parseFloat(document.getElementById('workWidth').value) || 30);
        const workHeight = cmToMm(parseFloat(document.getElementById('workHeight').value) || 20);
        const originX = cmToMm(parseFloat(document.getElementById('originX').value) || 0);
        const originY = cmToMm(parseFloat(document.getElementById('originY').value) || 0);

        const lines = [];
        lines.push('G21 G90 G17'); // mm, absolute, XY plane
        lines.push('G0 Z' + safeZ.toFixed(2));

        let totalLen = 0;
        const step = scaleDown ? stepOver * 4 : stepOver;
        const scaleX = workWidth / previewCanvas.width;
        const scaleY = workHeight / previewCanvas.height;

        // Ù…Ø³Ø­ Ø­Ø³Ø¨ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
        if (dir === 'x') {
          for (let y = 0; y < previewCanvas.height; y += step) {
            const rowPoints = [];
            let inContour = false;
            let segmentStart = -1;
            // ØªØ¬Ù†Ø¨ pointPolygonTest Ù„ÙƒÙ„ Ø¨ÙƒØ³Ù„: Ù†Ø³ØªØ®Ø¯Ù… sampling ÙƒÙ„ 2 Ø¨ÙƒØ³Ù„
            for (let x = 0; x < previewCanvas.width; x += 2) {
              const pt = new cv.Point(x, y);
              const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
              if (inside && !inContour) {
                segmentStart = x;
                inContour = true;
              } else if (!inside && inContour) {
                addSegmentPoints(rowPoints, segmentStart, x - 1, y, scaleX, scaleY, originX, originY, maxDepth, invertZ);
                inContour = false;
              }
            }
            if (inContour) {
              addSegmentPoints(rowPoints, segmentStart, previewCanvas.width - 1, y, scaleX, scaleY, originX, originY, maxDepth, invertZ);
            }
            if (rowPoints.length > 1) {
              processRowPoints(rowPoints, lines, feed, safeZ, (y / step) % 2 !== 0);
              totalLen += calculateRowLength(rowPoints);
            }
          }
        } else if (dir === 'y') {
          // Ù…Ø³Ø­ Ø±Ø£Ø³ÙŠ
          for (let x = 0; x < previewCanvas.width; x += step) {
            const colPoints = [];
            let inContour = false;
            let segmentStart = -1;
            for (let y = 0; y < previewCanvas.height; y += 2) {
              const pt = new cv.Point(x, y);
              const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
              if (inside && !inContour) {
                segmentStart = y;
                inContour = true;
              } else if (!inside && inContour) {
                // Ù‡Ù†Ø§ Ù†Ø¶ÙŠÙ Ù†Ù‚Ø§Ø· Ø¹Ù„Ù‰ Ø§Ù…ØªØ¯Ø§Ø¯ Ø±Ø£Ø³ÙŠ (x Ø«Ø§Ø¨ØªØŒ y Ù…ØªØºÙŠØ±)
                addSegmentPoints(colPoints, x, x, segmentStart, scaleX, scaleY, originX, originY, maxDepth, invertZ);
                inContour = false;
              }
            }
            if (inContour) {
              addSegmentPoints(colPoints, x, x, previewCanvas.height - 1, scaleX, scaleY, originX, originY, maxDepth, invertZ);
            }
            if (colPoints.length > 1) {
              processRowPoints(colPoints, lines, feed, safeZ, (x / step) % 2 !== 0);
              totalLen += calculateRowLength(colPoints);
            }
          }
        }

        lines.push('M5'); // stop spindle/laser
        lines.push('M30'); // program end

        // ØªÙ‚Ø¯ÙŠØ± ÙˆÙ‚Øª ØªÙ‚Ø±ÙŠØ¨ÙŠ Ù…Ø­Ø³Ù‘Ù† (Ø£Ø®Ø° Ø²Ù…Ø§Ù† Ø§Ù„ØªØ­Ø±ÙƒØ§Øª ÙˆØ§Ù„Ù€ safeZ ØªÙ‚Ø±ÙŠØ¨ÙŠØ§Ù‹ Ø¨Ø¹ÙŠÙ† Ø§Ù„Ø§Ø¹ØªØ¨Ø§Ø±)
        const timeMin = (totalLen / (feed || 1)) + ((Math.max(0, safeZ) / 50) * (totalLen / 1000));
        const estTimeHTML = "â±ï¸ ØªÙ‚Ø¯ÙŠØ± Ø§Ù„ÙˆÙ‚Øª: " + timeMin.toFixed(1) + " Ø¯Ù‚ÙŠÙ‚Ø©";
        document.getElementById('estTime').innerHTML = estTimeHTML;

        return lines.join('\n');
      } catch (error) {
        console.error('generateGcode error', error);
        showToast('ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ G-code');
        return "";
      }
    }

    // ========= Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… =========
    document.getElementById('btnGen').addEventListener('click', () => {
      const gcode = generateRasterGcode(false);
      document.getElementById('gcodeOut').value = gcode;
      if (gcode) {
        showToast("ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code Ø¨Ù†Ø¬Ø§Ø­");
        // Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„ØªØ¨ÙˆÙŠØ¨ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
        document.querySelector('[data-tab="simulation"]').click();
      }
    });

    document.getElementById('btnQuick').addEventListener('click', () => {
      const gcode = generateRasterGcode(true);
      document.getElementById('gcodeOut').value = gcode;
      if (gcode) {
        showToast("ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code Ø³Ø±ÙŠØ¹ Ø¨Ù†Ø¬Ø§Ø­");
        document.querySelector('[data-tab="simulation"]').click();
      }
    });

    document.getElementById('btnDownload').addEventListener('click', () => {
      const text = document.getElementById('gcodeOut').value;
      if (!text) {
        showToast("Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„ØªØ­Ù…ÙŠÙ„Ù‡");
        return;
      }
      try {
        const now = new Date();
        const dateStr = now.toISOString().slice(0, 19).replace(/[:.]/g, '-');
        const filename = `cnc_output_${dateStr}.gcode`;
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast(`ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù: ${filename}`);
      } catch (error) {
        console.error('file download error', error);
        showToast('ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù');
      }
    });

    document.getElementById('btnCenterOrigin').addEventListener('click', () => {
      const workWidth = parseFloat(document.getElementById('workWidth').value) || 0;
      const workHeight = parseFloat(document.getElementById('workHeight').value) || 0;
      document.getElementById('originX').value = (workWidth / 2).toFixed(1);
      document.getElementById('originY').value = (workHeight / 2).toFixed(1);
      showToast("ØªÙ… ØªÙˆØ³ÙŠØ· Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„");
    });

    // ======= Ù…ÙØ§ØªÙŠØ­ Ø§Ø®ØªØµØ§Ø± =======
    document.addEventListener('keydown', function (e) {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key.toLowerCase()) {
          case 'g':
            e.preventDefault();
            document.getElementById('btnGen').click();
            break;
          case 'r':
            e.preventDefault();
            document.getElementById('btnQuick').click();
            break;
          case 'd':
            e.preventDefault();
            document.getElementById('btnDownload').click();
            break;
        }
      }
    });

    // ========= Simulation 3D =========

    function parseGcodeForSimulation(gcode) {
      const lines = gcode.split('\n');
      const path = [];
      let pos = { x: 0, y: 0, z: 0 };
      for (let line of lines) {
        line = line.trim();
        if (!line) continue;
        if (line.startsWith('G0') || line.startsWith('G1')) {
          const xm = line.match(/X([-\d.]+)/i);
          const ym = line.match(/Y([-\d.]+)/i);
          const zm = line.match(/Z([-\d.]+)/i);
          if (xm) pos.x = parseFloat(xm[1]);
          if (ym) pos.y = parseFloat(ym[1]);
          if (zm) pos.z = parseFloat(zm[1]);
          path.push({ x: pos.x, y: pos.y, z: pos.z });
        }
      }
      return path;
    }

    function createToolPathVisualization(pathPoints, dir) {
      if (!pathPoints || pathPoints.length < 2) return null;
      const points = pathPoints.map(p => new THREE.Vector3(p.x / 10, -p.z, p.y / 10));
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      // Ø§Ø®ØªØ± Ø§Ù„Ù„ÙˆÙ† Ø­Ø³Ø¨ Ø§Ù„Ø§ØªØ¬Ø§Ù‡
      const color = dir === 'y' ? 0x3b82f6 : 0x10b981; // y -> blue, x -> green
      const material = new THREE.LineBasicMaterial({ color: color });
      const line = new THREE.Line(geometry, material);
      return line;
    }

    function createToolModel() {
      const group = new THREE.Group();
      const bodyGeom = new THREE.CylinderGeometry(0.5, 0.5, 6, 12);
      const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff4444 });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      body.rotation.x = Math.PI / 2;
      group.add(body);

      const tipGeom = new THREE.ConeGeometry(0.7, 2.5, 12);
      const tipMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
      const tip = new THREE.Mesh(tipGeom, tipMat);
      tip.rotation.x = Math.PI / 2;
      tip.position.z = 4;
      group.add(tip);
      group.scale.set(1.5, 1.5, 1.5);

      return group;
    }

    function addSimulationControls(container) {
      // Ø¥Ø²Ø§Ù„Ø© Ø¥Ø°Ø§ ÙˆÙØ¬Ø¯Øª
      const oldControls = container.querySelector('.simulation-controls');
      const oldInfo = container.querySelector('.simulation-info');
      if (oldControls) oldControls.remove();
      if (oldInfo) oldInfo.remove();

      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'simulation-controls';
      controlsDiv.innerHTML = `<button id="btnPlaySim">â–¶ ØªØ´ØºÙŠÙ„</button><button id="btnPauseSim">â¸ Ø¥ÙŠÙ‚Ø§Ù</button><button id="btnResetSim">â¹ Ø¥Ø¹Ø§Ø¯Ø©</button>`;
      container.appendChild(controlsDiv);

      const infoDiv = document.createElement('div');
      infoDiv.className = 'simulation-info';
      infoDiv.innerHTML = `<div>Ø§Ù„Ø­Ø§Ù„Ø©: <span id="simStatus">Ø¬Ø§Ù‡Ø²</span></div><div>Ø§Ù„ØªÙ‚Ø¯Ù…: <span id="simProgress">0%</span></div>`;
      container.appendChild(infoDiv);

      // Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
      document.getElementById('btnPlaySim').addEventListener('click', () => {
        if (!simulation.toolPath || !simulation.tool) return;
        if (!simulation.animationId) {
          simulation.isPlaying = true;
          animateToolMovement();
          document.getElementById('simStatus').textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ´ØºÙŠÙ„';
          showToast('Ø¨Ø¯Ø£Øª Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
        }
      });

      document.getElementById('btnPauseSim').addEventListener('click', () => {
        if (simulation.animationId) {
          cancelAnimationFrame(simulation.animationId);
          simulation.animationId = null;
        }
        simulation.isPlaying = false;
        document.getElementById('simStatus').textContent = 'Ù…ØªÙˆÙ‚Ù';
        showToast('ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
      });

      document.getElementById('btnResetSim').addEventListener('click', () => {
        if (simulation.animationId) {
          cancelAnimationFrame(simulation.animationId);
          simulation.animationId = null;
        }
        simulation.currentIndex = 0;
        simulation.isPlaying = false;
        if (simulation.tool) simulation.tool.position.set(0, 0, 0);
        document.getElementById('simProgress').textContent = '0%';
        document.getElementById('simStatus').textContent = 'Ø¬Ø§Ù‡Ø²';
        showToast('ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
      });
    }

    function animateToolMovement() {
      if (!simulation.toolPath || !simulation.tool) return;
      const posAttr = simulation.toolPath.geometry.attributes.position;
      const totalPoints = posAttr.count;
      function step() {
        if (simulation.currentIndex >= totalPoints) {
          // Ø§Ù†ØªÙ‡Øª
          simulation.animationId = null;
          simulation.isPlaying = false;
          document.getElementById('simStatus').textContent = 'Ù…ÙƒØªÙ…Ù„';
          showToast('Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
          return;
        }
        const ix = simulation.currentIndex;
        const x = posAttr.getX(ix);
        const y = posAttr.getY(ix);
        const z = posAttr.getZ(ix);
        simulation.tool.position.set(x, y, z);
        const progress = ((ix + 1) / totalPoints) * 100;
        document.getElementById('simProgress').textContent = progress.toFixed(1) + '%';
        simulation.currentIndex += 1;
        simulation.animationId = requestAnimationFrame(step);
      }
      if (!simulation.animationId) step();
    }

    function initSimulation() {
      const container = document.getElementById('threeContainer');

      // ØªÙ†Ø¸ÙŠÙ Ù…Ø´Ù‡Ø¯ Ø³Ø§Ø¨Ù‚
      if (renderer) {
        try {
          // Remove renderer DOM and dispose
          container.removeChild(renderer.domElement);
          renderer.dispose();
        } catch (e) { /* ignore */ }
        renderer = null;
        scene = null;
        camera = null;
        controls = null;
        simulation = { isPlaying: false, animationId: null, tool: null, toolPath: null, currentIndex: 0 };
      }

      // Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„Ù†Ø§Ø¦Ø¨
      const placeholder = document.getElementById('simulationPlaceholder');
      if (placeholder) placeholder.style.display = 'none';

      try {
        const gcode = document.getElementById('gcodeOut').value;
        if (!gcode) throw new Error('Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø©');

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x081224);

        camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 2000);
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Ø¥Ø¶Ø§Ø¡Ø©
        const ambient = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 120, 50);
        scene.add(dirLight);

        // Ø¥Ø¶Ø§ÙØ© Ø³Ø·Ø­ Ø§Ù„Ø¹Ù…Ù„ (scaled)
        const workWidth = cmToMm(parseFloat(document.getElementById('workWidth').value) || 30) / 10;
        const workHeight = cmToMm(parseFloat(document.getElementById('workHeight').value) || 20) / 10;
        const workDepth = (parseFloat(document.getElementById('workDepth').value) || 3) / 10;

        const materialGeometry = new THREE.BoxGeometry(workWidth, workDepth, workHeight);
        const materialMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513, transparent: true, opacity: 0.85 });
        const materialMesh = new THREE.Mesh(materialGeometry, materialMaterial);
        materialMesh.position.set(workWidth / 2, -workDepth / 2, workHeight / 2);
        scene.add(materialMesh);

        // ØªÙˆÙ„ÙŠØ¯ Ù…Ø³Ø§Ø± Ù…Ù† G-code
        const pathPoints = parseGcodeForSimulation(gcode);
        simulation.toolPath = createToolPathVisualization(pathPoints, lastScanDir);
        if (simulation.toolPath) scene.add(simulation.toolPath);

        // Ø¥Ø¶Ø§ÙØ© Ø£Ø¯Ø§Ø©
        simulation.tool = createToolModel();
        simulation.tool.position.set(0, 0, 0);
        scene.add(simulation.tool);

        // Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø´Ø¨ÙƒØ© ÙˆØ§Ù„Ù…Ø­Ø§ÙˆØ±
        const gridSize = Math.max(workWidth, workHeight) * 1.2;
        const gridHelper = new THREE.GridHelper(gridSize, 10);
        gridHelper.position.set(gridSize / 2, 0, gridSize / 2);
        scene.add(gridHelper);

        const axesHelper = new THREE.AxesHelper(Math.max(workWidth, workHeight) / 2 + 5);
        scene.add(axesHelper);

        // Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©
        addSimulationControls(container);

        // Render loop
        (function animate() {
          requestAnimationFrame(animate);
          if (controls) controls.update();
          if (renderer && scene && camera) renderer.render(scene, camera);
        })();

        showToast('ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø¨Ù†Ø¬Ø§Ø­');

      } catch (error) {
        console.error('initSimulation error', error);
        showToast('ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
        if (placeholder) placeholder.style.display = 'flex';
      }
    }

    // ========= ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© =========
    document.addEventListener('DOMContentLoaded', () => {
      updateDimensionDisplay();
      showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨Ù†Ø¬Ø§Ø­', 1500);

      // Ø­Ø¯Ø« ØªØºÙŠÙŠØ± Ø¹Ø±Ø¶ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
      document.getElementById('workWidth').addEventListener('input', () => setTimeout(updateDimensionDisplay, 300));
      document.getElementById('workHeight').addEventListener('input', () => setTimeout(updateDimensionDisplay, 300));

      // ØªØºÙŠÙŠØ± ÙˆØµÙ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±
      const machineDefaults = {
        router: { feed: 800, safeZ: 5, maxDepth: 3, stepOver: 5, description: "Router CNC - Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ù†Ø­Øª Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø´Ø¨ ÙˆØ§Ù„Ø£ÙƒØ±ÙŠÙ„ÙŠÙƒ ÙˆØ§Ù„Ù…Ø¹Ø§Ø¯Ù† Ø§Ù„Ù„ÙŠÙ†Ø©" },
        laser: { feed: 1200, safeZ: 0, maxDepth: 0, stepOver: 0.2, description: "Laser Engraver - Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ù†Ù‚Ø´ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø´Ø¨ ÙˆØ§Ù„Ø¬Ù„ÙˆØ¯ ÙˆØ§Ù„Ø£ÙƒØ±ÙŠÙ„ÙŠÙƒ" },
        plasma: { feed: 1500, safeZ: 3, maxDepth: 0, stepOver: 1, description: "Plasma Cutter - Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù‚Ø·Ø¹ Ø§Ù„Ù…Ø¹Ø§Ø¯Ù† Ø¨Ø³Ù…Ùƒ Ù…Ø®ØªÙ„Ù" },
        "3dprinter": { feed: 1000, safeZ: 0.2, maxDepth: 0.2, stepOver: 0.4, description: "3D Printer - Ù„Ù„Ø·Ø¨Ø§Ø¹Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ø¨ØªÙ‚Ù†ÙŠØ© FDM" }
      };
      document.getElementById('machineType').addEventListener('change', (e) => {
        const def = machineDefaults[e.target.value];
        if (def) {
          document.getElementById('feedRate').value = def.feed;
          document.getElementById('safeZ').value = def.safeZ;
          document.getElementById('maxDepth').value = def.maxDepth;
          document.getElementById('stepOver').value = def.stepOver;
          document.getElementById('machineDescription').textContent = def.description;
          showToast(`ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ${e.target.value}`);
        }
      });

    });

    // Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø­Ø¬Ù… Ø§Ù„Ù€ renderer Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ù†Ø§ÙØ°Ø©
    window.addEventListener('resize', () => {
      const container = document.getElementById('threeContainer');
      if (camera && renderer && container) {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }
    });
  </script>
</body>
</html>
