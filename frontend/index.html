<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <!-- ‚úÖ CncAi v1.0.3 Smart Debug ‚Äî Cache & CV Fix -->
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<script>
  // üîÑ Force reload bypass cache
  if(!location.search.includes('ver=')) {
    const v = '?ver=' + Date.now().toString(36);
    location.replace(location.pathname + v);
  }

  // üß† Auto CV listener - ensures debug overlay updates when OpenCV ready
  window.onOpenCvReady = function() {
    console.log('[CncAi] OpenCV ready signal received');
    try {
      if(window.updateCvState) updateCvState();
      if(window.appendDebug) appendDebug('OpenCV fully initialized');
      if(window.showToast) showToast('‚úÖ OpenCV ready',2000);
    } catch(e) { console.warn('CV listener error', e); }
  };
</script>
<!-- ‚úÖ End Fix -->
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>CNC AI ‚Äî CNC Router & Laser Engraving</title>

  
  <!-- ŸÖŸÉÿ™ÿ®ÿßÿ™ -->
  <script src="https://docs.opencv.org/4.8.0/opencv.js" async></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: Arial, Segoe UI, system-ui; background: #041022; color:#e6eef6; line-height:1.45 }
    .app { max-width:1400px; margin:12px auto; padding:14px }
    header { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #1e293b }
    .grid { display:grid; grid-template-columns:1fr 520px; gap:16px }
    @media (max-width:1100px){ .grid{ grid-template-columns:1fr } }
    .panel { background:#0b1320; padding:16px; border-radius:10px; border:1px solid #1e293b }
    /* tabs improved */
    .tab-buttons { display:flex; gap:8px; margin-top:12px; background: rgba(14,23,33,0.6); padding:6px; border-radius:8px }
    .tab-buttons button { flex:1; border:none; padding:8px 10px; border-radius:6px; background:transparent; color:#9bb0c8; cursor:pointer }
    .tab-buttons button.active { background:#0f172a; color:#e6eef6; box-shadow: inset 0 -3px 0 #06b6d4; }
    .tab-content { display:none; margin-top:12px }
    .tab-content.active { display:block }
    canvas { max-width:100%; border-radius:6px; background:#000; display:block; margin:0 auto; border:1px solid #334155 }
    #threeContainer { width:100%; height:420px; background:#081224; border-radius:8px; overflow:hidden; position:relative }
    label { display:block; margin-top:12px; color:#cfeaf2; font-weight:bold }
    input, select, textarea, button { font-size:0.9rem }
    input, select { width:100%; padding:8px 10px; border-radius:6px; border:1px solid #1e293b; background:#0f172a; color:#e6eef6; margin-top:6px }
    .button-group { display:flex; flex-direction:column; gap:8px; margin-top:12px }
    .button-row { display:flex; gap:8px; }
    button { background:#1e293b; color:#e6eef6; border:none; padding:10px; border-radius:8px; cursor:pointer }
    button.primary { background:#06b6d4; color:#021; font-weight:bold }
    button.secondary { background:#334155; }
    #toast { position:fixed; left:16px; bottom:16px; background:rgba(0,0,0,0.85); color:#fff; padding:10px 14px; border-radius:8px; display:none; z-index:10000 }
    .canvas-placeholder { width:100%; min-height:260px; background:#000; border-radius:6px; display:flex; align-items:center; justify-content:center; color:#9bb0c8; border:1px solid #334155 }
    .small-meta { font-size:12px; color:#9bb0c8; margin-top:6px }

    /* Debug overlay */
    #debugOverlay {
      position: fixed;
      right: 16px;
      bottom: 16px;
      width: 420px;
      max-height: 55vh;
      background: rgba(2,6,23,0.9);
      color: #e6eef6;
      border: 1px solid rgba(102, 126, 234, 0.08);
      border-radius: 8px;
      font-size: 13px;
      z-index: 20000;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 8px 40px rgba(0,0,0,0.6);
    }
    #debugOverlay.minimized { height: 36px; width: 160px; cursor: pointer; }
    #debugHeader {
      display:flex; align-items:center; justify-content:space-between; padding:8px 10px; border-bottom:1px solid rgba(255,255,255,0.03);
      background: linear-gradient(90deg, rgba(6,182,212,0.06), rgba(8,145,178,0.02));
    }
    #debugHeader b { color:#aee8f2; }
    #debugControls { display:flex; gap:6px; align-items:center; }
    .dbg-btn { background:transparent; border:1px solid rgba(255,255,255,0.06); color:#cfeaf2; padding:6px 8px; border-radius:6px; cursor:pointer; font-size:12px; }
    #debugList { overflow:auto; padding:8px; display:flex; flex-direction:column; gap:6px; }
    .dbg-item { padding:8px; border-radius:6px; background:rgba(255,255,255,0.02); line-height:1.2; max-height:120px; overflow:auto; font-family:monospace; font-size:12px; }
    .dbg-time { opacity:0.7; font-size:11px; margin-bottom:6px; display:block; }
    .dbg-error { border-left:4px solid #ef4444; }
    .dbg-warn { border-left:4px solid #f59e0b; }
    .dbg-info { border-left:4px solid #06b6d4; color:#cfeaf2; }
    .dbg-meta { opacity:0.75; font-size:11px; margin-top:6px; color:#9bb0c8; }
    #debugFooter { padding:6px 10px; border-top:1px solid rgba(255,255,255,0.02); text-align:right; font-size:12px; color:#9bb0c8; background:rgba(0,0,0,0.03); display:flex; justify-content:space-between; align-items:center; }

    /* Simulation controls */
    .sim-controls { position:absolute; top:10px; left:10px; z-index:120; display:flex; gap:8px; align-items:center; background:rgba(0,0,0,0.35); padding:6px;border-radius:6px }
    .sim-controls button { background:rgba(0,0,0,0.55); color:white; border:1px solid #06b6d4; border-radius:4px; padding:6px 8px; cursor:pointer; font-size:0.9rem }
    .sim-progress { position:absolute; bottom:10px; left:10px; z-index:120; background:rgba(0,0,0,0.35); padding:6px 8px;border-radius:6px; color:#cfeaf2; font-size:12px }

    /* Top view + legend */
    #topViewContainer { margin-top:12px; display:flex; flex-direction:column; gap:6px; align-items:center; }
    #topView { width:100%; height:200px; background:#0d1722; border-radius:6px; border:1px solid #334155; display:block }
    #topLegend { width:100%; height:18px; border-radius:6px; border:1px solid #2b3844; background:linear-gradient(90deg,#ddd,#333); }

    /* colormap buttons */
    .colormap-section {
      margin: 16px 0;
      padding: 16px;
      background: rgba(14, 23, 33, 0.8);
      border-radius: 10px;
      border: 1px solid #334155;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    .colormap-title {
      text-align: center;
      margin-bottom: 12px;
      color: #cfeaf2;
      font-weight: bold;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .colormap-buttons { display:flex; gap:8px; justify-content:center; margin-top:8px; flex-wrap:wrap; }
    .colormap-buttons button {
      background:#141b22; color:#cfeaf2; border:1px solid #26343f; padding:10px 16px; border-radius:8px; 
      cursor:pointer; font-size:14px; font-weight:bold; transition:all 0.3s ease; min-width:80px;
    }
    .colormap-buttons button:hover { background:#1e293b; border-color:#06b6d4; transform:translateY(-2px); }
    .colormap-buttons button.active { background:#06b6d4; color:#021; border-color:#06b6d4; box-shadow:0 4px 12px rgba(6,182,212,0.3); }

    /* Machine category styles */
    .machine-settings { transition: all 0.3s ease; }
    .laser-specific { border-left: 3px solid #ff4444; padding-left: 10px; margin: 8px 0; background: rgba(255, 0, 0, 0.05); }
    .router-specific { border-left: 3px solid #06b6d4; padding-left: 10px; margin: 8px 0; background: rgba(6, 182, 212, 0.05); }
    .laser-edge-settings {
      border: 1px solid #ff4444;
      border-radius: 6px;
      padding: 10px;
      margin: 8px 0;
      background: rgba(255, 68, 68, 0.05);
    }
    .laser-mode-description {
      font-size: 11px;
      color: #9bb0c8;
      margin-top: 4px;
      line-height: 1.3;
    }

    /* Progress indicator */
    .progress-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 30000;
      flex-direction: column;
      gap: 16px;
    }
    .progress-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #06b6d4;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    .progress-text {
      color: white;
      font-size: 16px;
    }

    @keyframes spin { 0%{transform:rotate(0)}100%{transform:rotate(360deg)} }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>CNC AI ‚Äî CNC Router & Laser Engraving</h1>
      <div id="cvState">
        <span class="loading" style="display:inline-block;width:16px;height:16px;border:3px solid #f3f3f3;border-top:3px solid #06b6d4;border-radius:50%;animation:spin 1s linear infinite;margin-left:8px;"></span>
        ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ OpenCV...
      </div>
    </header>

    <div class="grid">
      <!-- LEFT panel -->
      <div class="panel">
        <div style="display:flex;gap:8px;align-items:center;">
          <input id="fileInput" type="file" accept="image/*"/>
          <label class="file-input-label" for="fileInput" style="display:inline-block;padding:8px 12px;background:#1e293b;border-radius:6px;color:#e6eef6;cursor:pointer;border:1px dashed #334155">üìÅ ÿßÿÆÿ™ÿ± ÿµŸàÿ±ÿ©</label>
          <div style="flex:1"></div>

          <label for="edgeMode" style="font-weight:normal;color:#9bb0c8">Edge Mode:</label>
          <select id="edgeMode" style="width:140px">
            <option value="auto">Canny (ÿπÿßÿØŸä)</option>
            <option value="sobel">Sobel (ÿØŸÇŸäŸÇ)</option>
            <option value="laplace">Laplacian (ŸÜÿßÿπŸÄŸÖ)</option>
          </select>
        </div>

        <!-- Edge sensitivity slider -->
        <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
          <label style="margin:0;color:#9bb0c8">ÿ≠ÿ≥ÿßÿ≥Ÿäÿ© ÿßŸÑÿ≠ŸàÿßŸÅ:</label>
          <input id="edgeSensitivity" type="range" min="0.1" max="1.0" step="0.05" value="0.33" style="flex:1">
          <div id="edgeValue" style="min-width:44px;text-align:center;color:#cfeaf2">0.33</div>
        </div>

        <!-- ========== ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑŸÄ Colormap ÿßŸÑÿ´ÿßÿ®ÿ™ÿ© ========== -->
        <div class="colormap-section">
          <div class="colormap-title">
            <span>üé®</span>
            ÿÆŸäÿßÿ±ÿßÿ™ ÿ™ÿØÿ±ÿ¨ ÿßŸÑÿ£ŸÑŸàÿßŸÜ
            <span>üé®</span>
          </div>
          <div class="colormap-buttons" id="colormapButtons">
            <button data-map="jet" class="active" title="Jet - ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿ•ŸÑŸâ ÿßŸÑÿ£ÿ≠ŸÖÿ±">
              <div style="display:flex;flex-direction:column;align-items:center;gap:4px">
                <div>Jet</div>
                <div style="width:100%;height:4px;background:linear-gradient(90deg,#0000ff,#00ffff,#ffff00,#ff0000);border-radius:2px"></div>
              </div>
            </button>
            <button data-map="hot" title="Hot - ÿßŸÑÿ£ÿ≥ŸàÿØ ÿ•ŸÑŸâ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿ•ŸÑŸâ ÿßŸÑÿ£ÿµŸÅÿ±">
              <div style="display:flex;flex-direction:column;align-items:center;gap:4px">
                <div>Hot</div>
                <div style="width:100%;height:4px;background:linear-gradient(90deg,#000000,#ff0000,#ffff00,#ffffff);border-radius:2px"></div>
              </div>
            </button>
            <button data-map="cool" title="Cool - ÿßŸÑÿ≥ŸÖÿßŸàŸä ÿ•ŸÑŸâ ÿßŸÑÿ£ÿ±ÿ¨ŸàÿßŸÜŸä">
              <div style="display:flex;flex-direction:column;align-items:center;gap:4px">
                <div>Cool</div>
                <div style="width:100%;height:4px;background:linear-gradient(90deg,#00ffff,#ff00ff);border-radius:2px"></div>
              </div>
            </button>
            <button data-map="gray" title="Gray - ÿßŸÑÿ™ÿØÿ±ÿ¨ ÿßŸÑÿ±ŸÖÿßÿØŸä">
              <div style="display:flex;flex-direction:column;align-items:center;gap:4px">
                <div>Gray</div>
                <div style="width:100%;height:4px;background:linear-gradient(90deg,#000000,#ffffff);border-radius:2px"></div>
              </div>
            </button>
          </div>
          <div class="small-meta" style="text-align: center; margin-top: 8px;">
            ÿßŸÑÿ™ÿ∫ŸäŸäÿ± Ÿäÿ∑ÿ®ŸÇ ÿπŸÑŸâ: Heatmap ‚Ä¢ Top View ‚Ä¢ Contours ‚Ä¢ ŸÉŸÑ ÿßŸÑŸÖÿπÿßŸäŸÜÿßÿ™
          </div>
        </div>

        <div class="tab-buttons" role="tablist">
          <button data-tab="original" class="active">üñºÔ∏è ÿßŸÑÿ£ÿµŸÑŸäÿ©</button>
          <button data-tab="heatmap">üî• Heatmap</button>
          <button data-tab="contour">üìê Contours</button>
          <button data-tab="topview">üîù Top View</button>
          <button data-tab="simulation">üé¨ ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ©</button>
        </div>

        <div id="original" class="tab-content active">
          <div class="canvas-placeholder" id="originalPlaceholder">ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑÿ£ÿµŸÑŸäÿ© ÿ≥ÿ™ÿ∏Ÿáÿ± ŸáŸÜÿß</div>
          <canvas id="canvasOriginal" style="display:none;"></canvas>
        </div>

        <div id="heatmap" class="tab-content">
          <div class="canvas-placeholder" id="heatmapPlaceholder">Heatmap ÿ≥ÿ™ÿ∏Ÿáÿ± ŸáŸÜÿß</div>
          <canvas id="canvasHeatmap" style="display:none;"></canvas>
        </div>

        <div id="contour" class="tab-content">
          <div class="canvas-placeholder" id="contourPlaceholder">Contours ÿ≥ÿ™ÿ∏Ÿáÿ± ŸáŸÜÿß</div>
          <canvas id="canvasContour" style="display:none;"></canvas>
          <div class="small-meta">ÿ™ÿ®ÿØŸäŸÑ Ÿàÿ∂ÿπ ŸÉÿ¥ŸÅ ÿßŸÑÿ≠ŸàÿßŸÅ ÿ£Ÿà ÿ™ÿ≠ÿ±ŸäŸÉ ÿ≠ÿ≥ÿßÿ≥Ÿäÿ© ÿßŸÑÿ≠ŸàÿßŸÅ Ÿäÿ≠ÿØÿ´ ÿ•ÿπÿßÿØÿ© ŸÖÿπÿßŸÑÿ¨ÿ© ÿ™ŸÑŸÇÿßÿ¶Ÿäÿ©</div>
        </div>

        <div id="topview" class="tab-content">
          <div id="topViewContainer">
            <canvas id="topView"></canvas>
            <div id="topLegend" title="ÿπŸÖŸÇ ÿßŸÑŸÜŸÇÿ¥ ‚Äî ÿßŸÑÿ£ŸÑŸàÿßŸÜ ŸÅŸÇÿ∑"></div>
          </div>
          <div class="small-meta">ŸÖÿπÿßŸäŸÜÿ© ŸÖŸÜ ÿßŸÑÿ£ÿπŸÑŸâ ŸÑŸÑÿπŸÖŸÇ ÿßŸÑŸÖÿ™ŸàŸÇÿπ ÿ®ÿπÿØ ÿ™ŸÜŸÅŸäÿ∞ G-code (ÿßŸÑÿ£ŸÑŸàÿßŸÜ ÿ™ÿ™ÿ®ÿπ ÿßÿÆÿ™Ÿäÿßÿ± Colormap)</div>
        </div>

        <div id="simulation" class="tab-content">
          <div id="threeContainer">
            <div class="canvas-placeholder" id="simulationPlaceholder">ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ© ÿ≥ÿ™ÿ∏Ÿáÿ± ŸáŸÜÿß ÿ®ÿπÿØ ÿ™ŸàŸÑŸäÿØ G-code</div>
          </div>
        </div>
      </div>

      <!-- RIGHT panel -->
      <div class="panel">
        <h3>‚öôÔ∏è ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÖÿßŸÉŸäŸÜÿ©</h3>

        <!-- Machine Category Selection -->
        <label for="machineCategory">ŸÜŸàÿπ ÿßŸÑŸÖÿßŸÉŸäŸÜÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿä</label>
        <select id="machineCategory">
          <option value="router">CNC Router (ŸÜÿ≠ÿ™ ÿÆÿ¥ÿ®)</option>
          <option value="laser">Laser Engraver (ŸÜŸÇÿ¥ ŸÑŸäÿ≤ÿ±)</option>
        </select>

        <!-- CNC Router Settings -->
        <div id="routerSettings" class="machine-settings">
          <h4 class="router-specific">üîÑ ÿ•ÿπÿØÿßÿØÿßÿ™ CNC Router</h4>
          
          <label for="workWidth">ÿπÿ±ÿ∂ ÿßŸÑÿπŸÖŸÑ (ÿ≥ŸÖ)</label>
          <input id="workWidth" type="number" value="30" step="0.1" min="1" max="200"/>
          <div class="small-meta" id="widthMm">300.0 ŸÖŸÖ</div>

          <label for="workHeight">ÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿπŸÖŸÑ (ÿ≥ŸÖ)</label>
          <input id="workHeight" type="number" value="20" step="0.1" min="1" max="200"/>
          <div class="small-meta" id="heightMm">200.0 ŸÖŸÖ</div>

          <label for="workDepth">ÿπŸÖŸÇ ÿßŸÑÿπŸÖŸÑ (ŸÖŸÖ)</label>
          <input id="workDepth" type="number" value="3.0" step="0.1" min="0.1" max="50"/>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
            <div>
              <label for="originX">ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ£ÿµŸÑ X (ÿ≥ŸÖ)</label>
              <input id="originX" type="number" value="0" step="0.1"/>
            </div>
            <div>
              <label for="originY">ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ£ÿµŸÑ Y (ÿ≥ŸÖ)</label>
              <input id="originY" type="number" value="0" step="0.1"/>
            </div>
          </div>
          <div style="margin-top:6px"><button id="btnCenterOrigin" class="secondary">üéØ ÿ™Ÿàÿ≥Ÿäÿ∑ ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ£ÿµŸÑ</button></div>

          <hr style="border-color:#122433;margin:12px 0"/>

          <label for="feedRate">ÿ≥ÿ±ÿπÿ© ÿßŸÑÿ™ÿ∫ÿ∞Ÿäÿ© (ŸÖŸÖ/ÿØŸÇŸäŸÇÿ©)</label>
          <input id="feedRate" type="number" value="800" min="10" max="5000"/>
          <label for="safeZ">ÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿ£ŸÖÿßŸÜ (ŸÖŸÖ)</label>
          <input id="safeZ" type="number" value="5" step="0.1" min="0" max="100"/>

          <label for="scanDir">ÿßÿ™ÿ¨ÿßŸá ÿßŸÑŸÖÿ≥ÿßÿ±ÿßÿ™ (Raster)</label>
          <select id="scanDir">
            <option value="x">ÿ£ŸÅŸÇŸä (X)</option>
            <option value="y">ÿ±ÿ£ÿ≥Ÿä (Y)</option>
          </select>

          <label for="stepOver">ÿÆÿ∑Ÿàÿ© ÿßŸÑŸÖÿ≥ÿ≠ (ŸÖŸÖ)</label>
          <input id="stepOver" type="number" value="5" step="0.1" min="0.1" max="50"/>
          <label for="maxDepth">ÿ£ŸÇÿµŸâ ÿπŸÖŸÇ (ŸÖŸÖ)</label>
          <input id="maxDepth" type="number" value="3.0" step="0.1" min="0.1" max="50"/>

          <!-- Fixed Z + Invert Z -->
          <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
            <label style="font-weight:normal;"><input id="fixedZ" type="checkbox" /> ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Z ÿ´ÿßÿ®ÿ™</label>
            <input id="fixedZValue" type="number" value="-1.0" step="0.1" style="width:120px" />
          </div>
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <label style="font-weight:normal;"><input id="invertZ" type="checkbox" /> ÿπŸÉÿ≥ Z</label>
            <div style="flex:1"></div>
            <label style="font-weight:normal;color:#9bb0c8">ŸÑŸàŸÜ ÿßŸÑÿÆÿ¥ÿ®:</label>
            <select id="woodColor" style="width:140px">
              <option value="#deb887">ÿÆÿ¥ÿ® ŸÅÿßÿ™ÿ≠</option>
              <option value="#a0522d" selected>ÿÆÿ¥ÿ® ŸÖÿ™Ÿàÿ≥ÿ∑</option>
              <option value="#d2b48c">ÿ®Ÿäÿ¨</option>
              <option value="#8b5a2b">ŸÖÿßŸáŸàÿ¨ŸÜŸä</option>
            </select>
          </div>

          <div class="button-group">
            <div class="button-row">
              <button id="btnGen" class="primary">‚ö° ÿ™ŸàŸÑŸäÿØ G-code (Raster)</button>
              <button id="btnQuick" class="secondary">üß™ ÿßÿÆÿ™ÿ®ÿßÿ± ÿ≥ÿ±Ÿäÿπ</button>
            </div>

            <div style="margin-top:8px">
              <label for="contourMode">ŸÜÿ∑ÿßŸÇ ÿßŸÑÿ≠ŸàÿßŸÅ (Contour)</label>
              <select id="contourMode">
                <option value="outer">ÿßŸÑÿÆÿßÿ±ÿ¨Ÿäÿ© ŸÅŸÇÿ∑</option>
                <option value="all">ŸÉŸÑ ÿßŸÑÿ≠ŸàÿßŸÅ</option>
              </select>
              <div style="height:8px"></div>
              <div class="button-row">
                <button id="btnContour" class="secondary">üåÄ ÿ™ŸàŸÑŸäÿØ G-code (Contour)</button>
                <button id="btnDownload" class="secondary">üíæ ÿ™ÿ≠ŸÖŸäŸÑ G-code</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Laser Engraver Settings -->
        <div id="laserSettings" class="machine-settings" style="display:none;">
          <h4 class="laser-specific">‚ö° ÿ•ÿπÿØÿßÿØÿßÿ™ Laser Engraver</h4>
          
          <label for="laserWorkWidth">ÿπÿ±ÿ∂ ÿßŸÑÿπŸÖŸÑ (ÿ≥ŸÖ)</label>
          <input id="laserWorkWidth" type="number" value="30" step="0.1" min="1" max="200"/>
          <div class="small-meta" id="laserWidthMm">300.0 ŸÖŸÖ</div>

          <label for="laserWorkHeight">ÿßÿ±ÿ™ŸÅÿßÿπ ÿßŸÑÿπŸÖŸÑ (ÿ≥ŸÖ)</label>
          <input id="laserWorkHeight" type="number" value="20" step="0.1" min="1" max="200"/>
          <div class="small-meta" id="laserHeightMm">200.0 ŸÖŸÖ</div>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
            <div>
              <label for="laserOriginX">ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ£ÿµŸÑ X (ÿ≥ŸÖ)</label>
              <input id="laserOriginX" type="number" value="0" step="0.1"/>
            </div>
            <div>
              <label for="laserOriginY">ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ£ÿµŸÑ Y (ÿ≥ŸÖ)</label>
              <input id="laserOriginY" type="number" value="0" step="0.1"/>
            </div>
          </div>
          <div style="margin-top:6px"><button id="btnLaserCenterOrigin" class="secondary">üéØ ÿ™Ÿàÿ≥Ÿäÿ∑ ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ£ÿµŸÑ</button></div>

          <!-- Laser Edge Detection Settings -->
          <div class="laser-edge-settings">
            <label for="laserEdgeMode">ŸÜŸÖÿ∑ ŸÉÿ¥ŸÅ ÿßŸÑÿ≠ŸàÿßŸÅ ŸÑŸÑŸÑŸäÿ≤ÿ±</label>
            <select id="laserEdgeMode">
              <option value="canny">Canny (ÿπÿßÿØŸä)</option>
              <option value="adaptive">Adaptive Threshold (ŸÑŸÑŸÜŸÇÿ¥)</option>
              <option value="morphological">Morphological (ŸÑŸÑÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿØŸÇŸäŸÇÿ©)</option>
              <option value="gradient">Gradient-Based (ŸÑŸÑÿ™ÿØÿ±ÿ¨ÿßÿ™)</option>
            </select>
            <div class="laser-mode-description" id="laserModeDesc">
              Adaptive Threshold - ŸÖŸÖÿ™ÿßÿ≤ ŸÑŸÑÿµŸàÿ± ÿ∞ÿßÿ™ ÿßŸÑÿ•ÿ∂ÿßÿ°ÿ© ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ™ÿ¨ÿßŸÜÿ≥ÿ©
            </div>

            <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
              <label style="margin:0;color:#9bb0c8">ÿØŸÇÿ© ÿßŸÑŸÑŸäÿ≤ÿ±:</label>
              <input id="laserDetail" type="range" min="1" max="10" value="5" step="1" style="flex:1">
              <div id="laserDetailValue" style="min-width:44px;text-align:center;color:#ff4444">5</div>
            </div>
          </div>

          <div style="margin-top: 8px;">
            <button id="btnRedetectLaser" class="secondary">üîÑ ÿ•ÿπÿßÿØÿ© ŸÉÿ¥ŸÅ ÿ≠ŸàÿßŸÅ ÿßŸÑŸÑŸäÿ≤ÿ±</button>
          </div>

          <hr style="border-color:#ff4444;margin:12px 0"/>

          <!-- Laser Power -->
          <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
            <label style="margin:0;color:#9bb0c8">ŸÇŸàÿ© ÿßŸÑŸÑŸäÿ≤ÿ±:</label>
            <input id="laserPower" type="range" min="0" max="100" value="80" step="1" style="flex:1">
            <div id="laserPowerValue" style="min-width:44px;text-align:center;color:#ff4444">80%</div>
          </div>

          <label for="laserMode">Ÿàÿ∂ÿπ ÿßŸÑŸÑŸäÿ≤ÿ±</label>
          <select id="laserMode">
            <option value="engrave">ŸÜŸÇÿ¥ (Grayscale)</option>
            <option value="cut">ŸÇÿµ (Contour)</option>
            <option value="combine">ŸÜŸÇÿ¥ + ŸÇÿµ</option>
          </select>

          <label for="laserSpeed">ÿ≥ÿ±ÿπÿ© ÿßŸÑŸÑŸäÿ≤ÿ± (ŸÖŸÖ/ÿØŸÇŸäŸÇÿ©)</label>
          <input id="laserSpeed" type="number" value="2000" min="100" max="10000"/>

          <label for="laserPasses">ÿπÿØÿØ ÿßŸÑŸÖÿ±ÿßÿ™</label>
          <input id="laserPasses" type="number" value="1" min="1" max="10"/>

          <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
            <label style="font-weight:normal;">
              <input id="laserDynamic" type="checkbox" checked /> 
              ŸÇŸàÿ© ÿØŸäŸÜÿßŸÖŸäŸÉŸäÿ© (ÿ≠ÿ≥ÿ® ÿßŸÑÿ∏ŸÑÿßŸÖ)
            </label>
          </div>

          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <label style="font-weight:normal;">
              <input id="laserAirAssist" type="checkbox" /> 
              Air Assist
            </label>
          </div>

          <!-- Laser Buttons -->
          <div class="button-group">
            <div class="button-row">
              <button id="btnLaserEngrave" class="primary" style="background:#ff4444; display:none;">‚ö° ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ŸÑŸäÿ≤ÿ± (ŸÜŸÇÿ¥)</button>
              <button id="btnLaserQuick" class="secondary" style="display:none;">üß™ ŸÜŸÇÿ¥ ÿ≥ÿ±Ÿäÿπ</button>
            </div>
            <div class="button-row">
              <button id="btnLaserCut" class="secondary" style="display:none;">‚úÇÔ∏è ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ŸÑŸäÿ≤ÿ± (ŸÇÿµ)</button>
              <button id="btnLaserDownload" class="secondary" style="display:none;">üíæ ÿ™ÿ≠ŸÖŸäŸÑ ŸÉŸàÿØ ÿßŸÑŸÑŸäÿ≤ÿ±</button>
            </div>
          </div>
        </div>

        <div id="estTime" style="margin-top:12px;color:#9bb0c8;text-align:center;padding:8px;background:#0f172a;border-radius:6px"></div>

        <label for="gcodeOut" style="margin-top:12px">üìÑ ŸÖÿÆÿ±ÿ¨ÿßÿ™ G-code</label>
        <textarea id="gcodeOut" readonly placeholder="ÿ≥Ÿäÿ∏Ÿáÿ± G-code ŸáŸÜÿß ÿ®ÿπÿØ ÿßŸÑÿ™ŸàŸÑŸäÿØ..." style="height:180px;background:#021024;color:#cfeaf2;border-radius:8px;padding:10px;"></textarea>

      </div>
    </div>
  </div>

  <!-- Progress Overlay -->
  <div class="progress-overlay" id="progressOverlay">
    <div class="progress-spinner"></div>
    <div class="progress-text" id="progressText">ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©...</div>
  </div>

  <!-- Debug Overlay -->
  <div id="debugOverlay" aria-live="polite" role="status">
    <div id="debugHeader">
      <div><b>Debug</b> ‚Äî Console</div>
      <div id="debugControls">
        <button id="dbgToggleSize" class="dbg-btn" title="ÿ™ÿµÿ∫Ÿäÿ±/ÿ™ŸÉÿ®Ÿäÿ±">üîΩ</button>
        <button id="dbgCopy" class="dbg-btn" title="ŸÜÿ≥ÿÆ ÿßŸÑÿ≥ÿ¨ŸÑ">üìã ŸÜÿ≥ÿÆ</button>
        <button id="dbgClear" class="dbg-btn" title="ŸÖÿ≥ÿ≠ ÿßŸÑÿ≥ÿ¨ŸÑ">üßπ ŸÖÿ≥ÿ≠</button>
      </div>
    </div>
    <div id="debugList"></div>
    <div id="debugFooter">
      <div id="debugSummary">0 ÿ≥ÿ¨ŸÑÿßÿ™</div>
      <div style="flex:1"></div>
      <div style="font-size:12px;color:#9bb0c8">ÿßŸÜŸÇÿ± ÿßŸÑÿ™ÿµÿ∫Ÿäÿ± ŸÑÿ≠ŸÅÿ∏ ÿßŸÑÿ¥ÿßÿ¥ÿ©</div>
    </div>
  </div>

  <div id="toast"></div>

  <script>
    // ================= ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿπÿßŸÖÿ© =================
    let cvReady = false;
    let grayMat = null;
    let contour = null;
    let previewCanvas = null;
    let additionalContours = []; // {contour, area}
    let lastScanDir = 'x';
    let lastGeneratedGcode = '';
    let isProcessing = false; // ŸÖŸÜÿπ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑŸÖÿ≤ÿØŸàÿ¨ÿ©

    // colormap current
    let currentColormap = 'jet';

    // Simulation / Three
    let scene, camera, renderer, controls;
    let simulation = { isPlaying: false, animationFrame: null, tool: null, toolPath: null, pathPoints: [], index: 0, speed: 1 };

    // ================= ŸÜÿ∏ÿßŸÖ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖŸáÿßŸÖ =================
    class TaskManager {
      constructor() {
        this.queue = [];
        this.isRunning = false;
      }

      async addTask(taskFn, description = 'ŸÖŸáŸÖÿ©') {
        return new Promise((resolve, reject) => {
          this.queue.push({ taskFn, description, resolve, reject });
          if (!this.isRunning) {
            this.processQueue();
          }
        });
      }

      async processQueue() {
        if (this.queue.length === 0) {
          this.isRunning = false;
          return;
        }

        this.isRunning = true;
        const task = this.queue.shift();

        try {
          showProgress(task.description);
          const result = await task.taskFn();
          task.resolve(result);
        } catch (error) {
          console.error(`ŸÅÿ¥ŸÑ ŸÅŸä ${task.description}:`, error);
          showToast(`ŸÅÿ¥ŸÑ ŸÅŸä ${task.description}: ${error.message}`);
          task.reject(error);
        } finally {
          hideProgress();
          this.processQueue();
        }
      }

      clear() {
        this.queue = [];
        this.isRunning = false;
      }
    }

    const taskManager = new TaskManager();

    // ================= ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ŸÇÿØŸÖ =================
    function showProgress(message = 'ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©...') {
      document.getElementById('progressText').textContent = message;
      document.getElementById('progressOverlay').style.display = 'flex';
    }

    function hideProgress() {
      document.getElementById('progressOverlay').style.display = 'none';
    }

    // ================= ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿµÿ≠ÿ© =================
    class InputValidator {
      static validateNumberInput(inputId, min, max) {
        const input = document.getElementById(inputId);
        const value = parseFloat(input.value);
        
        if (isNaN(value)) {
          showToast(`ÿßŸÑŸÇŸäŸÖÿ© ŸÅŸä ${inputId} ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ©`);
          input.value = min;
          return min;
        }
        
        if (value < min) {
          showToast(`ÿßŸÑŸÇŸäŸÖÿ© ŸÅŸä ${inputId} ÿ£ŸÇŸÑ ŸÖŸÜ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ (${min})`);
          input.value = min;
          return min;
        }
        
        if (value > max) {
          showToast(`ÿßŸÑŸÇŸäŸÖÿ© ŸÅŸä ${inputId} ÿ£ŸÉÿ®ÿ± ŸÖŸÜ ÿßŸÑŸÖÿ≥ŸÖŸàÿ≠ (${max})`);
          input.value = max;
          return max;
        }
        
        return value;
      }

      static validateImageSize(canvas) {
        const maxPixels = 4000000; // 4MP ŸÑŸÑÿ≠ÿØ ŸÖŸÜ ÿßÿ≥ÿ™ŸáŸÑÿßŸÉ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©
        const currentPixels = canvas.width * canvas.height;
        
        if (currentPixels > maxPixels) {
          const ratio = Math.sqrt(maxPixels / currentPixels);
          const newWidth = Math.floor(canvas.width * ratio);
          const newHeight = Math.floor(canvas.height * ratio);
          
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = newWidth;
          tempCanvas.height = newHeight;
          tempCtx.drawImage(canvas, 0, 0, newWidth, newHeight);
          
          const ctx = canvas.getContext('2d');
          canvas.width = newWidth;
          canvas.height = newHeight;
          ctx.drawImage(tempCanvas, 0, 0);
          
          showToast('ÿ™ŸÖ ÿ™ŸÇŸÑŸäŸÑ ÿ≠ÿ¨ŸÖ ÿßŸÑÿµŸàÿ±ÿ© ŸÑŸÑÿ£ÿØÿßÿ° ÿßŸÑÿ£ŸÅÿ∂ŸÑ');
          return true;
        }
        return false;
      }

      static validateLaserSettings() {
        const power = this.validateNumberInput('laserPower', 0, 100);
        const speed = this.validateNumberInput('laserSpeed', 100, 10000);
        const passes = this.validateNumberInput('laserPasses', 1, 10);
        
        return { power, speed, passes };
      }

      static validateRouterSettings() {
        const feedRate = this.validateNumberInput('feedRate', 10, 5000);
        const safeZ = this.validateNumberInput('safeZ', 0, 100);
        const maxDepth = this.validateNumberInput('maxDepth', 0.1, 50);
        const stepOver = this.validateNumberInput('stepOver', 0.1, 50);
        
        return { feedRate, safeZ, maxDepth, stepOver };
      }
    }

    // ================= Debug overlay system =================
    (function initDebugOverlay(){
      const debugList = document.getElementById('debugList');
      const dbgClear = document.getElementById('dbgClear');
      const dbgCopy = document.getElementById('dbgCopy');
      const dbgToggleSize = document.getElementById('dbgToggleSize');
      const debugOverlay = document.getElementById('debugOverlay');
      const debugSummary = document.getElementById('debugSummary');
      const logs = [];

      function formatTime(d) { return d.toISOString().slice(11, 23); }
      function updateSummary() { debugSummary.textContent = logs.length + ' ÿ≥ÿ¨ŸÑÿßÿ™'; }

      function addEntry(type, message, stack) {
        const time = new Date();
        const entry = { time, type, message, stack };
        logs.push(entry);
        updateSummary();

        const div = document.createElement('div');
        div.className = 'dbg-item ' + (type === 'error' ? 'dbg-error' : (type === 'warn' ? 'dbg-warn' : 'dbg-info'));
        const tspan = document.createElement('span');
        tspan.className = 'dbg-time';
        tspan.textContent = `[${formatTime(time)}] ${type.toUpperCase()}`;
        const msg = document.createElement('div');
        msg.textContent = message;
        div.appendChild(tspan);
        div.appendChild(msg);
        if (stack) {
          const meta = document.createElement('div');
          meta.className = 'dbg-meta';
          meta.textContent = String(stack).split('\n').slice(0,3).join(' | ');
          div.appendChild(meta);
        }
        debugList.prepend(div);
      }

      dbgClear.addEventListener('click', () => {
        debugList.innerHTML = '';
        logs.length = 0;
        updateSummary();
      });

      dbgCopy.addEventListener('click', async () => {
        try {
          const text = logs.map(l => `[${l.time.toISOString()}] ${l.type.toUpperCase()}: ${l.message}\n${l.stack||''}`).join('\n\n');
          await navigator.clipboard.writeText(text);
          addEntry('info', 'ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑÿ≥ÿ¨ŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿßŸÅÿ∏ÿ©');
        } catch (e) {
          addEntry('error', 'ŸÅÿ¥ŸÑ ŸÜÿ≥ÿÆ ÿßŸÑÿ≥ÿ¨ŸÑ: ' + (e.message || e));
        }
      });

      dbgToggleSize.addEventListener('click', (ev) => {
        ev.stopPropagation();
        debugOverlay.classList.toggle('minimized');
        dbgToggleSize.textContent = debugOverlay.classList.contains('minimized') ? 'üîº' : 'üîΩ';
      });

      // Click restore when minimized
      debugOverlay.addEventListener('click', (ev) => {
        if (debugOverlay.classList.contains('minimized')) {
          debugOverlay.classList.remove('minimized');
          dbgToggleSize.textContent = 'üîΩ';
        }
      });

      // override console methods
      const _log = console.log, _warn = console.warn, _error = console.error;
      console.log = function(...args) {
        try { addEntry('info', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' ')); } catch(e){}
        _log.apply(console, args);
      };
      console.warn = function(...args) {
        try { addEntry('warn', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' '), new Error().stack); } catch(e){}
        _warn.apply(console, args);
      };
      console.error = function(...args) {
        try { addEntry('error', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' '), new Error().stack); } catch(e){}
        _error.apply(console, args);
      };

      window.addEventListener('error', function(ev){
        try { addEntry('error', ev.message + ' (' + ev.filename + ':' + ev.lineno + ')', ev.error && ev.error.stack ? ev.error.stack : ev.filename + ':' + ev.lineno); } catch(e){}
      });

      window.addEventListener('unhandledrejection', function(ev){
        try { addEntry('error', 'UnhandledRejection: ' + (ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason)), ev.reason && ev.reason.stack ? ev.reason.stack : ''); } catch(e){}
      });

    })();

    // ================= Helper UI funcs =================
    function showToast(msg, ms = 3000) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.style.display = 'block';
      clearTimeout(t._t);
      t._t = setTimeout(() => t.style.display = 'none', ms);
      try { console.log(msg); } catch (e) {}
    }

    function cmToMm(cm) { return cm * 10; }
    function mmToCm(mm) { return mm / 10; }

    function updateDimensionDisplay() {
      const widthCm = parseFloat(document.getElementById('workWidth').value) || 0;
      const heightCm = parseFloat(document.getElementById('workHeight').value) || 0;
      document.getElementById('widthMm').textContent = cmToMm(widthCm).toFixed(1) + ' ŸÖŸÖ';
      document.getElementById('heightMm').textContent = cmToMm(heightCm).toFixed(1) + ' ŸÖŸÖ';
      
      // Update laser dimensions too
      const laserWidthCm = parseFloat(document.getElementById('laserWorkWidth').value) || 0;
      const laserHeightCm = parseFloat(document.getElementById('laserWorkHeight').value) || 0;
      document.getElementById('laserWidthMm').textContent = cmToMm(laserWidthCm).toFixed(1) + ' ŸÖŸÖ';
      document.getElementById('laserHeightMm').textContent = cmToMm(laserHeightCm).toFixed(1) + ' ŸÖŸÖ';
    }

    function showElement(elementId, hidePlaceholderId) {
      const element = document.getElementById(elementId);
      const placeholder = document.getElementById(hidePlaceholderId);
      if (element && placeholder) {
        element.style.display = 'block';
        placeholder.style.display = 'none';
      }
    }

    // ================= OpenCV readiness - ÿßŸÑÿ•ÿµÿØÿßÿ± ÿßŸÑŸÖÿ≠ÿ≥ŸÜ =================
    function waitForCv() {
      if (typeof cv !== 'undefined') {
        // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿ∑ÿ±ŸäŸÇÿ© ÿ¢ŸÖŸÜÿ© ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ¨ÿßŸáÿ≤Ÿäÿ© OpenCV
        try {
          // ÿßÿÆÿ™ÿ®ÿßÿ± ÿ®ÿ≥Ÿäÿ∑ ŸÑŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ OpenCV ŸäÿπŸÖŸÑ
          const testMat = new cv.Mat();
          if (testMat) {
            cvReady = true;
            testMat.delete(); // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©
            
            // ÿ™ÿ≠ÿØŸäÿ´ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ
            document.getElementById('cvState').innerHTML = '‚úÖ OpenCV ÿ¨ÿßŸáÿ≤';
            showToast('ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ OpenCV ÿ®ŸÜÿ¨ÿßÿ≠', 1400);
            
            // ŸÖÿ≠ÿßŸàŸÑÿ© ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸâ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿßŸÑÿ•ÿµÿØÿßÿ± ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ŸÖÿ™ŸàŸÅÿ±ÿ©
            try {
              if (cv.getBuildInformation) {
                console.log('OpenCV build info available');
              }
            } catch (e) {
              console.log('OpenCV loaded (version info not available)');
            }
          }
        } catch (error) {
          console.warn('OpenCV test failed, retrying...', error);
          setTimeout(waitForCv, 100);
        }
      } else {
        setTimeout(waitForCv, 100);
      }
    }

    // ÿ•ÿ∂ÿßŸÅÿ© ŸÖÿπÿßŸÑÿ¨ ÿ£ÿÆÿ∑ÿßÿ° ŸÑÿ™ÿ≠ŸÖŸäŸÑ OpenCV
    window.addEventListener('error', function(e) {
      if (e.filename && e.filename.includes('opencv.js')) {
        document.getElementById('cvState').innerHTML = '‚ùå ŸÅÿ¥ŸÑ ÿ™ÿ≠ŸÖŸäŸÑ OpenCV';
        showToast('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ OpenCV. ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÑÿßÿ™ÿµÿßŸÑ ÿ®ÿßŸÑÿ•ŸÜÿ™ÿ±ŸÜÿ™', 5000);
      }
    });

    // ÿ®ÿØÿ° ÿ™ÿ≠ŸÖŸäŸÑ OpenCV
    waitForCv();

    // ================= ŸÜÿ∏ÿßŸÖ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© ÿßŸÑŸÖÿ≠ÿ≥ŸÜ =================
    class MemoryManager {
      constructor() {
        this.mats = new Set();
        this.maxMats = 20; // ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑŸÖÿµŸÅŸàŸÅÿßÿ™ ÿßŸÑŸÖÿÆÿ≤ŸÜÿ©
      }

      track(mat) {
        if (mat && !mat.isDeleted) {
          this.mats.add(mat);
          // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© ÿ•ÿ∞ÿß ÿ™ÿ¨ÿßŸàÿ≤ŸÜÿß ÿßŸÑÿ≠ÿØ
          if (this.mats.size > this.maxMats) {
            this.cleanupOldest();
          }
        }
      }

      cleanupOldest() {
        if (this.mats.size > 0) {
          const oldest = this.mats.values().next().value;
          this.safeDelete(oldest);
          this.mats.delete(oldest);
        }
      }

      safeDelete(mat) {
        if (mat && !mat.isDeleted && mat.delete) {
          try {
            mat.delete();
          } catch (e) {
            console.warn('Error deleting mat:', e);
          }
        }
      }

      cleanupAll() {
        this.mats.forEach(mat => this.safeDelete(mat));
        this.mats.clear();
      }

      cleanupMats() {
        try {
          if (grayMat && !grayMat.isDeleted) { 
            this.safeDelete(grayMat);
            grayMat = null; 
          }
        } catch (e) { console.warn('cleanup grayMat', e); }
        
        try {
          if (contour && !contour.isDeleted && contour.delete) {
            this.safeDelete(contour);
            contour = null;
          }
        } catch (e) { console.warn('cleanup contour', e); }
        
        try {
          additionalContours.forEach(item => {
            if (item && item.contour && !item.contour.isDeleted) {
              this.safeDelete(item.contour);
            }
          });
          additionalContours = [];
        } catch (e) { console.warn('cleanup additionalContours', e); }
      }
    }

    const memoryManager = new MemoryManager();

    // ================= Tabs behavior =================
    document.querySelectorAll('.tab-buttons button').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-buttons button').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab).classList.add('active');

        if (btn.dataset.tab === 'simulation' && document.getElementById('gcodeOut').value) {
          initSimulation();
        }
      });
    });

    // ================= Machine Category Control =================
    document.getElementById('machineCategory').addEventListener('change', function(e) {
      const isLaser = e.target.value === 'laser';
      
      // ÿ•ÿ∏Ÿáÿßÿ±/ÿ•ÿÆŸÅÿßÿ° ÿßŸÑÿ£ŸÇÿ≥ÿßŸÖ
      document.getElementById('routerSettings').style.display = isLaser ? 'none' : 'block';
      document.getElementById('laserSettings').style.display = isLaser ? 'block' : 'none';
      
      // ÿ™ÿ≠ÿØŸäÿ´ Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±
      updateButtonVisibility(isLaser);
      
      // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿµŸàÿ±ÿ© ŸÖÿ≠ŸÖŸÑÿ©ÿå ŸÜÿπŸäÿØ ŸÉÿ¥ŸÅ ÿßŸÑÿ≠ŸàÿßŸÅ ÿ®ÿßŸÑŸÜÿ∏ÿßŸÖ ÿßŸÑŸÖŸÜÿßÿ≥ÿ®
      if (previewCanvas && cvReady && !isProcessing) {
        taskManager.addTask(async () => {
          if (isLaser) {
            await detectLaserContours();
          } else {
            await detectContours();
          }
        }, 'ÿ™ÿ®ÿØŸäŸÑ Ÿàÿ∂ÿπ ÿßŸÑŸÖÿßŸÉŸäŸÜÿ©');
      }
      
      showToast(isLaser ? 'ÿ™ŸÖ ÿßŸÑÿ™ÿ®ÿØŸäŸÑ ÿ•ŸÑŸâ Ÿàÿ∂ÿπ ÿßŸÑŸÑŸäÿ≤ÿ±' : 'ÿ™ŸÖ ÿßŸÑÿ™ÿ®ÿØŸäŸÑ ÿ•ŸÑŸâ Ÿàÿ∂ÿπ ÿßŸÑÿ±Ÿàÿßÿ™ÿ±');
    });

    function updateButtonVisibility(isLaser) {
      const rasterBtn = document.getElementById('btnGen');
      const contourBtn = document.getElementById('btnContour');
      const quickBtn = document.getElementById('btnQuick');
      const laserEngraveBtn = document.getElementById('btnLaserEngrave');
      const laserQuickBtn = document.getElementById('btnLaserQuick');
      const laserCutBtn = document.getElementById('btnLaserCut');
      const laserDownloadBtn = document.getElementById('btnLaserDownload');
      const redetectLaserBtn = document.getElementById('btnRedetectLaser');
      
      if (isLaser) {
        rasterBtn.style.display = 'none';
        contourBtn.style.display = 'none';
        quickBtn.style.display = 'none';
        laserEngraveBtn.style.display = 'block';
        laserQuickBtn.style.display = 'block';
        laserCutBtn.style.display = 'block';
        laserDownloadBtn.style.display = 'block';
        redetectLaserBtn.style.display = 'block';
      } else {
        rasterBtn.style.display = 'block';
        contourBtn.style.display = 'block';
        quickBtn.style.display = 'block';
        laserEngraveBtn.style.display = 'none';
        laserQuickBtn.style.display = 'none';
        laserCutBtn.style.display = 'none';
        laserDownloadBtn.style.display = 'none';
        redetectLaserBtn.style.display = 'none';
      }
    }

    // Laser power slider update
    document.getElementById('laserPower').addEventListener('input', function(e) {
      document.getElementById('laserPowerValue').textContent = e.target.value + '%';
      document.getElementById('laserPowerValue').style.color = `hsl(${e.target.value * 1.2}, 100%, 60%)`;
    });

    // Laser detail slider update
    document.getElementById('laserDetail').addEventListener('input', function(e) {
      document.getElementById('laserDetailValue').textContent = e.target.value;
    });

    // Laser edge mode descriptions
    const laserModeDescriptions = {
      canny: 'Canny - ŸÉÿ¥ŸÅ ÿ≠ŸàÿßŸÅ ÿ™ŸÇŸÑŸäÿØŸä ŸÖŸÜÿßÿ≥ÿ® ŸÑŸÑÿµŸàÿ± ÿßŸÑÿπÿßŸÖÿ©',
      adaptive: 'Adaptive Threshold - ŸÖŸÖÿ™ÿßÿ≤ ŸÑŸÑÿµŸàÿ± ÿ∞ÿßÿ™ ÿßŸÑÿ•ÿ∂ÿßÿ°ÿ© ÿ∫Ÿäÿ± ÿßŸÑŸÖÿ™ÿ¨ÿßŸÜÿ≥ÿ©',
      morphological: 'Morphological - ŸÑŸÑÿ≠ŸàÿßŸÅ ÿßŸÑÿØŸÇŸäŸÇÿ© ŸàÿßŸÑŸÜÿßÿπŸÖÿ© ŸàÿßŸÑÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿµÿ∫Ÿäÿ±ÿ©',
      gradient: 'Gradient-Based - ŸÑŸÑÿ™ÿØÿ±ÿ¨ÿßÿ™ ÿßŸÑŸÑŸàŸÜŸäÿ© ŸàÿßŸÑÿµŸàÿ± ÿ∞ÿßÿ™ ÿßŸÑÿ™ÿ®ÿßŸäŸÜ ÿßŸÑÿπÿßŸÑŸä'
    };

    document.getElementById('laserEdgeMode').addEventListener('change', function(e) {
      document.getElementById('laserModeDesc').textContent = laserModeDescriptions[e.target.value] || '';
      if (!previewCanvas || isProcessing) return;
      const isLaser = document.getElementById('machineCategory').value === 'laser';
      if (isLaser && cvReady && previewCanvas && previewCanvas.width > 0) {
        taskManager.addTask(detectLaserContours, 'ÿ™ÿ≠ÿØŸäÿ´ ŸÉÿ¥ŸÅ ÿ≠ŸàÿßŸÅ ÿßŸÑŸÑŸäÿ≤ÿ±');
      }
    });

    // Laser center origin
    document.getElementById('btnLaserCenterOrigin').addEventListener('click', () => {
      const workWidth = parseFloat(document.getElementById('laserWorkWidth').value) || 0;
      const workHeight = parseFloat(document.getElementById('laserWorkHeight').value) || 0;
      document.getElementById('laserOriginX').value = (workWidth / 2).toFixed(1);
      document.getElementById('laserOriginY').value = (workHeight / 2).toFixed(1);
      showToast("ÿ™ŸÖ ÿ™Ÿàÿ≥Ÿäÿ∑ ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ£ÿµŸÑ ŸÑŸÑŸÑŸäÿ≤ÿ±");
    });

    // Laser redetect button
    document.getElementById('btnRedetectLaser').addEventListener('click', () => {
      if (!previewCanvas) {
        showToast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿµŸàÿ±ÿ© ŸÖÿ≠ŸÖŸÑÿ©');
        return;
      }
      if (cvReady && !isProcessing) {
        taskManager.addTask(detectLaserContours, 'ÿ•ÿπÿßÿØÿ© ŸÉÿ¥ŸÅ ÿ≠ŸàÿßŸÅ ÿßŸÑŸÑŸäÿ≤ÿ±');
      }
    });

    // ================= Load image =================
    document.getElementById('fileInput').addEventListener('change', async function (e) {
      if (isProcessing) {
        showToast('ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿµŸàÿ±ÿ© ÿ≥ÿßÿ®ŸÇÿ©...');
        return;
      }

      const file = e.target.files[0];
      if (!file) return;
      
      // ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ŸÜŸàÿπ ÿßŸÑŸÖŸÑŸÅ
      if (!file.type.match('image.*')) {
        showToast('ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ŸÖŸÑŸÅ ÿµŸàÿ±ÿ© ŸÅŸÇÿ∑ (JPEG, PNG, etc.)');
        return;
      }
      
      // ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ
      if (file.size > 20 * 1024 * 1024) { // 20MB
        showToast('ÿ≠ÿ¨ŸÖ ÿßŸÑŸÖŸÑŸÅ ŸÉÿ®Ÿäÿ± ÿ¨ÿØÿßŸã. ÿßŸÑÿ±ÿ¨ÿßÿ° ÿßÿÆÿ™Ÿäÿßÿ± ÿµŸàÿ±ÿ© ÿ£ÿµÿ∫ÿ± ŸÖŸÜ 20MB');
        return;
      }
      
      await taskManager.addTask(async () => {
        try {
          isProcessing = true;
          memoryManager.cleanupMats();
          const img = new Image();
          
          img.onerror = function() {
            throw new Error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©. ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÖŸÑŸÅ ÿµÿßŸÑÿ≠');
          };
          
          img.src = URL.createObjectURL(file);
          await img.decode();

          previewCanvas = document.getElementById('canvasOriginal');
          const ctx = previewCanvas.getContext('2d');

          let w = img.width, h = img.height;
          
          // ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ≠ÿ¨ŸÖ ÿßŸÑÿµŸàÿ±ÿ© ŸàŸÇŸÑŸÑŸáÿß ÿ•ÿ∞ÿß ŸÑÿ≤ŸÖ ÿßŸÑÿ£ŸÖÿ±
          const maxPixels = 4000000; // 4MP
          const currentPixels = w * h;
          if (currentPixels > maxPixels) {
            const ratio = Math.sqrt(maxPixels / currentPixels);
            w = Math.floor(w * ratio);
            h = Math.floor(h * ratio);
          }

          previewCanvas.width = w;
          previewCanvas.height = h;
          ctx.drawImage(img, 0, 0, w, h);
          showElement('canvasOriginal', 'originalPlaceholder');

          // ÿ™ÿ≠ÿ±Ÿäÿ± ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©
          URL.revokeObjectURL(img.src);

          if (cvReady) {
            const isLaser = document.getElementById('machineCategory').value === 'laser';
            if (isLaser) {
              await detectLaserContours();
            } else {
              await detectContours();
            }
          } else {
            showToast('ŸÅŸä ÿßŸÜÿ™ÿ∏ÿßÿ± OpenCV...');
            await new Promise(resolve => {
              const checkCv = setInterval(() => {
                if (cvReady) {
                  clearInterval(checkCv);
                  resolve();
                }
              }, 100);
            });
            
            const isLaser = document.getElementById('machineCategory').value === 'laser';
            if (isLaser) {
              await detectLaserContours();
            } else {
              await detectContours();
            }
          }
        } catch (error) {
          console.error('image load error', error);
          throw new Error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©: ' + error.message);
        } finally {
          isProcessing = false;
        }
      }, 'ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©');
    });

    // ================= Edge detection & contours ŸÑŸÑÿ±ÿßŸàÿ™ÿ± =================
    async function detectContours() {
      if (!cvReady) {
        throw new Error('OpenCV ÿ∫Ÿäÿ± ÿ¨ÿßŸáÿ≤ ÿ®ÿπÿØ');
      }
      
      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿµŸàÿ±ÿ© ÿµÿßŸÑÿ≠ÿ©
      if (!previewCanvas || previewCanvas.width === 0 || previewCanvas.height === 0) {
        throw new Error('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿµŸàÿ±ÿ© ÿµÿßŸÑÿ≠ÿ© ŸÑŸÑŸÖÿπÿßŸÑÿ¨ÿ©');
      }
      
      let src = null, gray = null, blurred = null, edges = null, hierarchy = null, contours = null, kernel = null;
      
      try {
        src = cv.imread(previewCanvas);
        if (src.empty()) {
          throw new Error('ÿßŸÑÿµŸàÿ±ÿ© ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ© ŸÑŸÑŸÖÿπÿßŸÑÿ¨ÿ©');
        }
        memoryManager.track(src);
        
        gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        memoryManager.track(gray);
        
        blurred = new cv.Mat();
        cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
        memoryManager.track(blurred);

        // pick edge mode
        const mode = document.getElementById('edgeMode').value || 'auto';
        // sensitivity
        const sens = parseFloat(document.getElementById('edgeSensitivity').value) || 0.33;

        const median = cv.mean(blurred)[0];
        const lowerThreshold = Math.max(0, (1.0 - sens) * median);
        const upperThreshold = Math.min(255, (1.0 + sens) * median);

        edges = new cv.Mat();
        memoryManager.track(edges);
        
        if (mode === 'sobel') {
          const gradX = new cv.Mat(), gradY = new cv.Mat();
          cv.Sobel(blurred, gradX, cv.CV_16S, 1, 0, 3, 1, 0, cv.BORDER_DEFAULT);
          cv.Sobel(blurred, gradY, cv.CV_16S, 0, 1, 3, 1, 0, cv.BORDER_DEFAULT);
          cv.convertScaleAbs(gradX, gradX);
          cv.convertScaleAbs(gradY, gradY);
          cv.addWeighted(gradX, 0.5, gradY, 0.5, 0, edges);
          memoryManager.safeDelete(gradX);
          memoryManager.safeDelete(gradY);
        } else if (mode === 'laplace') {
          cv.Laplacian(blurred, edges, cv.CV_16S, 3, 1, 0, cv.BORDER_DEFAULT);
          cv.convertScaleAbs(edges, edges);
        } else {
          cv.Canny(blurred, edges, lowerThreshold, upperThreshold);
        }

        // improve edges
        kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
        cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);
        memoryManager.track(kernel);

        contours = new cv.MatVector();
        hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
        memoryManager.track(contours);
        memoryManager.track(hierarchy);

        const minArea = (gray.cols * gray.rows) * 0.01; // default 1%
        const validContours = [];
        for (let i = 0; i < contours.size(); i++) {
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area > minArea) {
            validContours.push({ contour: cnt, area });
          } else {
            memoryManager.safeDelete(cnt);
          }
        }

        if (validContours.length > 0) {
          validContours.sort((a,b)=> b.area - a.area);
          contour = validContours[0].contour;
          additionalContours = validContours.slice(1).map(v => ({ contour: v.contour, area: v.area }));
          showToast(`ÿ™ŸÖ ŸÉÿ¥ŸÅ ${validContours.length} ŸÉŸàŸÜÿ™Ÿàÿ±`);
        } else {
          throw new Error('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ŸàÿßŸÅ Ÿàÿßÿ∂ÿ≠ÿ© ŸÅŸä ÿßŸÑÿµŸàÿ±ÿ©');
        }

        if (grayMat) { 
          memoryManager.safeDelete(grayMat);
        }
        grayMat = gray.clone();
        memoryManager.track(grayMat);

        renderHeatmap(); // uses currentColormap
        renderContour(gray, contour);

      } catch (err) {
        console.error('detectContours error', err);
        throw new Error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ©: ' + err.message);
      } finally {
        // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖÿµŸÅŸàŸÅÿßÿ™ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ©
        memoryManager.safeDelete(src);
        memoryManager.safeDelete(blurred);
        memoryManager.safeDelete(edges);
        memoryManager.safeDelete(hierarchy);
        memoryManager.safeDelete(contours);
        memoryManager.safeDelete(kernel);
        memoryManager.safeDelete(gray);
      }
    }

    // ================= Laser-Specific Edge Detection =================
    async function detectLaserContours() {
      if (!cvReady) {
        throw new Error('OpenCV ÿ∫Ÿäÿ± ÿ¨ÿßŸáÿ≤ ÿ®ÿπÿØ');
      }
      
      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ÿµŸàÿ±ÿ© ÿµÿßŸÑÿ≠ÿ©
      if (!previewCanvas || previewCanvas.width === 0 || previewCanvas.height === 0) {
        throw new Error('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿµŸàÿ±ÿ© ÿµÿßŸÑÿ≠ÿ© ŸÑŸÑŸÖÿπÿßŸÑÿ¨ÿ©');
      }
      
      let src = null, gray = null, edges = null, hierarchy = null, contours = null;
      
      try {
        src = cv.imread(previewCanvas);
        if (src.empty()) {
          throw new Error('ÿßŸÑÿµŸàÿ±ÿ© ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿ© ŸÑŸÑŸÖÿπÿßŸÑÿ¨ÿ©');
        }
        memoryManager.track(src);
        
        gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        memoryManager.track(gray);
        
        const mode = document.getElementById('laserEdgeMode').value || 'adaptive';
        const detailLevel = parseInt(document.getElementById('laserDetail').value) || 5;
        
        edges = new cv.Mat();
        memoryManager.track(edges);
        
        if (mode === 'adaptive') {
          const adaptive = new cv.Mat();
          const blockSize = Math.max(3, 2 * Math.floor(detailLevel) + 1);
          cv.adaptiveThreshold(gray, adaptive, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, blockSize, 2);
          memoryManager.track(adaptive);
          
          const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
          cv.morphologyEx(adaptive, edges, cv.MORPH_CLOSE, kernel);
          memoryManager.track(kernel);
          
          memoryManager.safeDelete(adaptive);
          memoryManager.safeDelete(kernel);
          
        } else if (mode === 'morphological') {
          const blurred = new cv.Mat();
          cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0);
          memoryManager.track(blurred);
          
          const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
          const dilated = new cv.Mat();
          const eroded = new cv.Mat();
          
          cv.dilate(blurred, dilated, kernel);
          cv.erode(blurred, eroded, kernel);
          cv.subtract(dilated, eroded, edges);
          
          cv.normalize(edges, edges, 0, 255, cv.NORM_MINMAX);
          
          memoryManager.safeDelete(blurred);
          memoryManager.safeDelete(kernel);
          memoryManager.safeDelete(dilated);
          memoryManager.safeDelete(eroded);
          
        } else if (mode === 'gradient') {
          const blurred = new cv.Mat();
          cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
          memoryManager.track(blurred);
          
          const gradX = new cv.Mat();
          const gradY = new cv.Mat();
          const absGradX = new cv.Mat();
          const absGradY = new cv.Mat();
          
          cv.Sobel(blurred, gradX, cv.CV_16S, 1, 0, 3, 1, 0, cv.BORDER_DEFAULT);
          cv.Sobel(blurred, gradY, cv.CV_16S, 0, 1, 3, 1, 0, cv.BORDER_DEFAULT);
          
          cv.convertScaleAbs(gradX, absGradX);
          cv.convertScaleAbs(gradY, absGradY);
          cv.addWeighted(absGradX, 0.5, absGradY, 0.5, 0, edges);
          
          const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(2, 2));
          cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);
          memoryManager.track(kernel);
          
          memoryManager.safeDelete(blurred);
          memoryManager.safeDelete(gradX);
          memoryManager.safeDelete(gradY);
          memoryManager.safeDelete(absGradX);
          memoryManager.safeDelete(absGradY);
          memoryManager.safeDelete(kernel);
          
        } else {
          const blurred = new cv.Mat();
          cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0);
          cv.Canny(blurred, edges, 50, 150);
          memoryManager.safeDelete(blurred);
        }

        if (detailLevel > 5) {
          const kernelSize = Math.min(3, Math.floor(detailLevel / 3));
          const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(kernelSize, kernelSize));
          cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);
          memoryManager.safeDelete(kernel);
        }

        contours = new cv.MatVector();
        hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
        memoryManager.track(contours);
        memoryManager.track(hierarchy);

        const minArea = (gray.cols * gray.rows) * 0.002;
        const validContours = [];
        
        for (let i = 0; i < contours.size(); i++) {
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area > minArea) {
            validContours.push({ contour: cnt, area });
          } else {
            memoryManager.safeDelete(cnt);
          }
        }

        if (validContours.length > 0) {
          validContours.sort((a,b)=> b.area - a.area);
          contour = validContours[0].contour;
          additionalContours = validContours.slice(1).map(v => ({ contour: v.contour, area: v.area }));
          showToast(`ÿ™ŸÖ ŸÉÿ¥ŸÅ ${validContours.length} ŸÉŸàŸÜÿ™Ÿàÿ± ŸÑŸÑŸÑŸäÿ≤ÿ±`);
        } else {
          throw new Error('ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ≠ŸàÿßŸÅ ŸÖŸÜÿßÿ≥ÿ®ÿ© ŸÑŸÑŸÑŸäÿ≤ÿ±');
        }

        if (grayMat) { 
          memoryManager.safeDelete(grayMat);
        }
        grayMat = gray.clone();
        memoryManager.track(grayMat);

        renderHeatmap();
        renderContour(gray, contour);

      } catch (err) {
        console.error('detectLaserContours error', err);
        throw new Error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÑŸäŸÑ ÿßŸÑÿµŸàÿ±ÿ© ŸÑŸÑŸÑŸäÿ≤ÿ±: ' + err.message);
      } finally {
        // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ©
        memoryManager.safeDelete(src);
        memoryManager.safeDelete(gray);
        memoryManager.safeDelete(edges);
        memoryManager.safeDelete(hierarchy);
        memoryManager.safeDelete(contours);
      }
    }

    // live update when edge mode or sensitivity changed ŸÑŸÑÿ±ÿßŸàÿ™ÿ±
    document.getElementById('edgeMode').addEventListener('change', () => {
      if (!previewCanvas || isProcessing) return;
      const isLaser = document.getElementById('machineCategory').value === 'laser';
      if (!isLaser && cvReady && previewCanvas && previewCanvas.width > 0) {
        taskManager.addTask(detectContours, 'ÿ™ÿ≠ÿØŸäÿ´ ŸÉÿ¥ŸÅ ÿßŸÑÿ≠ŸàÿßŸÅ');
      }
    });
    
    document.getElementById('edgeSensitivity').addEventListener('input', (e) => {
      document.getElementById('edgeValue').textContent = parseFloat(e.target.value).toFixed(2);
      if (!previewCanvas || isProcessing) return;
      const isLaser = document.getElementById('machineCategory').value === 'laser';
      if (!isLaser && cvReady && previewCanvas && previewCanvas.width > 0) {
        taskManager.addTask(detectContours, 'ÿ™ÿ≠ÿØŸäÿ´ ÿ≠ÿ≥ÿßÿ≥Ÿäÿ© ÿßŸÑÿ≠ŸàÿßŸÅ');
      }
    });

    // ================= Colormap utilities =================
    function clamp(v, a=0, b=1){ return Math.max(a, Math.min(b, v)); }
    function getColormapColor(t, map) {
      // t in [0,1]
      t = clamp(t);
      if (map === 'hot') {
        // hot: black->red->yellow->white
        if (t < 0.33) return { r: Math.round(t/0.33*128), g: 0, b: 0 };
        if (t < 0.66) return { r: Math.round(128 + (t-0.33)/0.33*127), g: Math.round((t-0.33)/0.33*128), b: 0 };
        return { r: 255, g: Math.round(128 + (t-0.66)/0.34*127), b: Math.round((t-0.66)/0.34*127) };
      } else if (map === 'cool') {
        // cool: cyan -> magenta-ish
        return { r: Math.round(255 * t), g: Math.round(255 * (1 - t)), b: 255 };
      } else if (map === 'gray') {
        const v = Math.round(255 * t);
        return { r: v, g: v, b: v };
      } else {
        // jet-like approximation: blue->cyan->yellow->red
        const r = Math.round(255 * clamp(1.5 - Math.abs(1.0 - 4.0*(t-0.5)), 0, 1));
        const g = Math.round(255 * clamp(1.5 - Math.abs(0.5 - 4.0*(t-0.25)), 0, 1));
        const b = Math.round(255 * clamp(1.5 - Math.abs(0.5 - 4.0*(t)), 0, 1));
        // fallback simpler jet:
        if (!r && !g && !b) {
          const jr = Math.round(255 * clamp(1.5 - Math.abs(1 - 4*(t-0.5))));
          const jg = Math.round(255 * clamp(1.5 - Math.abs(0.5 - 4*(t-0.25))));
          const jb = Math.round(255 * clamp(1.5 - Math.abs(0.5 - 4*t)));
          return { r: jr, g: jg, b: jb };
        }
        return { r, g, b };
      }
    }

    function hexToRgb(hex) {
      if (!hex) return { r:160, g:82, b:45 };
      const h = hex.replace('#','');
      const hh = (h.length===3) ? h.split('').map(c=>c+c).join('') : h;
      const bigint = parseInt(hh, 16);
      return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
    }
    function mixColors(c1, c2, t) {
      return {
        r: Math.round(c1.r * (1 - t) + c2.r * t),
        g: Math.round(c1.g * (1 - t) + c2.g * t),
        b: Math.round(c1.b * (1 - t) + c2.b * t)
      };
    }

    // ================= Rendering heatmap & contour (colormaps) =================
    function renderHeatmap() {
      if (!grayMat || !previewCanvas) return;
      const heatCanvas = document.getElementById('canvasHeatmap');
      const ctx = heatCanvas.getContext('2d');
      heatCanvas.width = grayMat.cols;
      heatCanvas.height = grayMat.rows;
      const imgData = ctx.createImageData(heatCanvas.width, heatCanvas.height);
      const data = grayMat.data;
      for (let i = 0; i < data.length; i++) {
        const value = data[i]; // 0..255
        const t = value / 255.0; // normalized
        const col = getColormapColor(t, currentColormap);
        const idx = i * 4;
        imgData.data[idx] = col.r;
        imgData.data[idx + 1] = col.g;
        imgData.data[idx + 2] = col.b;
        imgData.data[idx + 3] = 255;
      }
      ctx.putImageData(imgData, 0, 0);
      showElement('canvasHeatmap', 'heatmapPlaceholder');

      // also update contour view (overlay)
      try {
        if (contour) renderContour(grayMat, contour);
      } catch(e){}
      // update top view if G-code exists
      if (lastGeneratedGcode) renderTopViewFromGcode(lastGeneratedGcode);
    }

    function renderContour(gray, mainContour) {
      const contourCanvas = document.getElementById('canvasContour');
      const ctx = contourCanvas.getContext('2d');
      contourCanvas.width = gray.cols;
      contourCanvas.height = gray.rows;
      const heatCanvas = document.getElementById('canvasHeatmap');
      // draw heatmap first (so contours overlay on top)
      try {
        ctx.drawImage(heatCanvas, 0, 0);
      } catch(e) {
        // fallback: fill with gray
        ctx.fillStyle = '#222';
        ctx.fillRect(0,0,contourCanvas.width, contourCanvas.height);
      }
      if (mainContour) {
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const data = mainContour.data32S;
        for (let i = 0; i < data.length; i += 2) {
          const x = data[i], y = data[i + 1];
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
      }
      ctx.strokeStyle = '#ffff00';
      ctx.lineWidth = 1;
      additionalContours.forEach(ci => {
        try {
          const cnt = ci.contour;
          ctx.beginPath();
          const d = cnt.data32S;
          for (let i = 0; i < d.length; i += 2) {
            const x = d[i], y = d[i+1];
            if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
          }
          ctx.closePath();
          ctx.stroke();
        } catch(e) { console.warn('renderContour extra error', e); }
      });
      showElement('canvasContour', 'contourPlaceholder');
    }

    // ================= Bilinear sampling from grayscale Mat =================
    function sampleGrayAt(x, y) {
      if (!grayMat || !previewCanvas) return 128;
      const gw = grayMat.cols, gh = grayMat.rows;
      const gx_f = (x / previewCanvas.width) * (gw - 1);
      const gy_f = (y / previewCanvas.height) * (gh - 1);
      const x0 = Math.floor(gx_f), y0 = Math.floor(gy_f);
      const x1 = Math.min(gw - 1, x0 + 1), y1 = Math.min(gh - 1, y0 + 1);
      const sx = gx_f - x0, sy = gy_f - y0;
      const v00 = grayMat.data[y0 * gw + x0];
      const v10 = grayMat.data[y0 * gw + x1];
      const v01 = grayMat.data[y1 * gw + x0];
      const v11 = grayMat.data[y1 * gw + x1];
      const v0 = v00 * (1 - sx) + v10 * sx;
      const v1 = v01 * (1 - sx) + v11 * sx;
      return Math.round(v0 * (1 - sy) + v1 * sy);
    }

    // ================= Raster helpers =================
    function addSegmentPoints(rowPoints, startX, endX, y, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue) {
      for (let x = startX; x <= endX; x += 2) {
        const pv = sampleGrayAt(x, y);
        let z;
        if (useFixedZ) {
          z = fixedZValue;
        } else {
          z = -((255 - pv) / 255.0) * maxDepth;
        }
        if (invertZ) z = -z;
        const scaledX = (x * scaleX) + originX;
        const scaledY = (y * scaleY) + originY;
        rowPoints.push({ x: scaledX, y: scaledY, z });
      }
    }

    function processRowPoints(rowPoints, lines, feed, safeZ, reverse) {
      if (reverse) rowPoints.reverse();
      lines.push('G0 X' + rowPoints[0].x.toFixed(2) + ' Y' + rowPoints[0].y.toFixed(2) + ' Z' + safeZ.toFixed(2));
      lines.push('G1 F' + feed.toFixed(0));
      for (let i = 0; i < rowPoints.length; i++) {
        const p = rowPoints[i];
        lines.push('G1 X' + p.x.toFixed(2) + ' Y' + p.y.toFixed(2) + ' Z' + p.z.toFixed(3));
      }
      lines.push('G0 Z' + safeZ.toFixed(2));
    }

    function calculateRowLength(rowPoints) {
      let length = 0;
      for (let i = 1; i < rowPoints.length; i++) {
        length += Math.hypot(rowPoints[i].x - rowPoints[i-1].x, rowPoints[i].y - rowPoints[i-1].y);
      }
      return length;
    }

    // ================= Generate Raster G-code ŸÑŸÑÿ±ÿßŸàÿ™ÿ± =================
    function generateRasterGcode(scaleDown = false) {
      if (!grayMat || !contour) {
        throw new Error("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿµŸàÿ±ÿ© ÿ¨ÿßŸáÿ≤ÿ© ŸÑŸÑÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ©");
      }
      
      try {
        InputValidator.validateRouterSettings();
        
        const dir = document.getElementById('scanDir').value;
        lastScanDir = dir;
        const stepOver = parseFloat(document.getElementById('stepOver').value) || 5;
        const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
        const feed = parseFloat(document.getElementById('feedRate').value) || 800;
        const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;

        const useFixedZ = document.getElementById('fixedZ').checked;
        const fixedZValue = parseFloat(document.getElementById('fixedZValue').value) || -1.0;
        const invertZ = document.getElementById('invertZ').checked;

        const workWidth = cmToMm(parseFloat(document.getElementById('workWidth').value) || 30);
        const workHeight = cmToMm(parseFloat(document.getElementById('workHeight').value) || 20);
        const originX = cmToMm(parseFloat(document.getElementById('originX').value) || 0);
        const originY = cmToMm(parseFloat(document.getElementById('originY').value) || 0);

        const lines = [];
        lines.push('G21 G90 G17');
        lines.push('G0 Z' + safeZ.toFixed(2));

        let totalLen = 0;
        const step = scaleDown ? stepOver * 4 : stepOver;
        const scaleX = workWidth / previewCanvas.width;
        const scaleY = workHeight / previewCanvas.height;

        if (dir === 'x') {
          for (let y = 0; y < previewCanvas.height; y += step) {
            const rowPoints = [];
            let inContour = false;
            let segmentStart = -1;
            for (let x = 0; x < previewCanvas.width; x += 2) {
              const pt = new cv.Point(x, y);
              const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
              if (inside && !inContour) { segmentStart = x; inContour = true; }
              else if (!inside && inContour) {
                addSegmentPoints(rowPoints, segmentStart, x - 1, y, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
                inContour = false;
              }
            }
            if (inContour) addSegmentPoints(rowPoints, segmentStart, previewCanvas.width - 1, y, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
            if (rowPoints.length > 1) {
              processRowPoints(rowPoints, lines, feed, safeZ, (y / step) % 2 !== 0);
              totalLen += calculateRowLength(rowPoints);
            }
          }
        } else if (dir === 'y') {
          for (let x = 0; x < previewCanvas.width; x += step) {
            const colPoints = [];
            let inContour = false;
            let segmentStart = -1;
            for (let y = 0; y < previewCanvas.height; y += 2) {
              const pt = new cv.Point(x, y);
              const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
              if (inside && !inContour) { segmentStart = y; inContour = true; }
              else if (!inside && inContour) {
                addSegmentPoints(colPoints, x, x, segmentStart, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
                inContour = false;
              }
            }
            if (inContour) addSegmentPoints(colPoints, x, x, previewCanvas.height - 1, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
            if (colPoints.length > 1) {
              processRowPoints(colPoints, lines, feed, safeZ, (x / step) % 2 !== 0);
              totalLen += calculateRowLength(colPoints);
            }
          }
        }

        lines.push('M5');
        lines.push('M30');

        // improved estimate
        const timeMin = (totalLen / (feed || 1)) + ((Math.max(0, safeZ) / 50) * (totalLen / 1000));
        document.getElementById('estTime').innerHTML = "‚è±Ô∏è ÿ™ŸÇÿØŸäÿ± ÿßŸÑŸàŸÇÿ™: " + timeMin.toFixed(1) + " ÿØŸÇŸäŸÇÿ©";

        return lines.join('\n');
      } catch (error) {
        console.error('generateRasterGcode error', error);
        throw new Error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ŸàŸÑŸäÿØ G-code (Raster): ' + error.message);
      }
    }

    // ================= Generate Contour G-code ŸÑŸÑÿ±ÿßŸàÿ™ÿ± =================
    function generateContourGcode() {
      if (!grayMat || !contour) {
        throw new Error("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ÿ≠ŸàÿßŸÅ ŸÑÿ™ŸàŸÑŸäÿØ ÿßŸÑŸÉŸàÿØ");
      }
      
      try {
        InputValidator.validateRouterSettings();
        
        const mode = document.getElementById('contourMode').value || 'outer';
        lastScanDir = 'contour';
        const feed = parseFloat(document.getElementById('feedRate').value) || 800;
        const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
        const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;

        const useFixedZ = document.getElementById('fixedZ').checked;
        const fixedZValue = parseFloat(document.getElementById('fixedZValue').value) || -1.0;
        const invertZ = document.getElementById('invertZ').checked;

        const workWidth = cmToMm(parseFloat(document.getElementById('workWidth').value) || 30);
        const workHeight = cmToMm(parseFloat(document.getElementById('workHeight').value) || 20);
        const originX = cmToMm(parseFloat(document.getElementById('originX').value) || 0);
        const originY = cmToMm(parseFloat(document.getElementById('originY').value) || 0);
        const scaleX = workWidth / previewCanvas.width;
        const scaleY = workHeight / previewCanvas.height;

        const lines = [];
        lines.push('G21 G90 G17');
        lines.push('G0 Z' + safeZ.toFixed(2));

        const contoursToUse = (mode === 'outer') ? [contour] : [contour, ...additionalContours.map(c => c.contour)];
        let totalLen = 0;

        for (const cnt of contoursToUse) {
          const data = cnt.data32S;
          if (!data || data.length < 4) continue;

          let x0 = data[0], y0 = data[1];
          const startX = (x0 * scaleX + originX).toFixed(2);
          const startY = (y0 * scaleY + originY).toFixed(2);
          const startGray = sampleGrayAt(x0, y0);

          let zStart;
          if (useFixedZ) zStart = fixedZValue;
          else zStart = -((255 - startGray) / 255.0) * maxDepth;
          if (invertZ) zStart = -zStart;

          lines.push(`G0 X${startX} Y${startY} Z${safeZ.toFixed(2)}`);
          lines.push(`G1 F${feed.toFixed(0)}`);
          lines.push(`G1 Z${zStart.toFixed(3)}`);

          for (let i = 2; i < data.length; i += 2) {
            const x = data[i], y = data[i + 1];
            const px = (x * scaleX + originX).toFixed(2);
            const py = (y * scaleY + originY).toFixed(2);
            const pv = sampleGrayAt(x, y);
            let zVal;
            if (useFixedZ) zVal = fixedZValue;
            else zVal = -((255 - pv) / 255.0) * maxDepth;
            if (invertZ) zVal = -zVal;
            lines.push(`G1 X${px} Y${py} Z${zVal.toFixed(3)}`);
            totalLen += Math.hypot(x - x0, y - y0);
            x0 = x; y0 = y;
          }

          lines.push(`G1 X${startX} Y${startY} Z${zStart.toFixed(3)}`);
          lines.push(`G0 Z${safeZ.toFixed(2)}`);
        }

        lines.push('M5');
        lines.push('M30');

        const timeMin = totalLen / (parseFloat(document.getElementById('feedRate').value)||800);
        document.getElementById('estTime').innerHTML = "‚è±Ô∏è ÿ™ŸÇÿØŸäÿ± ÿßŸÑŸàŸÇÿ™ (Contour): " + timeMin.toFixed(1) + " ÿØŸÇŸäŸÇÿ©";

        return lines.join('\n');

      } catch (error) {
        console.error('generateContourGcode error', error);
        throw new Error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ŸàŸÑŸäÿØ G-code (Contour): ' + error.message);
      }
    }

    // ================= Laser G-code Generation =================
    function generateLaserEngraveGcode() {
      if (!grayMat || !contour) {
        throw new Error("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿµŸàÿ±ÿ© ÿ¨ÿßŸáÿ≤ÿ© ŸÑŸÑŸÖÿπÿßŸÑÿ¨ÿ©");
      }

      try {
        InputValidator.validateLaserSettings();
        
        const laserPower = parseInt(document.getElementById('laserPower').value) || 80;
        const laserSpeed = parseInt(document.getElementById('laserSpeed').value) || 2000;
        const dynamicPower = document.getElementById('laserDynamic').checked;

        const workWidth = cmToMm(parseFloat(document.getElementById('laserWorkWidth').value) || 30);
        const workHeight = cmToMm(parseFloat(document.getElementById('laserWorkHeight').value) || 20);
        const originX = cmToMm(parseFloat(document.getElementById('laserOriginX').value) || 0);
        const originY = cmToMm(parseFloat(document.getElementById('laserOriginY').value) || 0);

        const lines = [];
        lines.push('G21 G90');
        lines.push('G0 X0 Y0');
        lines.push('M3 S' + Math.round(laserPower * 10)); // ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑŸÑŸäÿ≤ÿ± ŸÖÿ±ÿ© Ÿàÿßÿ≠ÿØÿ©
        
        const scaleX = workWidth / previewCanvas.width;
        const scaleY = workHeight / previewCanvas.height;
        
        // ÿ•ÿπÿØÿßÿØÿßÿ™ ŸÖÿÆŸÅŸÅÿ© ÿ¨ÿØÿßŸã
        const stepOver = 3.0; // ÿÆÿ∑Ÿàÿßÿ™ ŸÉÿ®Ÿäÿ±ÿ©
        let totalLen = 0;
        let pointCount = 0;

        for (let y = 0; y < previewCanvas.height; y += stepOver) {
          const rowPoints = [];
          
          for (let x = 0; x < previewCanvas.width; x += 3) { // ÿÆÿ∑Ÿàÿßÿ™ ŸÉÿ®Ÿäÿ±ÿ©
            const pt = new cv.Point(x, y);
            const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
            
            if (inside) {
              const pv = sampleGrayAt(x, y);
              const power = dynamicPower ? Math.round((pv / 255) * laserPower) : laserPower;
              const scaledX = (x * scaleX) + originX;
              const scaledY = (y * scaleY) + originY;
              rowPoints.push({ x: scaledX, y: scaledY, power });
              pointCount++;
              
              // ÿ≠ÿØ ÿ£ŸÇÿµŸâ ŸÑÿπÿØÿØ ÿßŸÑŸÜŸÇÿßÿ∑
              if (pointCount > 2000) break;
            }
          }
          
          if (rowPoints.length > 1) {
            // ÿßÿ™ÿ¨ÿßŸá ŸÖÿ™ÿπÿ±ÿ¨
            const reverse = (y / stepOver) % 2 !== 0;
            if (reverse) rowPoints.reverse();
            
            lines.push('G0 X' + rowPoints[0].x.toFixed(2) + ' Y' + rowPoints[0].y.toFixed(2));
            lines.push('G1 F' + laserSpeed.toFixed(0));
            
            for (let i = 0; i < rowPoints.length; i++) {
              const p = rowPoints[i];
              lines.push('G1 X' + p.x.toFixed(2) + ' Y' + p.y.toFixed(2));
            }
            
            totalLen += calculateRowLength(rowPoints);
          }
          
          if (pointCount > 2000) break;
        }

        lines.push('M5');
        lines.push('M30');

        const timeMin = totalLen / laserSpeed;
        document.getElementById('estTime').innerHTML = "‚è±Ô∏è ÿ™ŸÇÿØŸäÿ± ŸàŸÇÿ™ ÿßŸÑŸÑŸäÿ≤ÿ±: " + timeMin.toFixed(1) + " ÿØŸÇŸäŸÇÿ© | " + pointCount + " ŸÜŸÇÿ∑ÿ©";

        return lines.join('\n');
      } catch (error) {
        console.error('generateLaserEngraveGcode error', error);
        throw new Error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ÿßŸÑŸÑŸäÿ≤ÿ±: ' + error.message);
      }
    }

    function generateLaserQuickGcode() {
      if (!grayMat || !contour) {
        throw new Error("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿµŸàÿ±ÿ© ÿ¨ÿßŸáÿ≤ÿ© ŸÑŸÑŸÖÿπÿßŸÑÿ¨ÿ©");
      }

      try {
        const laserPower = 80; // ÿ´ÿßÿ®ÿ™ ÿπŸÑÿ¥ÿßŸÜ ÿßŸÑÿ≥ÿ±ÿπŸá
        const laserSpeed = 3000; // ÿ£ÿ≥ÿ±ÿπ

        const workWidth = cmToMm(parseFloat(document.getElementById('laserWorkWidth').value) || 30);
        const workHeight = cmToMm(parseFloat(document.getElementById('laserWorkHeight').value) || 20);
        const originX = cmToMm(parseFloat(document.getElementById('laserOriginX').value) || 0);
        const originY = cmToMm(parseFloat(document.getElementById('laserOriginY').value) || 0);

        const lines = [];
        lines.push('G21 G90');
        lines.push('G0 X0 Y0');
        lines.push('M3 S800'); // ŸÇŸàÿ© ÿ´ÿßÿ®ÿ™ÿ©
        
        const scaleX = workWidth / previewCanvas.width;
        const scaleY = workHeight / previewCanvas.height;
        
        // ÿ•ÿπÿØÿßÿØÿßÿ™ ÿ≥ÿ±Ÿäÿπÿ© ÿ¨ÿØÿßŸã
        const stepOver = 5.0;
        let totalLen = 0;
        let pointCount = 0;

        for (let y = 0; y < previewCanvas.height; y += stepOver) {
          const rowPoints = [];
          
          for (let x = 0; x < previewCanvas.width; x += 5) {
            const pt = new cv.Point(x, y);
            const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
            
            if (inside) {
              const scaledX = (x * scaleX) + originX;
              const scaledY = (y * scaleY) + originY;
              rowPoints.push({ x: scaledX, y: scaledY });
              pointCount++;
              
              if (pointCount > 1000) break;
            }
          }
          
          if (rowPoints.length > 1) {
            const reverse = (y / stepOver) % 2 !== 0;
            if (reverse) rowPoints.reverse();
            
            lines.push('G0 X' + rowPoints[0].x.toFixed(2) + ' Y' + rowPoints[0].y.toFixed(2));
            lines.push('G1 F' + laserSpeed.toFixed(0));
            
            for (let i = 0; i < rowPoints.length; i++) {
              const p = rowPoints[i];
              lines.push('G1 X' + p.x.toFixed(2) + ' Y' + p.y.toFixed(2));
            }
            
            totalLen += calculateRowLength(rowPoints);
          }
          
          if (pointCount > 1000) break;
        }

        lines.push('M5');
        lines.push('M30');

        document.getElementById('estTime').innerHTML = "‚è±Ô∏è Ÿàÿ∂ÿπ ÿ≥ÿ±Ÿäÿπ: " + pointCount + " ŸÜŸÇÿ∑ÿ©";

        return lines.join('\n');
      } catch (error) {
        console.error('generateLaserQuickGcode error', error);
        throw new Error('ŸÅÿ¥ŸÑ ŸÅŸä ÿßŸÑÿ™ŸàŸÑŸäÿØ ÿßŸÑÿ≥ÿ±Ÿäÿπ: ' + error.message);
      }
    }

    function generateLaserCutGcode() {
      if (!grayMat || !contour) {
        throw new Error("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ÿ≠ŸàÿßŸÅ ŸÑÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ÿßŸÑŸÇÿµ");
      }

      try {
        InputValidator.validateLaserSettings();
        
        const laserPower = parseInt(document.getElementById('laserPower').value) || 80;
        const laserSpeed = parseInt(document.getElementById('laserSpeed').value) || 1000;
        const laserPasses = parseInt(document.getElementById('laserPasses').value) || 1;
        const airAssist = document.getElementById('laserAirAssist').checked;

        const workWidth = cmToMm(parseFloat(document.getElementById('laserWorkWidth').value) || 30);
        const workHeight = cmToMm(parseFloat(document.getElementById('laserWorkHeight').value) || 20);
        const originX = cmToMm(parseFloat(document.getElementById('laserOriginX').value) || 0);
        const originY = cmToMm(parseFloat(document.getElementById('laserOriginY').value) || 0);
        const scaleX = workWidth / previewCanvas.width;
        const scaleY = workHeight / previewCanvas.height;

        const lines = [];
        lines.push('G21 G90');
        if (airAssist) lines.push('M8');

        const contoursToUse = [contour, ...additionalContours.map(c => c.contour)];
        let totalLen = 0;

        for (let pass = 0; pass < laserPasses; pass++) {
          for (const cnt of contoursToUse) {
            const data = cnt.data32S;
            if (!data || data.length < 4) continue;

            let x0 = data[0], y0 = data[1];
            const startX = (x0 * scaleX + originX).toFixed(2);
            const startY = (y0 * scaleY + originY).toFixed(2);

            lines.push(`G0 X${startX} Y${startY}`);
            lines.push(`M3 S${Math.round(laserPower * 10)}`);
            lines.push(`G1 F${laserSpeed.toFixed(0)}`);

            for (let i = 2; i < data.length; i += 2) {
              const x = data[i], y = data[i + 1];
              const px = (x * scaleX + originX).toFixed(2);
              const py = (y * scaleY + originY).toFixed(2);
              lines.push(`G1 X${px} Y${py}`);
              totalLen += Math.hypot(x - x0, y - y0);
              x0 = x; y0 = y;
            }

            lines.push(`G1 X${startX} Y${startY}`);
            lines.push('M5');
          }
        }

        if (airAssist) lines.push('M9');
        lines.push('M30');

        const timeMin = totalLen / laserSpeed;
        document.getElementById('estTime').innerHTML = "‚è±Ô∏è ÿ™ŸÇÿØŸäÿ± ŸàŸÇÿ™ ÿßŸÑŸÇÿµ: " + timeMin.toFixed(1) + " ÿØŸÇŸäŸÇÿ©";

        return lines.join('\n');

      } catch (error) {
        console.error('generateLaserCutGcode error', error);
        throw new Error('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ŸÇÿµ ÿßŸÑŸÑŸäÿ≤ÿ±: ' + error.message);
      }
    }

    // ================= Buttons =================
    document.getElementById('btnGen').addEventListener('click', () => {
      taskManager.addTask(() => {
        const gcode = generateRasterGcode(false);
        document.getElementById('gcodeOut').value = gcode;
        lastGeneratedGcode = gcode;
        if (gcode) {
          showToast("ÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ G-code (Raster)");
          renderTopViewFromGcode(gcode);
          document.querySelector('.tab-buttons button[data-tab="simulation"]').click();
        }
        return gcode;
      }, 'ÿ™ŸàŸÑŸäÿØ G-code (Raster)');
    });

    document.getElementById('btnQuick').addEventListener('click', () => {
      taskManager.addTask(() => {
        const gcode = generateRasterGcode(true);
        document.getElementById('gcodeOut').value = gcode;
        lastGeneratedGcode = gcode;
        if (gcode) {
          showToast("ÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ G-code ÿ≥ÿ±Ÿäÿπ (Raster)");
          renderTopViewFromGcode(gcode);
          document.querySelector('.tab-buttons button[data-tab="simulation"]').click();
        }
        return gcode;
      }, 'ÿ™ŸàŸÑŸäÿØ G-code ÿ≥ÿ±Ÿäÿπ');
    });

    document.getElementById('btnContour').addEventListener('click', () => {
      taskManager.addTask(() => {
        const gcode = generateContourGcode();
        document.getElementById('gcodeOut').value = gcode;
        lastGeneratedGcode = gcode;
        if (gcode) {
          showToast("ÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ G-code (Contour)");
          renderTopViewFromGcode(gcode);
          document.querySelector('.tab-buttons button[data-tab="simulation"]').click();
        }
        return gcode;
      }, 'ÿ™ŸàŸÑŸäÿØ G-code (Contour)');
    });

    // Laser buttons
    document.getElementById('btnLaserEngrave').addEventListener('click', () => {
      taskManager.addTask(() => {
        const gcode = generateLaserEngraveGcode();
        document.getElementById('gcodeOut').value = gcode;
        lastGeneratedGcode = gcode;
        if (gcode) {
          showToast("ÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ÿßŸÑŸÑŸäÿ≤ÿ± (ŸÜŸÇÿ¥)");
          renderTopViewFromGcode(gcode);
          document.querySelector('.tab-buttons button[data-tab="simulation"]').click();
        }
        return gcode;
      }, 'ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ÿßŸÑŸÑŸäÿ≤ÿ± (ŸÜŸÇÿ¥)');
    });

    document.getElementById('btnLaserQuick').addEventListener('click', () => {
      taskManager.addTask(() => {
        const gcode = generateLaserQuickGcode();
        document.getElementById('gcodeOut').value = gcode;
        lastGeneratedGcode = gcode;
        if (gcode) {
          showToast("ÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ÿßŸÑŸÑŸäÿ≤ÿ± ÿßŸÑÿ≥ÿ±Ÿäÿπ");
          renderTopViewFromGcode(gcode);
          document.querySelector('.tab-buttons button[data-tab="simulation"]').click();
        }
        return gcode;
      }, 'ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ÿßŸÑŸÑŸäÿ≤ÿ± ÿßŸÑÿ≥ÿ±Ÿäÿπ');
    });

    document.getElementById('btnLaserCut').addEventListener('click', () => {
      taskManager.addTask(() => {
        const gcode = generateLaserCutGcode();
        document.getElementById('gcodeOut').value = gcode;
        lastGeneratedGcode = gcode;
        if (gcode) {
          showToast("ÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ÿßŸÑŸÑŸäÿ≤ÿ± (ŸÇÿµ)");
          renderTopViewFromGcode(gcode);
          document.querySelector('.tab-buttons button[data-tab="simulation"]').click();
        }
        return gcode;
      }, 'ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ÿßŸÑŸÑŸäÿ≤ÿ± (ŸÇÿµ)');
    });

    document.getElementById('btnDownload').addEventListener('click', () => {
      const text = document.getElementById('gcodeOut').value;
      if (!text) { 
        showToast("ŸÑÿß ŸäŸàÿ¨ÿØ G-code ŸÑÿ™ÿ≠ŸÖŸäŸÑŸá"); 
        return; 
      }
      try {
        const now = new Date();
        const dateStr = now.toISOString().slice(0, 19).replace(/[:.]/g, '-');
        const machineType = document.getElementById('machineCategory').value;
        const filename = `${machineType}_output_${dateStr}.gcode`;
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; 
        a.download = filename; 
        document.body.appendChild(a); 
        a.click(); 
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast(`ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÑŸÅ: ${filename}`);
      } catch (error) {
        console.error('file download error', error);
        showToast('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÑŸÅ');
      }
    });

    document.getElementById('btnLaserDownload').addEventListener('click', () => {
      document.getElementById('btnDownload').click();
    });

    document.getElementById('btnCenterOrigin').addEventListener('click', () => {
      const workWidth = parseFloat(document.getElementById('workWidth').value) || 0;
      const workHeight = parseFloat(document.getElementById('workHeight').value) || 0;
      document.getElementById('originX').value = (workWidth / 2).toFixed(1);
      document.getElementById('originY').value = (workHeight / 2).toFixed(1);
      showToast("ÿ™ŸÖ ÿ™Ÿàÿ≥Ÿäÿ∑ ŸÜŸÇÿ∑ÿ© ÿßŸÑÿ£ÿµŸÑ");
    });

    // keyboard shortcuts
    document.addEventListener('keydown', function (e) {
      if (e.ctrlKey || e.metaKey) {
        switch (e.key.toLowerCase()) {
          case 'g': 
            e.preventDefault(); 
            if (document.getElementById('machineCategory').value === 'laser') {
              document.getElementById('btnLaserEngrave').click();
            } else {
              document.getElementById('btnGen').click();
            }
            break;
          case 'r': 
            e.preventDefault(); 
            if (document.getElementById('machineCategory').value === 'laser') {
              document.getElementById('btnLaserQuick').click();
            } else {
              document.getElementById('btnQuick').click();
            }
            break;
          case 'd': e.preventDefault(); document.getElementById('btnDownload').click(); break;
          case '`': e.preventDefault(); document.getElementById('dbgToggleSize').click(); break;
        }
      }
    });

    // ================= Colormap Event Listeners =================
    document.querySelectorAll('#colormapButtons button').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('#colormapButtons button').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        currentColormap = btn.dataset.map;
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÄ heatmap ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿ∏ÿßŸáÿ±
        if (document.getElementById('heatmap').classList.contains('active')) {
          renderHeatmap();
        }
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÄ top view ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸáŸÜÿßŸÉ G-code
        if (lastGeneratedGcode) {
          renderTopViewFromGcode(lastGeneratedGcode);
        }
        
        // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑŸÄ contour view ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿ∏ÿßŸáÿ±
        if (document.getElementById('contour').classList.contains('active') && grayMat && contour) {
          renderContour(grayMat, contour);
        }
        
        showToast('ÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ŸÜŸÖŸàÿ∞ÿ¨ ÿßŸÑÿ£ŸÑŸàÿßŸÜ ÿ•ŸÑŸâ ' + currentColormap);
      });
    });

    // ================= Simulation 3D & Controls =================

    // ÿ•ÿ∂ÿßŸÅÿ© ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÉÿ™ÿ®ÿßÿ™
    function checkThreeJSLoaded() {
      if (typeof THREE === 'undefined') {
        throw new Error('THREE.js ÿ∫Ÿäÿ± ŸÖÿ≠ŸÖŸÑ');
      }
      
      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ OrbitControls
      if (typeof THREE.OrbitControls === 'undefined') {
        console.warn('OrbitControls ÿ∫Ÿäÿ± ŸÖÿ≠ŸÖŸÑ - ÿ≥ÿ™ÿπŸÖŸÑ ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ© ÿ®ÿØŸàŸÜ ÿ™ÿ≠ŸÉŸÖ ÿ®ÿßŸÑŸÉÿßŸÖŸäÿ±ÿß');
      }
      
      return true;
    }

    function parseGcodeForSimulation(gcode) {
      if (!gcode || gcode.length === 0) return [];
      
      const lines = gcode.split('\n');
      const path = [];
      let pos = { x: 0, y: 0, z: 0 };
      let pointCount = 0;
      const maxPoints = 2000; // ÿ™ŸÇŸÑŸäŸÑ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÑŸÑÿ£ÿØÿßÿ°
      
      for (let line of lines) {
        if (pointCount >= maxPoints) break;
        
        line = line.trim();
        if (!line || line.startsWith(';')) continue;
        
        if (line.startsWith('G0') || line.startsWith('G1')) {
          const xm = line.match(/X([-\d.]+)/i);
          const ym = line.match(/Y([-\d.]+)/i);
          const zm = line.match(/Z([-\d.]+)/i);
          
          if (xm) pos.x = parseFloat(xm[1]);
          if (ym) pos.y = parseFloat(ym[1]);
          if (zm) pos.z = parseFloat(zm[1]);
          
          // ÿ£ÿÆÿ∞ ÿπŸäŸÜÿßÿ™ ÿ£ŸÇŸÑ ŸÑŸÑÿ™ÿ≠ÿ≥ŸäŸÜ
          if (pointCount % 5 === 0) {
            path.push({ x: pos.x, y: pos.y, z: pos.z });
          }
          pointCount++;
        }
      }
      
      return path;
    }

    function createToolPathVisualization(pathPoints, dir) {
      if (!pathPoints || pathPoints.length < 2) return null;
      const points = pathPoints.map(p => new THREE.Vector3(p.x / 10, -p.z, p.y / 10));
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      let color = 0x10b981; // x
      if (dir === 'y') color = 0x3b82f6;
      if (dir === 'contour') color = 0xf59e0b;
      if (dir === 'laser') color = 0xff4444;
      const material = new THREE.LineBasicMaterial({ color: color });
      const line = new THREE.Line(geometry, material);
      return line;
    }

    function createToolModel() {
      const group = new THREE.Group();
      const bodyGeom = new THREE.CylinderGeometry(0.6, 0.6, 6, 12);
      const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff4444 });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      body.rotation.x = Math.PI / 2;
      group.add(body);
      const tipGeom = new THREE.ConeGeometry(0.8, 2.5, 12);
      const tipMat = new THREE.MeshPhongMaterial({ color: 0xffff00 });
      const tip = new THREE.Mesh(tipGeom, tipMat);
      tip.rotation.x = Math.PI / 2;
      tip.position.z = 4;
      group.add(tip);
      group.scale.set(1.5,1.5,1.5);
      return group;
    }

    function createLaserToolModel() {
      const group = new THREE.Group();
      const bodyGeom = new THREE.CylinderGeometry(0.4, 0.4, 8, 12);
      const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff4444 });
      const body = new THREE.Mesh(bodyGeom, bodyMat);
      body.rotation.x = Math.PI / 2;
      group.add(body);
      const lensGeom = new THREE.CylinderGeometry(0.6, 0.6, 1, 16);
      const lensMat = new THREE.MeshPhongMaterial({ color: 0x00ffff });
      const lens = new THREE.Mesh(lensGeom, lensMat);
      lens.rotation.x = Math.PI / 2;
      lens.position.z = 4.5;
      group.add(lens);
      group.scale.set(1.2,1.2,1.2);
      return group;
    }

    // ÿØÿßŸÑÿ© ŸÖÿ≥ÿßÿπÿØÿ© ŸÑÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ©
    function cleanupSimulation() {
      simulation.isPlaying = false;
      simulation.animationFrame && cancelAnimationFrame(simulation.animationFrame);
      simulation.animationFrame = null;
      simulation.index = 0;
      simulation.pathPoints = [];
      
      if (controls) {
        controls.dispose();
        controls = null;
      }
      
      if (renderer) {
        try {
          if (renderer.domElement && renderer.domElement.parentNode) {
            renderer.domElement.parentNode.removeChild(renderer.domElement);
          }
          renderer.dispose();
          renderer = null;
        } catch (e) {
          console.warn('Error disposing renderer:', e);
        }
      }
      
      scene = null;
      camera = null;
      simulation.tool = null;
      simulation.toolPath = null;
    }

    // Simulation controls UI will be created inside the three container
    function addSimulationControls(container) {
      const old = container.querySelector('.sim-controls');
      if (old) old.remove();
      const oldInfo = container.querySelector('.sim-progress');
      if (oldInfo) oldInfo.remove();

      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'sim-controls';
      controlsDiv.innerHTML = `
        <button id="simPlay">‚ñ∂</button><button id="simPause">‚è∏</button><button id="simReset">‚èÆ</button>
        <label style="color:#cfeaf2;font-size:12px;margin-left:6px">ÿ≥ÿ±ÿπÿ©</label>
        <input id="simSpeed" type="range" min="0.2" max="3" step="0.1" value="${simulation.speed}" style="width:120px">
        <span id="simSpeedLabel" style="min-width:36px;text-align:center">${simulation.speed.toFixed(1)}x</span>
      `;
      container.appendChild(controlsDiv);

      const prog = document.createElement('div');
      prog.className = 'sim-progress';
      prog.innerHTML = `ÿßŸÑÿ≠ÿßŸÑÿ©: <span id="simStatus">ÿ¨ÿßŸáÿ≤</span> ‚Äî ÿ™ŸÇÿØŸÖ: <span id="simProgress">0%</span>`;
      container.appendChild(prog);

      // Events
      document.getElementById('simPlay').addEventListener('click', () => {
        if (!simulation.pathPoints || simulation.pathPoints.length === 0) return;
        if (!simulation.isPlaying) {
          simulation.isPlaying = true;
          animateSimPath();
          document.getElementById('simStatus').textContent = 'ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ™ÿ¥ÿ∫ŸäŸÑ';
          showToast('ÿ®ÿØÿ£ÿ™ ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ©');
        }
      });
      document.getElementById('simPause').addEventListener('click', () => {
        if (simulation.isPlaying) {
          simulation.isPlaying = false;
          cancelAnimationFrame(simulation.animationFrame);
          document.getElementById('simStatus').textContent = 'ŸÖÿ™ŸàŸÇŸÅ';
          showToast('ÿ£ŸÇŸÅŸÑÿ™ ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ© ŸÖÿ§ŸÇÿ™ÿßŸã');
        }
      });
      document.getElementById('simReset').addEventListener('click', () => {
        simulation.isPlaying = false;
        cancelAnimationFrame(simulation.animationFrame);
        simulation.index = 0;
        simulation.elapsedTime = 0;
        updateToolPosition(0);
        document.getElementById('simProgress').textContent = '0%';
        document.getElementById('simStatus').textContent = 'ÿ¨ÿßŸáÿ≤';
        showToast('ÿ™ŸÖ ÿ•ÿπÿßÿØÿ© ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ©');
      });

      const speedSlider = document.getElementById('simSpeed');
      const speedLabel = document.getElementById('simSpeedLabel');
      speedSlider.addEventListener('input', (e) => {
        simulation.speed = parseFloat(e.target.value);
        speedLabel.textContent = simulation.speed.toFixed(1) + 'x';
      });
    }

    function animateSimPath() {
      if (!simulation.pathPoints || simulation.pathPoints.length === 0) return;
      const total = simulation.pathPoints.length;
      function step() {
        if (!simulation.isPlaying) return;
        simulation.index += simulation.speed;
        if (simulation.index >= total) {
          simulation.index = total - 1;
          updateToolPosition(simulation.index);
          document.getElementById('simProgress').textContent = '100%';
          document.getElementById('simStatus').textContent = 'ŸÖŸÉÿ™ŸÖŸÑ';
          simulation.isPlaying = false;
          cancelAnimationFrame(simulation.animationFrame);
          showToast('ÿßŸÉÿ™ŸÖŸÑÿ™ ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ©');
          return;
        }
        updateToolPosition(simulation.index);
        const prog = ((Math.floor(simulation.index) + 1) / total) * 100;
        document.getElementById('simProgress').textContent = prog.toFixed(1) + '%';
        simulation.animationFrame = requestAnimationFrame(step);
      }
      if (!simulation.animationFrame) step();
    }

    function updateToolPosition(index) {
      if (!simulation.tool || !simulation.pathPoints || simulation.pathPoints.length === 0) return;
      const i = Math.floor(index);
      const p = simulation.pathPoints[i];
      if (!p) return;
      simulation.tool.position.set(p.x / 10, -p.z, p.y / 10);
    }

    function initSimulation() {
      const container = document.getElementById('threeContainer');
      
      // ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖŸÉÿ™ÿ®ÿßÿ™
      if (!checkThreeJSLoaded()) {
        showToast('ÿßŸÑŸÖŸÉÿ™ÿ®ÿßÿ™ ÿ´ŸÑÿßÿ´Ÿäÿ© ÿßŸÑÿ£ÿ®ÿπÿßÿØ ÿ∫Ÿäÿ± ÿ¨ÿßŸáÿ≤ÿ©. ÿ¨ÿßÿ±Ÿä ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ...');
        setTimeout(initSimulation, 1000);
        return;
      }
      
      // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ© ÿßŸÑÿ≥ÿßÿ®ŸÇÿ© ÿ®ÿ¥ŸÉŸÑ ŸÉÿßŸÖŸÑ
      cleanupSimulation();
      
      const placeholder = document.getElementById('simulationPlaceholder');
      if (placeholder) placeholder.style.display = 'none';

      try {
        const gcode = document.getElementById('gcodeOut').value;
        if (!gcode || gcode.trim().length === 0) {
          showToast('ŸÑÿß ŸäŸàÿ¨ÿØ G-code ŸÑŸÑŸÖÿ≠ÿßŸÉÿßÿ©');
          if (placeholder) placeholder.style.display = 'flex';
          return;
        }

        // ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÖÿ¥ŸáÿØ
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x081224);

        const containerW = container.clientWidth || 800;
        const containerH = container.clientHeight || 400;
        
        camera = new THREE.PerspectiveCamera(60, containerW / containerH, 0.1, 2000);
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ 
          antialias: false,
          preserveDrawingBuffer: true // ŸÑŸÑŸÖÿ≥ÿßÿπÿØÿ© ŸÅŸä ÿßŸÑÿ£ÿØÿßÿ°
        });
        renderer.setSize(containerW, containerH);
        container.appendChild(renderer.domElement);

        // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ OrbitControls ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖÿ™ÿßÿ≠ÿßŸã
        if (typeof THREE.OrbitControls !== 'undefined') {
          try {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = false;
            controls.screenSpacePanning = true;
          } catch (e) {
            console.warn('Failed to initialize OrbitControls:', e);
          }
        }

        // ÿ•ÿ∂ÿßÿ°ÿ© ŸÖÿ®ÿ≥ÿ∑ÿ©
        const ambient = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambient);

        const isLaser = document.getElementById('machineCategory').value === 'laser';
        
        // ŸÖŸÜÿµÿ© ŸÖÿ®ÿ≥ÿ∑ÿ©
        const workWidth = isLaser ? 
          cmToMm(parseFloat(document.getElementById('laserWorkWidth').value) || 30) / 10 :
          cmToMm(parseFloat(document.getElementById('workWidth').value) || 30) / 10;
        const workHeight = isLaser ?
          cmToMm(parseFloat(document.getElementById('laserWorkHeight').value) || 20) / 10 :
          cmToMm(parseFloat(document.getElementById('workHeight').value) || 20) / 10;
        
        const platformGeometry = new THREE.BoxGeometry(workWidth, 0.5, workHeight);
        const platformMaterial = new THREE.MeshPhongMaterial({ 
          color: isLaser ? 0x666666 : 0x8B4513 
        });
        const platformMesh = new THREE.Mesh(platformGeometry, platformMaterial);
        platformMesh.position.set(workWidth/2, -0.25, workHeight/2);
        scene.add(platformMesh);

        // ŸÖÿ≥ÿßÿ± ŸÖÿ®ÿ≥ÿ∑
        const pathPoints = parseGcodeForSimulation(gcode);
        
        // ÿ•ÿ∞ÿß ŸÉÿßŸÜ ÿßŸÑŸÖÿ≥ÿßÿ± ŸÉÿ®Ÿäÿ± ÿ¨ÿØÿßŸãÿå ŸÜÿÆŸÅŸÅŸá ÿ£ŸÉÿ´ÿ±
        if (pathPoints.length > 3000) {
          const simplifiedPoints = [];
          for (let i = 0; i < pathPoints.length; i += 5) {
            simplifiedPoints.push(pathPoints[i]);
          }
          simulation.pathPoints = simplifiedPoints;
          showToast('ÿ™ŸÖ ÿ™ÿ®ÿ≥Ÿäÿ∑ ÿßŸÑŸÖÿ≥ÿßÿ± ÿ•ŸÑŸâ ' + simplifiedPoints.length + ' ŸÜŸÇÿ∑ÿ©');
        } else {
          simulation.pathPoints = pathPoints;
        }

        // ÿ•ŸÜÿ¥ÿßÿ° ŸÖÿ≥ÿßÿ± ŸÖÿ±ÿ¶Ÿä ŸÖÿ®ÿ≥ÿ∑
        if (simulation.pathPoints.length > 1) {
          const points = simulation.pathPoints.map(p => 
            new THREE.Vector3(p.x / 10, -p.z, p.y / 10)
          );
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          const material = new THREE.LineBasicMaterial({ 
            color: isLaser ? 0xff4444 : 0x10b981 
          });
          simulation.toolPath = new THREE.Line(geometry, material);
          scene.add(simulation.toolPath);
        }

        // ÿ£ÿØÿßÿ© ŸÖÿ®ÿ≥ÿ∑ÿ©
        const toolGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
        const toolMaterial = new THREE.MeshPhongMaterial({ 
          color: isLaser ? 0xff4444 : 0xffff00 
        });
        simulation.tool = new THREE.Mesh(toolGeometry, toolMaterial);
        simulation.tool.rotation.x = Math.PI / 2;
        scene.add(simulation.tool);

        // ÿ¥ÿ®ŸÉÿ© ŸÖÿ≥ÿßÿπÿØÿ©
        const gridHelper = new THREE.GridHelper(Math.max(workWidth, workHeight), 10);
        gridHelper.position.set(workWidth/2, 0, workHeight/2);
        scene.add(gridHelper);

        // ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ©
        simulation.index = 0;
        simulation.isPlaying = false;
        simulation.animationFrame = null;

        // ÿπŸÜÿßÿµÿ± ÿ™ÿ≠ŸÉŸÖ ŸÖÿ®ÿ≥ÿ∑ÿ©
        addSimulationControls(container);

        // ÿ≠ŸÑŸÇÿ© ÿßŸÑÿ™ÿµŸäŸäÿ±
        (function renderLoop() {
          requestAnimationFrame(renderLoop);
          if (controls) controls.update();
          renderer.render(scene, camera);
        })();

        showToast('ÿ™ŸÖ ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ©: ' + simulation.pathPoints.length + ' ŸÜŸÇÿ∑ÿ©');

      } catch (error) {
        console.error('initSimulation error', error);
        showToast('ŸÅÿ¥ŸÑ ŸÅŸä ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÖÿ≠ÿßŸÉÿßÿ©');
        if (placeholder) placeholder.style.display = 'flex';
      }
    }

    // ================= Top View rendering (colored + inverted Y + legend + colormap blending) =================
    function renderTopViewFromGcode(gcode) {
      try {
        if (!previewCanvas) return;
        const topCanvas = document.getElementById('topView');
        const legendDiv = document.getElementById('topLegend');
        const tw = previewCanvas.width, th = previewCanvas.height;
        topCanvas.width = tw; topCanvas.height = th;
        const ctx = topCanvas.getContext('2d');

        const depthMap = new Float32Array(tw * th);
        const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3.0;

        const points = parseGcodeForSimulation(gcode);

        const isLaser = document.getElementById('machineCategory').value === 'laser';
        
        // wood color base for router, dark platform for laser
        const baseRgb = isLaser ? { r: 40, g: 40, b: 40 } : hexToRgb(document.getElementById('woodColor').value || '#a0522d');
        const blackRgb = { r: 10, g: 6, b: 3 };

        // mm -> pixel mapping
        const workWidth = isLaser ? 
          cmToMm(parseFloat(document.getElementById('laserWorkWidth').value) || 30) :
          cmToMm(parseFloat(document.getElementById('workWidth').value) || 30);
        const workHeight = isLaser ?
          cmToMm(parseFloat(document.getElementById('laserWorkHeight').value) || 20) :
          cmToMm(parseFloat(document.getElementById('workHeight').value) || 20);
        const originX = isLaser ?
          cmToMm(parseFloat(document.getElementById('laserOriginX').value) || 0) :
          cmToMm(parseFloat(document.getElementById('originX').value) || 0);
        const originY = isLaser ?
          cmToMm(parseFloat(document.getElementById('laserOriginY').value) || 0) :
          cmToMm(parseFloat(document.getElementById('originY').value) || 0);

        function mmToPixel(px_mm_x, px_mm_y) {
          const xRatio = (px_mm_x - originX) / workWidth;
          const yRatio = (px_mm_y - originY) / workHeight;
          const xPix = Math.round(xRatio * (tw - 1));
          // invert Y to match visual orientation
          const yPix = th - 1 - Math.round(yRatio * (th - 1));
          return { x: xPix, y: yPix };
        }

        // init depth map
        for (let i=0;i<depthMap.length;i++) depthMap[i]=0;

        // If no points, fallback to grayscale->depth using image
        if (!points || points.length === 0) {
          const imgData = ctx.createImageData(tw, th);
          for (let y=0;y<th;y++){
            for (let x=0;x<tw;x++){
              const v = sampleGrayAt(x,y);
              const depth = ((255 - v)/255.0)*maxDepth;
              const t = depth / maxDepth; // 0..1
              // colormap color
              const cmapCol = getColormapColor(t, currentColormap);
              // blend: base mixed with cmap color
              const mixed1 = mixColors(baseRgb, blackRgb, t*0.6);
              const finalCol = mixColors(mixed1, cmapCol, isLaser ? 0.5 : 0.35);
              const idx = (y*tw + x)*4;
              imgData.data[idx]=finalCol.r; imgData.data[idx+1]=finalCol.g; imgData.data[idx+2]=finalCol.b; imgData.data[idx+3]=255;
            }
          }
          ctx.putImageData(imgData,0,0);
          drawTopLegend(currentColormap);
          return;
        }

        // accumulate depths from gcode points
        for (let i=0;i<points.length;i++) {
          const p = points[i];
          if (typeof p.x === 'undefined') continue;
          const coords = mmToPixel(p.x, p.y);
          if (coords.x < 0 || coords.x >= tw || coords.y < 0 || coords.y >= th) continue;
          const depth = isLaser ? Math.abs(p.z) : Math.min(Math.abs(p.z), maxDepth);
          const idx = coords.y * tw + coords.x;
          depthMap[idx] = Math.max(depthMap[idx], depth);
          const spread = isLaser ? 1 : 2;
          for (let oy=-spread; oy<=spread; oy++) {
            for (let ox=-spread; ox<=spread; ox++) {
              const nx = coords.x + ox, ny = coords.y + oy;
              if (nx<0||nx>=tw||ny<0||ny>=th) continue;
              const nIdx = ny*tw + nx;
              const weight = Math.max(0, 1 - (Math.hypot(ox,oy) / (spread + 0.1)));
              depthMap[nIdx] = Math.max(depthMap[nIdx], depth * weight);
            }
          }
        }

        const imgData = ctx.createImageData(tw, th);
        for (let y=0;y<th;y++) {
          for (let x=0;x<tw;x++) {
            const idx = y*tw + x;
            const d = Math.min(depthMap[idx], maxDepth);
            const t = (maxDepth === 0) ? 0 : (d / maxDepth); // 0..1
            const cmapCol = getColormapColor(t, currentColormap);
            const mixed1 = mixColors(baseRgb, blackRgb, t*0.6);
            const finalCol = mixColors(mixed1, cmapCol, isLaser ? 0.5 : 0.35);
            const di = (y*tw + x)*4;
            imgData.data[di] = finalCol.r;
            imgData.data[di+1] = finalCol.g;
            imgData.data[di+2] = finalCol.b;
            imgData.data[di+3] = 255;
          }
        }
        ctx.putImageData(imgData, 0, 0);

        // draw legend gradient for current colormap
        drawTopLegend(currentColormap);

      } catch (e) {
        console.error('renderTopViewFromGcode error', e);
      }
    }

    function drawTopLegend(map) {
      try {
        const legend = document.getElementById('topLegend');
        // create simple gradient css from colormap: sample t=0..1
        const steps = 6;
        const stops = [];
        for (let i=0;i<=steps;i++){
          const t = i / steps;
          const c = getColormapColor(t, map);
          stops.push(`rgb(${c.r},${c.g},${c.b}) ${Math.round((i/steps)*100)}%`);
        }
        legend.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
      } catch(e){}
    }

    // ================= Init UI and bindings =================
    document.addEventListener('DOMContentLoaded', () => {
      updateDimensionDisplay();
      showToast('ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ ÿ®ŸÜÿ¨ÿßÿ≠', 1200);
      
      // ŸÖŸÜÿπ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑŸÖÿ≤ÿØŸàÿ¨ ŸÑŸÑÿµŸàÿ±
      document.getElementById('fileInput').addEventListener('click', function(e) {
        this.value = ''; // Reset file input
      });
      
      // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ£ÿ®ÿπÿßÿØ ŸÖÿπ ÿ™ÿ£ÿÆŸäÿ± ŸÑŸÖŸÜÿπ ÿßŸÑÿ™ŸÉÿ±ÿßÿ±
      let updateTimeout;
      const updateDim = () => {
        clearTimeout(updateTimeout);
        updateTimeout = setTimeout(updateDimensionDisplay, 200);
      };
      
      document.getElementById('workWidth').addEventListener('input', updateDim);
      document.getElementById('workHeight').addEventListener('input', updateDim);
      document.getElementById('laserWorkWidth').addEventListener('input', updateDim);
      document.getElementById('laserWorkHeight').addEventListener('input', updateDim);

      const machineDefaults = {
        router: { feed: 800, safeZ: 5, maxDepth: 3, stepOver: 5, description: "CNC Router - ŸÑŸÑŸÜÿ≠ÿ™ ÿπŸÑŸâ ÿßŸÑÿÆÿ¥ÿ® ŸàÿßŸÑŸÖÿπÿßÿØŸÜ" },
        laser: { feed: 2000, safeZ: 0, maxDepth: 0, stepOver: 0.2, description: "Laser Engraver - ŸÑŸÑŸÜŸÇÿ¥ ŸàÿßŸÑŸÇÿµ ÿ®ÿßŸÑŸÑŸäÿ≤ÿ±" }
      };
      
      document.getElementById('machineCategory').addEventListener('change', (e) => {
        const def = machineDefaults[e.target.value];
        if (def) {
          document.getElementById('feedRate').value = def.feed;
          document.getElementById('safeZ').value = def.safeZ;
          document.getElementById('maxDepth').value = def.maxDepth;
          document.getElementById('stepOver').value = def.stepOver;
          document.getElementById('laserSpeed').value = def.feed;
          showToast(`ÿ™ŸÖ ÿ™ÿ≠ŸÖŸäŸÑ ÿ•ÿπÿØÿßÿØÿßÿ™ ${e.target.value}`);
        }
      });
    });

    // resize three renderer & topView on window resize
    window.addEventListener('resize', () => {
      const container = document.getElementById('threeContainer');
      if (camera && renderer && container) {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }
      try {
        const top = document.getElementById('topView');
        if (previewCanvas && top) {
          top.width = previewCanvas.width; top.height = previewCanvas.height;
        }
      } catch(e){}
    });

    // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ∞ÿßŸÉÿ±ÿ© ÿπŸÜÿØ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿµŸÅÿ≠ÿ©
    window.addEventListener('beforeunload', () => {
      memoryManager.cleanupAll();
      cleanupSimulation();
    });

  </script>

<!-- === Added in v1.0.1 ‚Äî Non-intrusive UI & helper enhancements === -->
<script>
(function(){
  'use strict';
  // Safety: do not modify existing functions; add helpers only

  // ----- px -> mm unified conversion -----
  function getWorkDimsMm() {
    const workWidthCm = parseFloat(document.getElementById('workWidth')?.value || document.getElementById('laserWorkWidth')?.value || 0);
    const workHeightCm = parseFloat(document.getElementById('workHeight')?.value || document.getElementById('laserWorkHeight')?.value || 0);
    return { workWidthMm: workWidthCm * 10, workHeightMm: workHeightCm * 10 };
  }

  window.pxToMm = function(x, y) {
    try {
      if (!window.grayMat) return { mmX: x, mmY: y };
      const dims = getWorkDimsMm();
      const gw = window.grayMat.cols || 1;
      const gh = window.grayMat.rows || 1;
      const pxToMmX = (dims.workWidthMm || 1) / gw;
      const pxToMmY = (dims.workHeightMm || 1) / gh;
      return { mmX: x * pxToMmX, mmY: y * pxToMmY };
    } catch (e) {
      console.warn('pxToMm failed', e);
      return { mmX: x, mmY: y };
    }
  };

  // ----- Save / restore settings (safe, non-intrusive) -----
  function collectInputs() {
    const inputs = document.querySelectorAll('input, select, textarea');
    const data = {};
    inputs.forEach(i => {
      if (!i.id) return;
      if (i.type === 'checkbox') data[i.id] = i.checked;
      else data[i.id] = i.value;
    });
    return data;
  }
  function applySettings(data) {
    if (!data) return;
    for (const key in data) {
      try {
        const el = document.getElementById(key);
        if (!el) continue;
        if (el.type === 'checkbox') el.checked = !!data[key];
        else el.value = data[key];
      } catch(e){}
    }
    // update dimension displays if present
    try { if (window.updateDimensionDisplay) window.updateDimensionDisplay(); } catch(e){}
  }

  window.saveCncAiSettings = function() {
    try {
      const data = collectInputs();
      localStorage.setItem('CncAi_Settings_v1.0.1', JSON.stringify(data));
      console.log('CncAi settings saved');
    } catch(e){ console.warn('save settings error', e); }
  };
  window.restoreCncAiSettings = function() {
    try {
      const raw = localStorage.getItem('CncAi_Settings_v1.0.1');
      if (!raw) return;
      const data = JSON.parse(raw);
      applySettings(data);
      console.log('CncAi settings restored');
    } catch(e){ console.warn('restore settings error', e); }
  };

  window.addEventListener('load', function(){ try{ restoreCncAiSettings(); } catch(e){} });
  window.addEventListener('beforeunload', function(){ try{ saveCncAiSettings(); } catch(e){} });

  // ----- Safe timing wrapper for tasks -----
  (function enhanceTaskTiming(){
    try {
      if (!window.TaskManager) return;
      const TP = TaskManager.prototype;
      if (!TP) return;
      // Create storage for timings
      window._cncTaskTimings = window._cncTaskTimings || [];
      const originalAdd = TP.addTask;
      TP.addTask = function(taskFn, description='ŸÖŸáŸÖÿ©') {
        // Wrap the taskFn so timing is measured per-task without altering original semantics
        const wrapped = async () => {
          const label = `task:${description}:${Date.now()}`;
          console.time(label);
          const start = performance.now ? performance.now() : Date.now();
          try {
            const res = await taskFn();
            return res;
          } finally {
            const end = performance.now ? performance.now() : Date.now();
            console.timeEnd(label);
            window._cncTaskTimings.push({ description, durationMs: Math.round(end - start), ts: new Date().toISOString() });
            // keep only recent 200 entries
            if (window._cncTaskTimings.length > 200) window._cncTaskTimings.shift();
          }
        };
        return originalAdd.call(this, wrapped, description);
      };
    } catch(e) { console.warn('enhanceTaskTiming failed', e); }
  })();

  // ----- Debug Overlay: performance panel -----
  function ensurePerfPanel() {
    try {
      const overlay = document.getElementById('debugOverlay');
      if (!overlay) return;
      let perf = document.getElementById('cncPerfPanel');
      if (!perf) {
        perf = document.createElement('div');
        perf.id = 'cncPerfPanel';
        perf.style.padding = '8px';
        perf.style.borderTop = '1px solid rgba(255,255,255,0.02)';
        perf.style.fontSize = '12px';
        perf.style.color = '#cfeaf2';
        overlay.appendChild(perf);
      }
      // update loop
      setInterval(()=>{
        try {
          const timings = window._cncTaskTimings || [];
          const last = timings.slice(-5);
          const avg = timings.length ? Math.round(timings.reduce((s,t)=>s+t.durationMs,0)/timings.length) : 0;
          perf.innerHTML = `<div style="opacity:0.9"><b>üìä ÿ£ÿØÿßÿ°</b> ‚Äî ÿ•ÿ¨ŸÖÿßŸÑŸä ÿ≥ÿ¨ŸÑÿßÿ™: ${timings.length} ‚Äî ŸÖÿ™Ÿàÿ≥ÿ∑: ${avg} ms</div>` +
                           `<div style="margin-top:6px;line-height:1.2;"><b>ÿ¢ÿÆÿ± ÿßŸÑŸÖŸáÿßŸÖ:</b> ${last.map(l=>`${l.description} (${l.durationMs}ms)`).join(' ‚Ä¢ ')}</div>`;
        } catch(e){}
      }, 1500);
    } catch(e){ console.warn('ensurePerfPanel error', e); }
  }
  window.addEventListener('load', ensurePerfPanel);

  // ----- Legend for TopView (non-intrusive) -----
  function addDepthLegend() {
    try {
      if (document.getElementById('depthLegend')) return;
      const container = document.getElementById('topViewContainer') || document.body;
      const legend = document.createElement('canvas');
      legend.id = 'depthLegend';
      legend.width = 220;
      legend.height = 24;
      legend.style.border = '1px solid rgba(255,255,255,0.03)';
      legend.style.borderRadius = '6px';
      legend.style.marginTop = '8px';
      legend.title = 'ŸÖŸÇŸäÿßÿ≥ ÿßŸÑÿπŸÖŸÇ (Z) ‚Äî ÿßŸÑÿ£ŸÑŸàÿßŸÜ ÿ™ÿ™ÿ®ÿπ ÿßÿÆÿ™Ÿäÿßÿ± Colormap';
      const ctx = legend.getContext('2d');
      // draw gradient based on known colormaps - approximate jet
      const grad = ctx.createLinearGradient(0,0,legend.width,0);
      grad.addColorStop(0, '#0000ff');
      grad.addColorStop(0.33, '#00ffff');
      grad.addColorStop(0.66, '#ffff00');
      grad.addColorStop(1, '#ff0000');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,legend.width,legend.height);
      ctx.fillStyle = '#cfeaf2';
      ctx.font = '12px sans-serif';
      ctx.fillText('ÿπŸÖŸÇ Z (ŸÖŸÖ):', 4, legend.height + 12);
      // append after topViewContainer
      container.appendChild(legend);
    } catch(e){ console.warn('addDepthLegend', e); }
  }
  window.addEventListener('load', addDepthLegend);

  // ----- Improved toasts (stacking, types) -----
  (function initToasts(){
    try {
      let root = document.getElementById('cncToastsRoot');
      if (!root) {
        root = document.createElement('div');
        root.id = 'cncToastsRoot';
        root.style.position = 'fixed';
        root.style.right = '16px';
        root.style.bottom = '16px';
        root.style.zIndex = 40000;
        root.style.display = 'flex';
        root.style.flexDirection = 'column';
        root.style.gap = '8px';
        document.body.appendChild(root);
      }
      window._showCncToast = function(msg, type='info', timeout=3500) {
        try {
          const el = document.createElement('div');
          el.className = 'cnc-toast cnc-toast-' + type;
          el.style.padding = '8px 12px';
          el.style.borderRadius = '8px';
          el.style.minWidth = '180px';
          el.style.background = type === 'error' ? 'linear-gradient(90deg,#ff6b6b,#ff4444)' : (type==='warn' ? 'linear-gradient(90deg,#f5b041,#f39c12)' : 'linear-gradient(90deg,#06b6d4,#0284c7)');
          el.style.color = type === 'error' ? '#210' : '#021';
          el.style.boxShadow = '0 8px 24px rgba(2,6,23,0.6)';
          el.style.fontWeight = '600';
          el.textContent = msg;
          root.appendChild(el);
          setTimeout(()=>{ el.style.transition = 'opacity 0.35s'; el.style.opacity = '0'; setTimeout(()=>el.remove(), 400); }, timeout);
        } catch(e){ console.warn('toast show failed', e); }
      };
      // expose simple alias to existing showToast for backward compatibility
      window.showToast = window._showCncToast;
    } catch(e){}
  })();

  // ----- Smart tooltips: non-intrusive titles for inputs without title -----
  (function applySmartTooltips(){
    try {
      const labels = document.querySelectorAll('label');
      labels.forEach(l => {
        try {
          const forId = l.getAttribute('for');
          if (!forId) return;
          const target = document.getElementById(forId);
          if (!target) return;
          if (!target.title) {
            target.title = l.textContent.trim() + ' ‚Äî ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÑŸÖÿ≤ŸäÿØ';
          }
        } catch(e){}
      });
    } catch(e){}
  })();

  // Expose utilities for debugging
  window.CncAiHelpers = {
    saveSettings: window.saveCncAiSettings || function(){},
    restoreSettings: window.restoreCncAiSettings || function(){},
    pxToMm: window.pxToMm
  };

})(); // end IIFE
</script>
<!-- === End of v1.0.1 additions === -->


<!-- === Added in v1.0.2 ‚Äî Laser G-code improvements (gamma, safe transitions, pass comments) === -->
<script>
(function(){
  'use strict';
  // Non-intrusive enhanced laser G-code generator.
  async function generateLaserGcodeEnhanced() {
    try {
      if (!window.grayMat) {
        window.showToast && window.showToast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿµŸàÿ±ÿ© ŸÖÿ≠ŸÖŸëŸÑÿ© (grayMat)', 'error');
        return;
      }
      // Basic settings (with safe fallbacks)
      const feedrate = parseFloat(document.getElementById('laserSpeed')?.value) || 2000;
      const powerMax = parseFloat(document.getElementById('laserPower')?.value) || 80;
      const passes = parseInt(document.getElementById('laserPasses')?.value) || 1;
      const detail = parseInt(document.getElementById('laserDetail')?.value) || 5;
      const invert = document.getElementById('invertZ')?.checked || false; // not used directly but read
      const safeZ = parseFloat(document.getElementById('safeZ')?.value) || 5;

      // gamma correction parameter (optional UI element may exist)
      const gammaInput = document.getElementById('laserGamma');
      const gamma = gammaInput ? (parseFloat(gammaInput.value) || 1.2) : 1.2;

      const cols = window.grayMat.cols;
      const rows = window.grayMat.rows;
      if (!cols || !rows) {
        window.showToast && window.showToast('ÿÆÿ∑ÿ£ ŸÅŸä ÿ£ÿ®ÿπÿßÿØ ÿßŸÑÿµŸàÿ±ÿ© ÿßŸÑÿ±ŸÖÿßÿØŸäÿ©', 'error');
        return;
      }

      // Determine Y step from detail slider: higher detail => smaller step
      const stepY = Math.max(1, Math.ceil(10 / Math.max(1, detail)));

      let gcode = '';
      gcode += '; Generated by CncAi v1.0.2 (Laser enhanced)\n';
      gcode += '; Units: mm (G21) | Absolute coords (G90)\n';
      gcode += 'G21\nG90\n';
      gcode += 'M5 ; ensure laser off\n';

      // helper to map pixel to mm using existing pxToMm if available
      function pxToMmSafe(px, py) {
        try {
          if (window.pxToMm) return window.pxToMm(px, py);
          // fallback simple proportional mapping
          const workW = (parseFloat(document.getElementById('laserWorkWidth')?.value)||30)*10;
          const workH = (parseFloat(document.getElementById('laserWorkHeight')?.value)||20)*10;
          return { mmX: (px / Math.max(1, cols-1)) * workW, mmY: (py / Math.max(1, rows-1)) * workH };
        } catch(e){ return { mmX: px, mmY: py }; }
      }

      // iterate passes
      for (let pass = 1; pass <= passes; pass++) {
        gcode += `; --- pass ${pass} ---\n`;
        // For each raster row
        for (let py = 0; py < rows; py += stepY) {
          const rowIndex = py;
          const isForward = ((Math.floor(py / stepY) % 2) === 0);
          const startX = isForward ? 0 : cols - 1;
          const endX = isForward ? cols - 1 : 0;
          const dir = isForward ? 1 : -1;

          // move to start of row with laser off
          const startMm = pxToMmSafe(startX, rowIndex);
          gcode += `G0 X${startMm.mmX.toFixed(3)} Y${startMm.mmY.toFixed(3)}\n`;
          gcode += 'M5\n'; // ensure laser off during rapid move

          // Raster along the row, emitting G1 with S (power) and feed
          for (let ix = startX; (dir>0 ? ix<=endX : ix>=endX); ix += dir) {
            const idx = rowIndex * cols + ix;
            const val = window.grayMat.data ? (window.grayMat.data[idx] || 0) : 0;
            // normalized 0..1 (0=black,255=white). For engraving, darker => more power.
            const v = Math.max(0, Math.min(255, val)) / 255.0;
            const adjusted = Math.pow(1.0 - v, gamma); // darker -> larger
            const pwr = Math.round(adjusted * powerMax); // 0 .. powerMax

            const pt = pxToMmSafe(ix, rowIndex);
            // use G1 with S and feedrate. ensure numbers are reasonable
            gcode += `G1 X${pt.mmX.toFixed(3)} Y${pt.mmY.toFixed(3)} S${pwr.toFixed(0)} F${Math.round(feedrate)}\n`;
          }

          // end of row: ensure laser off before rapid move to next row
          gcode += 'M5\n';
        } // end rows
      } // end passes

      // finish
      gcode += 'M5 ; laser off\n';
      gcode += `; Safe Z: ${safeZ}\n`;
      gcode += 'G0 X0 Y0 ; return origin\n';

      // place into UI
      const outEl = document.getElementById('gcodeOut');
      if (outEl) outEl.value = gcode;
      window.lastGeneratedGcode = gcode;
      window.showToast && window.showToast('‚úÖ ÿ™ŸÖ ÿ™ŸàŸÑŸäÿØ G-code ŸÑŸÑŸëŸäÿ≤ÿ± (ŸÜÿ≥ÿÆÿ© ŸÖÿ≠ÿ≥ŸëŸÜÿ©)', 'info');
      return gcode;
    } catch (err) {
      console.error('generateLaserGcodeEnhanced error', err);
      window.showToast && window.showToast('ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ™ŸàŸÑŸäÿØ ŸÉŸàÿØ ÿßŸÑŸÑŸäÿ≤ÿ±: ' + (err.message||err), 'error');
      throw err;
    }
  }

  // Attach to existing UI buttons if present (non-destructive)
  function attachToButtons() {
    try {
      const btnEngrave = document.getElementById('btnLaserEngrave') || document.getElementById('btnLaserEngraveButton');
      if (btnEngrave) {
        btnEngrave.addEventListener('click', async function(ev){
          ev.preventDefault();
          await generateLaserGcodeEnhanced();
        });
      }
      const btnDownload = document.getElementById('btnLaserDownload');
      if (btnDownload) {
        btnDownload.addEventListener('click', function(){
          try {
            const content = window.lastGeneratedGcode || document.getElementById('gcodeOut')?.value || '';
            if (!content) { window.showToast && window.showToast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ G-code ŸÑŸÑÿ™ÿ≠ŸÖŸäŸÑ', 'warn'); return; }
            const blob = new Blob([content], {type:'text/plain'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'CncAi_laser_output.nc';
            document.body.appendChild(a);
            a.click();
            a.remove();
            window.showToast && window.showToast('‚¨áÔ∏è ÿ™ŸÖ ÿ™ŸÜÿ≤ŸäŸÑ ŸÖŸÑŸÅ G-code', 'info');
          } catch(e){ console.error(e); window.showToast && window.showToast('ŸÅÿ¥ŸÑ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ', 'error'); }
        });
      }
      // Quick button same behaviour but non-blocking
      const btnQuick = document.getElementById('btnLaserQuick');
      if (btnQuick) {
        btnQuick.addEventListener('click', function(ev){
          ev.preventDefault();
          // fire and forget, do not await to keep UI responsive for quick test
          generateLaserGcodeEnhanced().catch(e=>{});
        });
      }
    } catch(e){ console.warn('attachToButtons failed', e); }
  }

  // wait until DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attachToButtons);
  } else {
    attachToButtons();
  }

  // expose function for developers
  window.generateLaserGcodeEnhanced = generateLaserGcodeEnhanced;

})(); // end IIFE
</script>
<!-- === End of v1.0.2 laser improvements === -->

<!-- === CncAi v1.0.3: Smart Debug (Hybrid) + UI Animations === -->
<style>
/* üß† Debug overlay (hybrid mode: collapsed + expandable) */
#cnc_debug_hybrid {
  position: fixed;
  right: 12px;
  bottom: 12px;
  z-index: 70000;
  font-family: system-ui;
  transition: all .25s ease;
  box-shadow: 0 10px 30px rgba(0,0,0,.6);
}
#cnc_debug_hybrid .collapsed {
  background: linear-gradient(90deg,#021426,#063044);
  color: #bfefff;
  padding: 8px 10px;
  border-radius: 12px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  width: 48px;
  justify-content: center;
}
#cnc_debug_hybrid .collapsed .dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #06b6d4;
  box-shadow: 0 0 6px rgba(6,182,212,0.8);
}
#cnc_debug_hybrid .expanded {
  display: none;
  max-width: 420px;
  background: linear-gradient(180deg,#041a2a,#072235);
  color: #dff6ff;
  padding: 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.03);
}
#cnc_debug_hybrid.expanded {
  width: 420px;
}
#cnc_debug_hybrid.expanded .collapsed { display: none; }
#cnc_debug_hybrid.expanded .expanded { display: block; }

/* üß© Debug text area */
#cnc_debug_hybrid .expanded .title { font-weight: 700; margin-bottom: 6px }
#cnc_debug_hybrid .expanded pre {
  background: #021522;
  color: #dff6ff;
  padding: 8px;
  border-radius: 8px;
  max-height: 220px;
  overflow: auto;
  font-size: 12px;
}

/* ‚ú® Button animation */
.cnc-btn { transition: transform .12s ease, box-shadow .12s ease; }
.cnc-btn:active { transform: scale(.96); box-shadow: 0 6px 18px rgba(0,0,0,0.45) inset; }
.cnc-btn:hover { transform: translateY(-3px); }

/* üîî Toast messages */
.cnc-toast {
  position: fixed;
  left: 16px;
  bottom: 16px;
  z-index: 80000;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.cnc-toast .t {
  background: linear-gradient(90deg,#06b6d4,#0b84b8);
  color: #001;
  padding: 8px 12px;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.6);
  font-weight: 700;
  opacity: 0;
  transform: translateY(8px);
  transition: all .28s ease;
}
.cnc-toast .t.show { opacity: 1; transform: translateY(0); }

/* üöÄ Loading bar */
#cnc_loading_bar {
  position: fixed;
  left: 0;
  top: 0;
  height: 4px;
  background: linear-gradient(90deg,#00c3ff,#0078ff);
  width: 0;
  transition: width .3s ease;
  z-index: 90000;
}
</style>

<!-- üß† Debug Hybrid Widget -->
<div id="cnc_debug_hybrid" aria-hidden="false">
  <div class="collapsed" title="Open Debug">
    <div class="dot"></div>
  </div>
  <div class="expanded" role="dialog">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="title">Debug ‚Ä¢ ÿßŸÑÿ™ÿµÿ≠Ÿäÿ≠</div>
      <button id="cnc_debug_close" class="cnc-btn" style="background:transparent;border:0;color:#9fe9ff">‚úñ</button>
    </div>
    <div style="margin-top:8px"><small id="cnc_cv_state">CV: Loading...</small></div>
    <pre id="cnc_debug_pre">Logs...</pre>
    <div style="margin-top:8px;display:flex;gap:8px;justify-content:flex-end">
      <button id="cnc_debug_refresh" class="cnc-btn">Retry CV</button>
      <button id="cnc_debug_clear" class="cnc-btn">Clear</button>
    </div>
  </div>
</div>
<div id="cnc_loading_bar"></div>
<div class="cnc-toast" id="cnc_toast_root"></div>

<script>
(function(){
  const dbg = document.getElementById('cnc_debug_hybrid');
  const pre = document.getElementById('cnc_debug_pre');
  const cvStateEl = document.getElementById('cnc_cv_state');
  const loadingBar = document.getElementById('cnc_loading_bar');

  // ‚úÖ Toast messages
  function showToast(msg, time=2200){
    const root=document.getElementById('cnc_toast_root');
    const el=document.createElement('div'); el.className='t'; el.textContent=msg;
    root.appendChild(el);
    requestAnimationFrame(()=>el.classList.add('show'));
    setTimeout(()=>{el.classList.remove('show');setTimeout(()=>el.remove(),300);},time);
  }
  window.showToast=showToast;

  // ‚úÖ Log printer
  function log(msg){
    const t=new Date().toLocaleTimeString();
    pre.textContent='['+t+'] '+msg+'\\n'+pre.textContent;
  }
  window.appendDebug=log;

  // ‚úÖ Debug UI toggles
  dbg.querySelector('.collapsed').onclick=()=>dbg.classList.add('expanded');
  document.getElementById('cnc_debug_close').onclick=()=>dbg.classList.remove('expanded');
  document.getElementById('cnc_debug_clear').onclick=()=>{pre.textContent='';showToast('Logs cleared');};
  document.getElementById('cnc_debug_refresh').onclick=()=>{safeRetryCv();showToast('Retrying OpenCV...');};

  // ‚úÖ Loading bar
  function setLoad(p){loadingBar.style.width=p+'%';}
  window.setLoadingPct=setLoad;

  // ‚úÖ Safe retry OpenCV
  function safeRetryCv(){
    setLoad(10);
    let tries=0;
    const timer=setInterval(()=>{
      tries++; setLoad(tries*10);
      if(window.cv&&cv.Mat){clearInterval(timer);setLoad(100);showToast('OpenCV ready');log('OpenCV recovered');return;}
      if(tries>10){clearInterval(timer);setLoad(0);showToast('CV retry failed');log('OpenCV retry failed');}
    },600);
  }
  window.safeRetryCv=safeRetryCv;

  // ‚úÖ CV state updater
  function updateCV(){
    if(window.cv&&cv.Mat){cvStateEl.textContent='CV: Ready';cvStateEl.style.color='#8fffd1';}
    else{cvStateEl.textContent='CV: Not ready';cvStateEl.style.color='#ffbfbf';}
  }
  window.updateCvState=updateCV;

  // monitor CV status
  setInterval(updateCV,2000);
})();

<script>
/* üß† CncAi v1.0.3 - OpenCV Smart Integration Fix */
(function(){
  // ŸÖÿ±ÿßŸÇÿ®ÿ© ŸÜÿ∏ÿßŸÖ OpenCV ÿßŸÑŸÇÿØŸäŸÖ
  let retryCount = 0;
  const originalWarn = console.warn;
  console.warn = function(...args){
    try{
      const msg = args.join(' ');
      if(msg.includes('OpenCV test failed')) {
        retryCount++;
        if(window.appendDebug) appendDebug('Retry '+retryCount+' ‚Ä¢ CV not ready');
        if(retryCount > 3 && window.safeRetryCv) {
          appendDebug('Switching to Smart Debug retry...');
          safeRetryCv();
        }
      }
    }catch(e){}
    originalWarn.apply(console, args);
  };

  // ÿπŸÜÿØ ŸÜÿ¨ÿßÿ≠ ÿßŸÑÿ™ÿ≠ŸÖŸäŸÑ
  const originalLog = console.log;
  console.log = function(...args){
    if(args.join(' ').includes('OpenCV build info available')){
      if(window.appendDebug) appendDebug('‚úÖ OpenCV build info detected');
      if(window.updateCvState) updateCvState();
    }
    originalLog.apply(console, args);
  };

  // ŸÅÿ≠ÿµ ÿ™ŸÑŸÇÿßÿ¶Ÿä ŸÉŸÑ ÿ´ÿßŸÜŸäÿ™ŸäŸÜ
  setInterval(()=>{
    try{
      if(window.cv && cv.Mat){
        if(window.appendDebug) appendDebug('‚úÖ OpenCV operational');
        if(window.updateCvState) updateCvState();
      }
    }catch(e){}
  },2000);
})();
</script>

<!-- ‚úÖ Safe OpenCV CDN (confirmed JS source) -->
<script async src="https://rawcdn.githack.com/opencv/opencv/4.x/platforms/js/opencv.js" onload="onOpenCvReady()"></script>





  
<!-- === End of CncAi v1.0.3 injection === -->



  
  
</body>
</html>
