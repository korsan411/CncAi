<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CNC AI - النسخة المصححة والمحسنة</title>

  <!-- مكتبات خارجية -->
  <script src="https://cdn.jsdelivr.net/npm/clipper-lib@6.4.2/clipper.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.156.0/examples/js/controls/OrbitControls.js"></script>

  <style>
    body {
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: #f4f6fa;
      color: #222;
    }
    header {
      background: #1f78d1;
      color: #fff;
      padding: 10px;
      text-align: center;
      font-weight: bold;
      font-size: 18px;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 15px;
      padding: 15px;
    }
    canvas {
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 6px;
      max-width: 100%;
      display: block;
      margin: 5px 0;
    }
    .panel {
      background: #fff;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .btn {
      padding: 8px 12px;
      border: 0;
      border-radius: 6px;
      cursor: pointer;
      margin: 3px;
      transition: background 0.2s;
    }
    .btn-primary {
      background: #1f78d1;
      color: #fff;
    }
    .btn-primary:hover {
      background: #0d5db5;
    }
    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .gcode-output {
      background: #0b1220;
      color: #cfe8ff;
      font-family: monospace;
      font-size: 12px;
      height: 200px;
      overflow: auto;
      padding: 6px;
      border-radius: 6px;
      white-space: pre-wrap;
    }
    label {
      font-weight: bold;
      margin-top: 10px;
      display: block;
    }
    input[type=number] {
      width: 70px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    input[type=file] {
      width: 100%;
      margin: 5px 0;
    }
    hr {
      border: none;
      border-top: 1px solid #eee;
      margin: 15px 0;
    }
    h3 {
      margin-top: 0;
    }
    .status {
      padding: 5px;
      border-radius: 4px;
      margin: 5px 0;
      text-align: center;
    }
    .status.success {
      background: #d4edda;
      color: #155724;
    }
    .status.error {
      background: #f8d7da;
      color: #721c24;
    }
    .preview-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .preview-box {
      border: 1px solid #ccc;
      border-radius: 6px;
      padding: 10px;
      background: #fff;
    }
    @media (max-width: 900px) {
      .container {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
<header>🛠 CNC AI - النسخة المصححة والمحسنة</header>

<div class="container">
  <!-- يسار -->
  <div class="panel">
    <label>رفع صورة التصميم</label>
    <input id="fileInput" type="file" accept="image/*">
    
    <div id="statusArea"></div>

    <div>
      <button id="btnAnalyze" class="btn btn-primary" disabled>كشف الحواف</button>
      <button id="btnGeneratePaths" class="btn" disabled>توليد المحيطات</button>
      <button id="btnGenGcode" class="btn" disabled>توليد G-code</button>
      <button id="btnDownload" class="btn" disabled>تحميل G-code</button>
    </div>

    <div class="preview-container">
      <div class="preview-box">
        <label>معاينة 2D</label>
        <canvas id="preview2d" width="600" height="400"></canvas>
      </div>

      <div class="preview-box">
        <label>Heatmap (للـ Z)</label>
        <canvas id="heatmap" width="300" height="200"></canvas>
      </div>

      <div class="preview-box">
        <label>معاينة 3D</label>
        <div id="preview3d" style="width:100%;height:300px;background:#eee;border-radius:6px"></div>
      </div>
    </div>
  </div>

  <!-- يمين -->
  <div class="panel">
    <h3>إعدادات</h3>
    <label>عرض العمل (mm)</label>
    <input id="workWidth" type="number" value="300">

    <label>ارتفاع العمل (mm)</label>
    <input id="workHeight" type="number" value="200">

    <label>قطر الأداة (mm)</label>
    <input id="toolDia" type="number" value="3" step="0.1">

    <label>Stepover (%)</label>
    <input id="stepover" type="number" value="40">

    <label>أقصى عمق (mm)</label>
    <input id="maxDepth" type="number" value="3" step="0.1">

    <label>عمق كل مرور (mm)</label>
    <input id="passDepth" type="number" value="0.5" step="0.1">

    <label>Feed Rate</label>
    <input id="feedRate" type="number" value="800">

    <hr>
    <div>
      <label><input type="checkbox" id="startFromEdges" checked> بدء من الحواف</label><br>
      <label><input type="checkbox" id="useInfill" checked> تعبئة داخلية</label>
    </div>

    <hr>
    <label>G-code Output</label>
    <div id="gcodeOutput" class="gcode-output"></div>
  </div>
</div>

<script>
/* عناصر DOM */
const fileInput = document.getElementById('fileInput');
const preview2d = document.getElementById('preview2d');
const ctx2d = preview2d.getContext('2d');
const heatmap = document.getElementById('heatmap');
const ctxHeat = heatmap.getContext('2d');
const gcodeOutput = document.getElementById('gcodeOutput');
const statusArea = document.getElementById('statusArea');
const btnAnalyze = document.getElementById('btnAnalyze');
const btnGeneratePaths = document.getElementById('btnGeneratePaths');
const btnGenGcode = document.getElementById('btnGenGcode');
const btnDownload = document.getElementById('btnDownload');

let loadedImage = null;
let originalImageData = null;
let contours = [];
let perimeters = [];
let heatmapData = null;
let scene3d = null, renderer3d = null, camera3d = null, controls3d = null;

/* تحميل الصورة */
fileInput.addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  
  const img = new Image();
  img.onload = () => {
    loadedImage = img;
    
    // ضبط أبعاد المعاينة 2D
    const maxWidth = 600;
    const maxHeight = 400;
    let width = img.width;
    let height = img.height;
    
    if (width > maxWidth) {
      height = (maxWidth / width) * height;
      width = maxWidth;
    }
    
    if (height > maxHeight) {
      width = (maxHeight / height) * width;
      height = maxHeight;
    }
    
    preview2d.width = width;
    preview2d.height = height;
    ctx2d.drawImage(img, 0, 0, width, height);
    
    // حفظ بيانات الصورة الأصلية للمعالجة
    originalImageData = ctx2d.getImageData(0, 0, width, height);

    // توليد Heatmap مصغرة
    heatmap.width = 300;
    heatmap.height = Math.round(300 * (img.height / img.width));
    ctxHeat.drawImage(img, 0, 0, heatmap.width, heatmap.height);
    heatmapData = ctxHeat.getImageData(0, 0, heatmap.width, heatmap.height);
    
    showStatus('تم تحميل الصورة بنجاح', 'success');
    
    // تفعيل زر كشف الحواف
    btnAnalyze.disabled = false;
    
    // إعادة تعيين الحالة
    contours = [];
    perimeters = [];
    btnGeneratePaths.disabled = true;
    btnGenGcode.disabled = true;
    btnDownload.disabled = true;
    gcodeOutput.textContent = '';
    
    // إعادة تعيين معاينة 3D
    const preview3d = document.getElementById('preview3d');
    preview3d.innerHTML = '';
    preview3d.style.background = '#eee';
  };
  
  img.onerror = () => {
    showStatus('فشل في تحميل الصورة', 'error');
  };
  
  img.src = URL.createObjectURL(file);
});

/* عرض حالة */
function showStatus(message, type) {
  statusArea.innerHTML = `<div class="status ${type}">${message}</div>`;
  setTimeout(() => {
    statusArea.innerHTML = '';
  }, 3000);
}

/* كشف الحواف */
btnAnalyze.addEventListener('click', () => {
  if (!originalImageData) return showStatus('حمّل صورة أولاً', 'error');
  
  showStatus('جاري كشف الحواف...', 'success');
  
  // استخدام setTimeout لتجنب تجميد المتصفح
  setTimeout(() => {
    contours = detectEdges(originalImageData);
    drawContours();
    showStatus('تم كشف الحواف بنجاح', 'success');
    btnGeneratePaths.disabled = false;
  }, 100);
});

/* رسم الحواف */
function drawContours() {
  ctx2d.clearRect(0, 0, preview2d.width, preview2d.height);
  ctx2d.drawImage(loadedImage, 0, 0, preview2d.width, preview2d.height);
  ctx2d.strokeStyle = 'red';
  ctx2d.lineWidth = 1.2;
  contours.forEach(cont => {
    ctx2d.beginPath();
    cont.forEach((p, i) => {
      if (i === 0) ctx2d.moveTo(p.x, p.y); else ctx2d.lineTo(p.x, p.y);
    });
    ctx2d.closePath();
    ctx2d.stroke();
  });
}

/* Sobel + Threshold ديناميكي */
function detectEdges(imgData) {
  const w = imgData.width, h = imgData.height;
  const gray = new Float32Array(w * h);
  const d = imgData.data;
  
  // تحويل إلى تدرج رمادي
  for (let i = 0; i < w * h; i++) {
    const j = i * 4;
    gray[i] = 0.34 * d[j] + 0.5 * d[j + 1] + 0.16 * d[j + 2];
  }
  
  // تطبيق مرشح Sobel
  const sobel = new Float32Array(w * h);
  const kx = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
  const ky = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
  
  for (let y = 1; y < h - 1; y++) {
    for (let x = 1; x < w - 1; x++) {
      let gx = 0, gy = 0, idx = 0;
      for (let yy = -1; yy <= 1; yy++) {
        for (let xx = -1; xx <= 1; xx++) {
          const v = gray[(y + yy) * w + (x + xx)];
          gx += v * kx[idx];
          gy += v * ky[idx];
          idx++;
        }
      }
      sobel[y * w + x] = Math.hypot(gx, gy);
    }
  }
  
  // حساب العتبة ديناميكياً
  let max = 0;
  for (let i = 0; i < sobel.length; i++) {
    if (sobel[i] > max) max = sobel[i];
  }
  
  const threshold = max * 0.35;
  const binary = new Uint8Array(w * h);
  for (let i = 0; i < w * h; i++) binary[i] = sobel[i] > threshold ? 1 : 0;

  // تتبع الحواف
  const visited = new Uint8Array(w * h);
  const contours = [];
  
  for (let y = 1; y < h - 1; y++) {
    for (let x = 1; x < w - 1; x++) {
      const idx = y * w + x;
      if (binary[idx] && !visited[idx]) {
        const stack = [[x, y]];
        const points = [];
        while (stack.length) {
          const [cx, cy] = stack.pop();
          const id = cy * w + cx;
          if (cx < 0 || cx >= w || cy < 0 || cy >= h || visited[id] || !binary[id]) continue;
          visited[id] = 1;
          points.push({x: cx, y: cy});
          stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
        }
        if (points.length > 20) contours.push(simplifyPath(points, 1));
      }
    }
  }
  return contours;
}

/* تبسيط المسارات (RDP) */
function simplifyPath(points, eps) {
  if (points.length < 3) return points;
  let dmax = 0, index = 0;
  const start = points[0], end = points[points.length - 1];
  for (let i = 1; i < points.length - 1; i++) {
    const d = perpendicularDist(points[i], start, end);
    if (d > dmax) { index = i; dmax = d; }
  }
  if (dmax > eps) {
    const res1 = simplifyPath(points.slice(0, index + 1), eps);
    const res2 = simplifyPath(points.slice(index), eps);
    return res1.slice(0, res1.length - 1).concat(res2);
  } else {
    return [start, end];
  }
}

function perpendicularDist(p, a, b) {
  const dx = b.x - a.x, dy = b.y - a.y;
  if (dx === 0 && dy === 0) return Math.hypot(p.x - a.x, p.y - a.y);
  const t = ((p.x - a.x) * dx + (p.y - a.y) * dy) / (dx * dx + dy * dy);
  const px = a.x + t * dx, py = a.y + t * dy;
  return Math.hypot(p.x - px, p.y - py);
}

/* توليد المحيطات باستخدام Clipper */
btnGeneratePaths.addEventListener('click', () => {
  if (contours.length === 0) return showStatus('لا توجد حواف', 'error');
  
  showStatus('جاري توليد المحيطات...', 'success');
  
  setTimeout(() => {
    perimeters = [];
    const scale = 100;
    const toolDia = parseFloat(document.getElementById('toolDia').value);
    const offset = (toolDia / 2) * scale;
    
    contours.forEach(cont => {
      const path = cont.map(p => ({X: Math.round(p.x * scale), Y: Math.round(p.y * scale)}));
      const co = new ClipperLib.ClipperOffset();
      co.AddPath(path, ClipperLib.JoinType.jtRound, ClipperLib.EndType.etClosedPolygon);
      const solution = new ClipperLib.Paths();
      co.Execute(solution, -offset);
      solution.forEach(sol => {
        const poly = sol.map(pt => ({x: pt.X / scale, y: pt.Y / scale}));
        perimeters.push(poly);
      });
    });
    
    drawPerimeters();
    showStatus('تم توليد المحيطات بدقة', 'success');
    btnGenGcode.disabled = false;
    init3DPreview();
  }, 100);
});

/* رسم المحيطات */
function drawPerimeters() {
  drawContours();
  ctx2d.strokeStyle = 'blue';
  ctx2d.lineWidth = 1.5;
  perimeters.forEach(poly => {
    ctx2d.beginPath();
    poly.forEach((p, i) => {
      if (i === 0) ctx2d.moveTo(p.x, p.y); else ctx2d.lineTo(p.x, p.y);
    });
    ctx2d.closePath();
    ctx2d.stroke();
  });
}

/* تهيئة معاينة 3D */
function init3DPreview() {
  const container = document.getElementById('preview3d');
  container.innerHTML = '';
  
  // إنشاء المشهد
  scene3d = new THREE.Scene();
  scene3d.background = new THREE.Color(0xf0f0f0);
  
  // إنشاء الكاميرا
  camera3d = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera3d.position.set(0, -200, 100);
  
  // إنشاء العارض
  renderer3d = new THREE.WebGLRenderer({ antialias: true });
  renderer3d.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer3d.domElement);
  
  // إضافة عناصر التحكم
  controls3d = new THREE.OrbitControls(camera3d, renderer3d.domElement);
  controls3d.enableDamping = true;
  controls3d.dampingFactor = 0.05;
  
  // إضافة إضاءة
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
  scene3d.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(50, 50, 50);
  scene3d.add(directionalLight);
  
  // رسم المحيطات في 3D
  const material = new THREE.LineBasicMaterial({ color: 0x1f78d1 });
  
  perimeters.forEach(poly => {
    const points = [];
    poly.forEach(p => {
      const mm = canvasToMM(p);
      const z = -getZ(p.x, p.y);
      points.push(new THREE.Vector3(mm.x - 150, mm.y - 100, z));
    });
    
    // إغلاق المضلع
    if (poly.length > 0) {
      const firstPoint = poly[0];
      const mmFirst = canvasToMM(firstPoint);
      const zFirst = -getZ(firstPoint.x, firstPoint.y);
      points.push(new THREE.Vector3(mmFirst.x - 150, mmFirst.y - 100, zFirst));
    }
    
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(geometry, material);
    scene3d.add(line);
  });
  
  // إضافة شبكة
  const gridHelper = new THREE.GridHelper(300, 10);
  scene3d.add(gridHelper);
  
  // إضافة محاور
  const axesHelper = new THREE.AxesHelper(50);
  scene3d.add(axesHelper);
  
  // دورة التصيير
  function animate() {
    requestAnimationFrame(animate);
    controls3d.update();
    renderer3d.render(scene3d, camera3d);
  }
  animate();
  
  // إعادة ضبط الحجم عند تغيير حجم النافذة
  window.addEventListener('resize', () => {
    camera3d.aspect = container.clientWidth / container.clientHeight;
    camera3d.updateProjectionMatrix();
    renderer3d.setSize(container.clientWidth, container.clientHeight);
  });
}

/* أخذ Z من Heatmap */
function getZ(x, y) {
  if (!heatmapData) return 0;
  
  const w = heatmap.width, h = heatmap.height;
  const ix = Math.max(0, Math.min(w - 1, Math.floor(x * (w / preview2d.width))));
  const iy = Math.max(0, Math.min(h - 1, Math.floor(y * (h / preview2d.height))));
  const idx = (iy * w + ix) * 4;
  const r = heatmapData.data[idx];
  const g = heatmapData.data[idx + 1];
  const b = heatmapData.data[idx + 2];
  const bright = 0.34 * r + 0.5 * g + 0.16 * b;
  const maxDepth = parseFloat(document.getElementById('maxDepth').value);
  return (1 - bright / 255) * maxDepth;
}

/* تحويل Canvas → mm */
function canvasToMM(pt) {
  const workW = parseFloat(document.getElementById('workWidth').value);
  const workH = parseFloat(document.getElementById('workHeight').value);
  return {
    x: (pt.x / preview2d.width) * workW,
    y: (pt.y / preview2d.height) * workH
  };
}

/* توليد G-code */
btnGenGcode.addEventListener('click', () => {
  if (perimeters.length === 0) return showStatus('لا توجد محيطات', 'error');
  
  showStatus('جاري توليد G-code...', 'success');
  
  setTimeout(() => {
    const feed = parseFloat(document.getElementById('feedRate').value);
    const safeZ = 5;
    const passDepth = parseFloat(document.getElementById('passDepth').value);
    const maxDepth = parseFloat(document.getElementById('maxDepth').value);

    const lines = [
      '; G-code Generated by CNC AI',
      '; النسخة المصححة والمحسنة',
      'G21 ; استخدام المليمترات',
      'G90 ; الوضع المطلق',
      'G17 ; مستوى XY',
      `G0 Z${safeZ} ; الانتقال إلى ارتفاع الأمان`
    ];

    perimeters.forEach((poly, idx) => {
      lines.push(`; المحيط ${idx + 1}`);
      const first = canvasToMM(poly[0]);
      lines.push(`G0 X${first.x.toFixed(2)} Y${first.y.toFixed(2)} Z${safeZ}`);
      
      // حساب أقصى عمق لهذا المحيط
      const maxZ = Math.max(...poly.map(p => getZ(p.x, p.y)));
      const passes = Math.ceil(maxZ / passDepth);

      for (let pass = 1; pass <= passes; pass++) {
        const targetDepth = Math.min(pass * passDepth, maxZ);
        lines.push(`; المرور ${pass} - العمق ${targetDepth.toFixed(2)}`);
        lines.push(`G1 Z-${targetDepth.toFixed(2)} F${feed / 2}`);
        
        poly.forEach((p, i) => {
          const mm = canvasToMM(p);
          const localZ = Math.min(getZ(p.x, p.y), targetDepth);
          lines.push(`G1 X${mm.x.toFixed(2)} Y${mm.y.toFixed(2)} Z-${localZ.toFixed(2)} F${feed}`);
        });
        
        // العودة إلى النقطة الأولى لإغلاق المسار
        const firstPoint = canvasToMM(poly[0]);
        const firstZ = Math.min(getZ(poly[0].x, poly[0].y), targetDepth);
        lines.push(`G1 X${firstPoint.x.toFixed(2)} Y${firstPoint.y.toFixed(2)} Z-${firstZ.toFixed(2)} F${feed}`);
        
        // الانتقال إلى ارتفاع الأمان بعد كل مرور
        if (pass < passes) {
          lines.push(`G0 Z${safeZ}`);
        }
      }
    });

    lines.push('G0 Z10 ; العودة إلى ارتفاع آمن');
    lines.push('M30 ; نهاية البرنامج');
    
    gcodeOutput.textContent = lines.join('\n');
    showStatus('تم توليد G-code بنجاح', 'success');
    btnDownload.disabled = false;
  }, 100);
});

/* تحميل G-code */
btnDownload.addEventListener('click', () => {
  if (!gcodeOutput.textContent) return showStatus('لا يوجد G-code لتحميله', 'error');
  
  const blob = new Blob([gcodeOutput.textContent], { type: 'text/plain' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'cnc_output.nc';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  showStatus('تم تحميل الملف بنجاح', 'success');
});
</script>
</body>
</html>
