<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CNC AI - النسخة المتطورة مع التحليلات المتقدمة</title>
  <style>
    :root {
      --primary-color: #4a90e2;
      --secondary-color: #67b0f5;
      --bg-color: #f8f9fa;
      --text-color: #212529;
      --card-bg: #ffffff;
      --border-color: #dee2e6;
      --header-bg: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
      --header-text: #ffffff;
      --button-bg: #e9ecef;
      --button-hover: #dee2e6;
      --success-color: #28a745;
      --warning-color: #ffc107;
      --error-color: #dc3545;
      --ai-color: #9c27b0;
      --wood-color: #8b4513;
      --tab-inactive: #e9ecef;
      --tab-active: var(--primary-color);
      --analysis-color: #17a2b8;
      --roughing-color: #8b4513;
      --finishing-color: #5a2d0c;
      --smoothing-color: #3d2108;
      --drawing-color: #ff5722;
    }

    body.dark {
      --bg-color: #121212;
      --text-color: #e0e0e0;
      --card-bg: #1e1e1e;
      --border-color: #444;
      --header-bg: linear-gradient(90deg, #2c2c2c, #444);
      --button-bg: #333;
      --button-hover: #555;
      --ai-color: #ba68c8;
      --wood-color: #a0522d;
      --tab-inactive: #333;
      --tab-active: #4a90e2;
      --analysis-color: #138496;
      --roughing-color: #a0522d;
      --finishing-color: #8b4513;
      --smoothing-color: #5a2d0c;
      --drawing-color: #ff8a65;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      line-height: 1.6;
      transition: all 0.3s ease;
      padding: 0;
      margin: 0;
    }

    .container {
      width: 100%;
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      background: var(--header-bg);
      color: var(--header-text);
      padding: 1rem;
      text-align: center;
      border-radius: 0 0 10px 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      margin-bottom: 2rem;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 1400px;
    }

    h1 {
      font-size: 1.8rem;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .controls {
      display: flex;
      gap: 15px;
      align-items: center;
    }

    #themeToggle {
      background: transparent;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--header-text);
      transition: transform 0.3s;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #themeToggle:hover {
      transform: scale(1.1);
      background: rgba(255, 255, 255, 0.2);
    }

    /* تنسيق التابات */
    .tabs {
      display: flex;
      margin-bottom: 20px;
      background: var(--card-bg);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .tab {
      padding: 12px 20px;
      cursor: pointer;
      background: var(--tab-inactive);
      transition: all 0.3s;
      text-align: center;
      flex: 1;
      font-weight: 500;
    }

    .tab.active {
      background: var(--tab-active);
      color: white;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* محتوى التابات */
    .upload-section {
      background: var(--card-bg);
      padding: 2rem;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      text-align: center;
      border: 1px solid var(--border-color);
    }

    .previews-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 2rem;
    }

    @media (min-width: 992px) {
      .previews-container {
        grid-template-columns: 1fr 1fr;
      }
    }

    .preview-block {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      display: flex;
      flex-direction: column;
      align-items: center;
      border: 1px solid var(--border-color);
    }

    .preview-title {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--primary-color);
    }

    .preview-content {
      width: 100%;
      display: flex;
      justify-content: center;
      margin-bottom: 1rem;
    }

    canvas {
      max-width: 100%;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }

    #preview3d {
      width: 100%;
      height: 300px;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      position: relative;
    }

    .options {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
      width: 100%;
      margin-top: 1rem;
    }

    .option-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .option-group label {
      font-size: 0.9rem;
      font-weight: 500;
    }

    input[type="range"] {
      width: 150px;
      accent-color: var(--primary-color);
    }

    .settings-panel {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .settings-group {
      margin-bottom: 1.5rem;
    }

    .settings-group h3 {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border-color);
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
    }

    .form-group select, 
    .form-group input {
      width: 100%;
      padding: 10px;
      border: 1px solid var(--border-color);
      border-radius: 5px;
      background: var(--bg-color);
      color: var(--text-color);
    }

    .gcode-output {
      background: var(--bg-color);
      border: 1px solid var(--border-color);
      border-radius: 5px;
      padding: 15px;
      height: 200px;
      overflow-y: auto;
      font-family: monospace;
      white-space: pre-wrap;
      margin-top: 1rem;
    }

    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.3s;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn-primary {
      background: var(--primary-color);
      color: white;
    }

    .btn-primary:hover {
      background: var(--secondary-color);
    }

    .btn-secondary {
      background: var(--button-bg);
      color: var(--text-color);
    }

    .btn-secondary:hover {
      background: var(--button-hover);
    }

    .btn-ai {
      background: var(--ai-color);
      color: white;
    }

    .btn-ai:hover {
      background: #7b1fa2;
    }

    .btn-analysis {
      background: var(--analysis-color);
      color: white;
    }

    .btn-analysis:hover {
      background: #138496;
    }

    .btn-roughing {
      background: var(--roughing-color);
      color: white;
    }

    .btn-finishing {
      background: var(--finishing-color);
      color: white;
    }

    .btn-smoothing {
      background: var(--smoothing-color);
      color: white;
    }

    .btn-drawing {
      background: var(--drawing-color);
      color: white;
    }

    .action-buttons {
      display: flex;
      gap: 10px;
      margin-top: 1rem;
      flex-wrap: wrap;
    }

    footer {
      text-align: center;
      margin-top: 3rem;
      padding: 1.5rem;
      color: var(--text-color);
      font-size: 0.9rem;
      border-top: 1px solid var(--border-color);
    }

    .image-enhancement {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }

    .enhancement-btn {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 5px;
      background: var(--button-bg);
      color: var(--text-color);
      cursor: pointer;
      text-align: center;
      transition: all 0.3s;
    }

    .enhancement-btn:hover {
      background: var(--button-hover);
    }

    .loading {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: white;
      z-index: 100;
      border-radius: 8px;
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 20px;
      border-radius: 8px;
      background: var(--success-color);
      color: white;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transform: translateX(100%);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .notification.show {
      transform: translateX(0);
      opacity: 1;
    }

    .notification.error {
      background: var(--error-color);
    }

    .notification.ai {
      background: var(--ai-color);
    }

    .notification.analysis {
      background: var(--analysis-color);
    }

    .ai-options {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .path-optimization {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1rem;
    }

    .optimization-option {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .optimization-option input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }

    .progress-container {
      width: 100%;
      background-color: var(--border-color);
      border-radius: 5px;
      margin: 15px 0;
      display: none;
    }

    .progress-bar {
      width: 0%;
      height: 20px;
      background-color: var(--primary-color);
      border-radius: 5px;
      transition: width 0.3s ease;
    }

    .edge-detection {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 1rem 0;
    }

    .analysis-panel {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      display: none;
    }

    .analysis-results {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .analysis-item {
      background: var(--bg-color);
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .analysis-item h4 {
      margin-bottom: 0.5rem;
      color: var(--analysis-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .analysis-value {
      font-size: 1.2rem;
      font-weight: bold;
    }

    .gcode-preview {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
      display: none;
    }

    .gcode-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .stat-item {
      background: var(--bg-color);
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      text-align: center;
    }

    .stat-item h4 {
      margin-bottom: 0.5rem;
      color: var(--primary-color);
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: bold;
    }

    .wood-stages {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
      margin-top: 1.5rem;
    }

    .wood-stage {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      border: 1px solid var(--border-color);
    }

    .wood-stage h3 {
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid var(--border-color);
      color: var(--primary-color);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .advanced-settings {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .path-preview {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    .path-preview-content {
      width: 100%;
      height: 300px;
      display: flex;
      justify-content: center;
      align-items: center;
      background: var(--bg-color);
      border-radius: 8px;
      border: 1px solid var(--border-color);
      margin-top: 1rem;
      position: relative;
      overflow: hidden;
    }

    .path-svg {
      width: 100%;
      height: 100%;
    }

    .path-controls {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      justify-content: center;
    }

    .drawing-tools {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin: 1rem 0;
      padding: 1rem;
      background: var(--card-bg);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .drawing-controls {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .drawing-instructions {
      font-size: 0.9rem;
      color: var(--text-color);
      text-align: center;
      margin-top: 0.5rem;
    }

    .drawing-canvas-container {
      position: relative;
      width: 100%;
      height: 300px;
      margin-top: 1rem;
    }

    #drawingCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
      border: 1px solid var(--border-color);
      border-radius: 8px;
    }

    .manual-selection {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
      border: 1px solid var(--border-color);
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 1.4rem;
      }
      
      .header-content {
        flex-direction: column;
        gap: 15px;
      }
      
      .preview-block {
        padding: 1rem;
      }
      
      .options {
        flex-direction: column;
        align-items: center;
      }
      
      .action-buttons {
        flex-direction: column;
      }
      
      .analysis-results, .gcode-stats {
        grid-template-columns: 1fr;
      }

      .wood-stages {
        grid-template-columns: 1fr;
      }

      .drawing-controls {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <h1><span>🛠️</span> CNC AI - النسخة المحسنة</h1>
      <div class="controls">
        <button id="themeToggle">🌙</button>
      </div>
    </div>
  </header>

  <div class="container">
    <!-- التابات -->
    <div class="tabs">
      <div class="tab active" data-tab="preview">معاينة الصورة</div>
      <div class="tab" data-tab="gcode">G-code إعدادات</div>
      <div class="tab" data-tab="advanced">إعدادات متقدمة</div>
    </div>

    <!-- تاب المعاينة -->
    <div class="tab-content active" id="preview-tab">
      <section class="upload-section">
        <h2 class="upload-title">📤 تحميل الصورة</h2>
        <div class="file-upload">
          <input type="file" id="fileInput" accept="image/*">
          <label for="fileInput"><span>📁</span> اختر صورة</label>
          <div class="file-name" id="fileName">لم يتم اختيار أي صورة بعد</div>
        </div>

        <div class="progress-container" id="progressContainer">
          <div class="progress-bar" id="progressBar"></div>
        </div>

        <div class="image-enhancement">
          <div class="enhancement-btn" onclick="applyEnhancement('brightness')">🔆 سطوع</div>
          <div class="enhancement-btn" onclick="applyEnhancement('contrast')">🌓 تباين</div>
          <div class="enhancement-btn" onclick="applyEnhancement('sharpen')">🔍 حدة</div>
          <div class="enhancement-btn" onclick="applyEnhancement('smooth')">🔄 نعومة</div>
          <div class="enhancement-btn" onclick="applyEnhancement('grayscale')">⚫ تدرج رمادي</div>
          <div class="enhancement-btn" onclick="applyEnhancement('reset')">🔄 إعادة تعيين</div>
        </div>

        <div class="edge-detection">
          <div class="enhancement-btn" onclick="detectEdges('sobel')">🔍 كشف الحواف (Sobel)</div>
          <div class="enhancement-btn" onclick="detectEdges('canny')">🔍 كشف الحواف (Canny)</div>
          <div class="enhancement-btn" onclick="detectEdges('laplacian')">🔍 كشف الحواف (Laplacian)</div>
        </div>
      </section>

      <div class="previews-container">
        <!-- الصورة الأصلية -->
        <div class="preview-block">
          <h3 class="preview-title">📷 الصورة الأصلية</h3>
          <div class="preview-content">
            <canvas id="preview2d"></canvas>
          </div>
        </div>

        <!-- معاينة 3D -->
        <div class="preview-block">
          <h3 class="preview-title">🌀 المعاينة ثلاثية الأبعاد</h3>
          <div class="preview-content">
            <div id="preview3d">
              <div class="loading" id="loading3d">
                <div class="loading-spinner"></div>
                <p>جاري تحميل النموذج...</p>
              </div>
            </div>
          </div>
          <div class="options">
            <div class="option-group">
              <label for="rotationSpeed">🔄 سرعة الدوران</label>
              <input type="range" id="rotationSpeed" min="0" max="0.05" step="0.001" value="0.01">
            </div>
            <div class="option-group">
              <label for="zoomControl">🔍 زوم</label>
              <input type="range" id="zoomControl" min="50" max="500" step="10" value="200">
            </div>
            <div class="option-group">
              <label for="heightIntensity">📏 شدة الارتفاع</label>
              <input type="range" id="heightIntensity" min="20" max="200" step="5" value="80">
            </div>
          </div>
        </div>

        <!-- Heatmap -->
        <div class="preview-block">
          <h3 class="preview-title">🌈 خريطة الارتفاعات (Heatmap)</h3>
          <div class="preview-content">
            <canvas id="heatmap"></canvas>
          </div>
          <div class="colormap-controls">
            <button class="btn btn-secondary" onclick="setColormap('jet')"><span>🌈</span> Jet</button>
            <button class="btn btn-secondary" onclick="setColormap('hot')"><span>🔥</span> Hot</button>
            <button class="btn btn-secondary" onclick="setColormap('cool')"><span>❄️</span> Cool</button>
            <button class="btn btn-secondary" onclick="setColormap('gray')"><span>⚪</span> Gray</button>
          </div>
        </div>

        <!-- حواف الصورة -->
        <div class="preview-block">
          <h3 class="preview-title">🔍 حواف الصورة</h3>
          <div class="preview-content">
            <canvas id="edgesCanvas"></canvas>
          </div>
          <div class="options">
            <div class="option-group">
              <label for="edgeThreshold">📊 عتبة الحواف</label>
              <input type="range" id="edgeThreshold" min="1" max="100" step="1" value="50" oninput="updateEdgeDetection()">
            </div>
          </div>
        </div>

        <!-- تحديد المناطق يدوياً -->
        <div class="preview-block">
          <h3 class="preview-title">✏️ تحديد المناطق يدوياً</h3>
          <div class="preview-content">
            <div class="drawing-canvas-container">
              <canvas id="drawingCanvas"></canvas>
            </div>
          </div>
          <div class="drawing-tools">
            <div class="drawing-controls">
              <button class="btn btn-drawing" id="startDrawing">
                <span>✏️</span> بدء الرسم
              </button>
              <button class="btn btn-secondary" id="clearDrawing">
                <span>🗑️</span> مسح الرسم
              </button>
              <button class="btn btn-primary" id="applyDrawing">
                <span>✅</span> تطبيق الرسم
              </button>
            </div>
            <div class="drawing-instructions">
              <p>ارسم المنطقة التي تريد قطعها. اضغط على "بدء الرسم" لبدء الرسم، ثم انقر واسحب لرسم المنطقة.</p>
            </div>
            <div class="options">
              <div class="option-group">
                <label for="brushSize">📏 حجم الفرشاة</label>
                <input type="range" id="brushSize" min="1" max="20" step="1" value="5">
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- تاب إعدادات G-code -->
    <div class="tab-content" id="gcode-tab">
      <div class="ai-options">
        <h3><span>🤖</span> خيارات الذكاء الاصطناعي</h3>
        <div class="path-optimization">
          <div class="optimization-option">
            <input type="checkbox" id="optimizePaths" checked>
            <label for="optimizePaths">تحسين المسارات لتقليل وقت القطع</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="smoothEdges" checked>
            <label for="smoothEdges">تنعيم الحواف للنتائج الأفضل</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="adaptivePrecision">
            <label for="adaptivePrecision">الدقة التكيفية (تلقائية)</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="useEdges" checked>
            <label for="useEdges">استخدام حواف الصورة لتوليد المسارات</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="startFromEdges" checked>
            <label for="startFromEdges">بدء القطع من الحواف</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="useManualSelection">
            <label for="useManualSelection">استخدام التحديد اليدوي للمناطق</label>
          </div>
        </div>
      </div>

      <div class="settings-panel">
        <div class="settings-group">
          <h3><span>🏭</span> إعدادات الماكينة</h3>
          <div class="form-group">
            <label for="machineType">نوع الماكينة</label>
            <select id="machineType">
              <option value="cnc">CNC Router</option>
              <option value="laser">Laser Cutter</option>
              <option value="3dprinter">3D Printer</option>
            </select>
          </div>
        </div>

        <div class="settings-group">
          <h3><span>📦</span> إعدادات الخامة</h3>
          <div class="form-group">
            <label for="materialType">نوع الخامة</label>
            <select id="materialType">
              <option value="wood">خشب</option>
              <option value="acrylic">أكريليك</option>
              <option value="aluminum">ألومنيوم</option>
              <option value="steel">صلب</option>
              <option value="pla">PLA (بلاستيك)</option>
              <option value="abs">ABS (بلاستيك)</option>
            </select>
          </div>
        </div>

        <div class="settings-group">
          <h3><span>⚙️</span> إعدادات القطع</h3>
          <div class="form-group">
            <label for="feedRate">سرعة التغذية (mm/min)</label>
            <input type="number" id="feedRate" value="1000">
          </div>
          <div class="form-group">
            <label for="spindleSpeed">سرعة المغزل (RPM)</label>
            <input type="number" id="spindleSpeed" value="10000">
          </div>
          <div class="form-group">
            <label for="cutDepth">عمق القطع (mm)</label>
            <input type="number" id="cutDepth" value="2" step="0.1">
          </div>
          <div class="form-group">
            <label for="passDepth">عمق التمريرة (mm)</label>
            <input type="number" id="passDepth" value="0.5" step="0.1">
          </div>
        </div>

        <div class="settings-group">
          <h3><span>🔧</span> إعدادات G-code</h3>
          <div class="form-group">
            <label for="gcodeType">نوع المخرجات</label>
            <select id="gcodeType">
              <option value="heatmap">بناءً على Heatmap</option>
              <option value="3dmodel">بناءً على النموذج ثلاثي الأبعاد</option>
              <option value="edges">بناءً على حواف الصورة</option>
              <option value="manual">بناءً على التحديد اليدوي</option>
            </select>
          </div>
          <div class="form-group">
            <label for="gcodePrecision">دقة التوليد</label>
            <select id="gcodePrecision">
              <option value="low">منخفضة (أسرع)</option>
              <option value="medium" selected>متوسطة</option>
              <option value="high">عالية (أبطأ)</option>
            </select>
          </div>
        </div>

        <div class="action-buttons">
          <button class="btn btn-analysis" onclick="analyzeImage()">
            <span>🔍</span> تحليل الصورة
          </button>
          <button class="btn btn-primary" onclick="generateGcode()">
            <span>⚡</span> توليد G-code
          </button>
          <button class="btn btn-secondary" onclick="downloadGcode()">
            <span>💾</span> حفظ G-code
          </button>
        </div>
      </div>

      <!-- معاينة مسارات القطع -->
      <div class="path-preview">
        <h3><span>🔄</span> معاينة مسارات القطع</h3>
        <div class="path-preview-content" id="pathPreview">
          <svg class="path-svg" id="pathSvg"></svg>
        </div>
        <div class="path-controls">
          <button class="btn btn-secondary" onclick="updatePathPreview()">
            <span>🔄</span> تحديث المعاينة
          </button>
          <button class="btn btn-primary" onclick="optimizePaths()">
            <span>🔍</span> تحسين المسارات
          </button>
        </div>
      </div>

      <div class="analysis-panel" id="analysisPanel">
        <h3><span>📊</span> نتائج التحليل</h3>
        <div class="analysis-results" id="analysisResults">
          <!-- سيتم ملؤها ديناميكيًا -->
        </div>
      </div>

      <div class="gcode-preview" id="gcodePreview">
        <h3><span>📋</span> معاينة G-code</h3>
        <div class="gcode-stats" id="gcodeStats">
          <!-- سيتم ملؤها ديناميكيًا -->
        </div>
        <div class="gcode-output" id="gcodeOutput">
// سيظهر كود G-code هنا بعد التوليد
// اضغط على "توليد G-code" لبدء عملية التوليد
        </div>
      </div>

      <!-- مراحل معالجة الخشب -->
      <div class="wood-stages" id="woodStages" style="display: none;">
        <div class="wood-stage">
          <h3><span>🔨</span> مرحلة التنجير</h3>
          <div class="form-group">
            <label for="roughingFeedRate">سرعة التغذية (mm/min)</label>
            <input type="number" id="roughingFeedRate" value="1500">
          </div>
          <div class="form-group">
            <label for="roughingSpindleSpeed">سرعة المغزل (RPM)</label>
            <input type="number" id="roughingSpindleSpeed" value="8000">
          </div>
          <div class="form-group">
            <label for="roughingDepth">عمق القطع (mm)</label>
            <input type="number" id="roughingDepth" value="3" step="0.1">
          </div>
          <button class="btn btn-roughing" onclick="generateStageGcode('roughing')">
            <span>⚡</span> توليد G-code للتنجير
          </button>
          <button class="btn btn-roughing" onclick="downloadStageGcode('roughing')">
            <span>💾</span> حفظ ملف التنجير
          </button>
        </div>

        <div class="wood-stage">
          <h3><span>✂️</span> مرحلة التشطيب</h3>
          <div class="form-group">
            <label for="finishingFeedRate">سرعة التغذية (mm/min)</label>
            <input type="number" id="finishingFeedRate" value="1000">
          </div>
          <div class="form-group">
            <label for="finishingSpindleSpeed">سرعة المغزل (RPM)</label>
            <input type="number" id="finishingSpindleSpeed" value="12000">
          </div>
          <div class="form-group">
            <label for="finishingDepth">عمق القطع (mm)</label>
            <input type="number" id="finishingDepth" value="1" step="0.1">
          </div>
          <button class="btn btn-finishing" onclick="generateStageGcode('finishing')">
            <span>⚡</span> توليد G-code للتشطيب
          </button>
          <button class="btn btn-finishing" onclick="downloadStageGcode('finishing')">
            <span>💾</span> حفظ ملف التشطيب
          </button>
        </div>

        <div class="wood-stage">
          <h3><span>✨</span> مرحلة التنعيم</h3>
          <div class="form-group">
            <label for="smoothingFeedRate">سرعة التغذية (mm/min)</label>
            <input type="number" id="smoothingFeedRate" value="800">
          </div>
          <div class="form-group">
            <label for="smoothingSpindleSpeed">سرعة المغزل (RPM)</label>
            <input type="number" id="smoothingSpindleSpeed" value="15000">
          </div>
          <div class="form-group">
            <label for="smoothingDepth">عمق القطع (mm)</label>
            <input type="number" id="smoothingDepth" value="0.5" step="0.1">
          </div>
          <button class="btn btn-smoothing" onclick="generateStageGcode('smoothing')">
            <span>⚡</span> توليد G-code للتنعيم
          </button>
          <button class="btn btn-smoothing" onclick="downloadStageGcode('smoothing')">
            <span>💾</span> حفظ ملف التنعيم
          </button>
        </div>
      </div>
    </div>

    <!-- تاب الإعدادات المتقدمة -->
    <div class="tab-content" id="advanced-tab">
      <div class="advanced-settings">
        <h2><span>⚙️</span> الإعدادات المتقدمة للماكينات</h2>
        
        <div class="settings-group">
          <h3><span>🔧</span> إعدادات المحاور</h3>
          <div class="form-group">
            <label for="xSpeed">السرعة على المحور X (mm/min)</label>
            <input type="number" id="xSpeed" value="3000">
          </div>
          <div class="form-group">
            <label for="ySpeed">السرعة على المحور Y (mm/min)</label>
            <input type="number" id="ySpeed" value="3000">
          </div>
          <div class="form-group">
            <label for="zSpeed">السرعة على المحور Z (mm/min)</label>
            <input type="number" id="zSpeed" value="1000">
          </div>
          <div class="form-group">
            <label for="acceleration">التسارع (mm/s²)</label>
            <input type="number" id="acceleration" value="500">
          </div>
        </div>

        <div class="settings-group">
          <h3><span>📏</span> إعدادات الدقة</h3>
          <div class="form-group">
            <label for="tolerance">التحمل (mm)</label>
            <input type="number" id="tolerance" value="0.01" step="0.001">
          </div>
          <div class="form-group">
            <label for="stepover">التداخل بين المسارات (%)</label>
            <input type="number" id="stepover" value="50" min="10" max="90">
          </div>
          <div class="form-group">
            <label for="resolution">دقة النموذج ثلاثي الأبعاد</label>
            <select id="resolution">
              <option value="low">منخفضة</option>
              <option value="medium" selected>متوسطة</option>
              <option value="high">عالية</option>
            </select>
          </div>
        </div>

        <div class="settings-group">
          <h3><span>🔄</span> إعدادات التحسين</h3>
          <div class="form-group">
            <label for="retractDistance">مسافة السحب (mm)</label>
            <input type="number" id="retractDistance" value="5" step="0.1">
          </div>
          <div class="form-group">
            <label for="retractSpeed">سرعة السحب (mm/min)</label>
            <input type="number" id="retractSpeed" value="1200">
          </div>
          <div class="form-group">
            <label for="plungeSpeed">سرعة الغوص (mm/min)</label>
            <input type="number" id="plungeSpeed" value="300">
          </div>
          <div class="form-group">
            <label for="coolant">نظام التبريد</label>
            <select id="coolant">
              <option value="none">بدون</option>
              <option value="mist">رذاذ</option>
              <option value="flood">غمر</option>
            </select>
          </div>
        </div>

        <div class="action-buttons">
          <button class="btn btn-primary" onclick="saveAdvancedSettings()">
            <span>💾</span> حفظ الإعدادات
          </button>
          <button class="btn btn-secondary" onclick="loadDefaultAdvancedSettings()">
            <span>🔄</span> الإعدادات الافتراضية
          </button>
        </div>
      </div>

      <div class="path-preview">
        <h3><span>🔄</span> تحسين مسارات القطع المتقدمة</h3>
        <div class="path-optimization">
          <div class="optimization-option">
            <input type="checkbox" id="adaptivePaths" checked>
            <label for="adaptivePaths">مسارات تكيفية حسب الارتفاع</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="reduceLift" checked>
            <label for="reduceLift">تقليل عمليات الرفع</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="optimizeOrder" checked>
            <label for="optimizeOrder">تحسين ترتيب القطع</label>
          </div>
          <div class="optimization-option">
            <input type="checkbox" id="minimizeTravel" checked>
            <label for="minimizeTravel">تقليل مسافات التنقل</label>
          </div>
        </div>
        
        <div class="path-preview-content" id="advancedPathPreview">
          <svg class="path-svg" id="advancedPathSvg"></svg>
        </div>
        
        <div class="path-controls">
          <button class="btn btn-primary" onclick="generateAdvancedPaths()">
            <span>🔍</span> توليد مسارات متقدمة
          </button>
          <button class="btn btn-analysis" onclick="analyzePaths()">
            <span>📊</span> تحليل المسارات
          </button>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <p>تم التطوير باستخدام Three.js و TensorFlow.js - مشروع CncAI مع معالجة متقدمة للصور</p>
  </footer>

  <div class="notification" id="notification">تم تحميل الصورة بنجاح!</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
  <script>
    // عناصر DOM
    const fileInput = document.getElementById('fileInput');
    const fileName = document.getElementById('fileName');
    const canvas2d = document.getElementById('preview2d');
    const ctx2d = canvas2d.getContext('2d');
    const heatmap = document.getElementById('heatmap');
    const ctxHeat = heatmap.getContext('2d');
    const edgesCanvas = document.getElementById('edgesCanvas');
    const ctxEdges = edgesCanvas.getContext('2d');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const ctxDrawing = drawingCanvas.getContext('2d');
    const preview3d = document.getElementById('preview3d');
    const rotationSpeedInput = document.getElementById('rotationSpeed');
    const zoomControl = document.getElementById('zoomControl');
    const heightIntensity = document.getElementById('heightIntensity');
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    const gcodeOutput = document.getElementById('gcodeOutput');
    const notification = document.getElementById('notification');
    const loading3d = document.getElementById('loading3d');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');
    const edgeThreshold = document.getElementById('edgeThreshold');
    const analysisPanel = document.getElementById('analysisPanel');
    const analysisResults = document.getElementById('analysisResults');
    const gcodePreview = document.getElementById('gcodePreview');
    const gcodeStats = document.getElementById('gcodeStats');
    const woodStages = document.getElementById('woodStages');
    const pathSvg = document.getElementById('pathSvg');
    const advancedPathSvg = document.getElementById('advancedPathSvg');
    const materialType = document.getElementById('materialType');
    const startDrawingBtn = document.getElementById('startDrawing');
    const clearDrawingBtn = document.getElementById('clearDrawing');
    const applyDrawingBtn = document.getElementById('applyDrawing');
    const brushSizeInput = document.getElementById('brushSize');

    // إعداد Three.js للمعاينة
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    const camera = new THREE.PerspectiveCamera(45, preview3d.offsetWidth / preview3d.offsetHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(preview3d.offsetWidth, preview3d.offsetHeight);
    preview3d.appendChild(renderer.domElement);

    // إضاءة المشاهد
    function setupLights(scene) {
      const ambientLight = new THREE.AmbientLight(0x404040, 1);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(1, 1, 1);
      scene.add(directionalLight);
      
      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
      directionalLight2.position.set(-1, -1, -1);
      scene.add(directionalLight2);
    }

    setupLights(scene);

    camera.position.z = 200;

    let mesh;
    let rotationSpeed = 0.01;
    let currentColormap = 'jet';
    let heightFactor = 80;
    let heightMapData = null;
    let originalImageData = null;
    let edgesImageData = null;
    let generatedGcode = '';
    let analysisData = null;
    let toolPaths = [];
    let advancedToolPaths = [];
    let stageGcodes = {
      roughing: '',
      finishing: '',
      smoothing: ''
    };

    // متغيرات للرسم اليدوي
    let isDrawing = false;
    let manualSelectionData = null;
    let lastX = 0;
    let lastY = 0;

    // ============== دوال الرسم اليدوي ==============

    // تهيئة لوحة الرسم
    function initDrawingCanvas() {
      drawingCanvas.width = canvas2d.width;
      drawingCanvas.height = canvas2d.height;
      ctxDrawing.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctxDrawing.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }

    // بدء الرسم
    function startDrawing() {
      isDrawing = true;
      startDrawingBtn.textContent = '⏹️ إيقاف الرسم';
      startDrawingBtn.classList.remove('btn-drawing');
      startDrawingBtn.classList.add('btn-secondary');
      drawingCanvas.style.cursor = 'crosshair';
      showNotification('بدء الرسم: ارسم المنطقة المطلوبة', false, 'analysis');
    }

    // إيقاف الرسم
    function stopDrawing() {
      isDrawing = false;
      startDrawingBtn.textContent = '✏️ بدء الرسم';
      startDrawingBtn.classList.remove('btn-secondary');
      startDrawingBtn.classList.add('btn-drawing');
      drawingCanvas.style.cursor = 'default';
      showNotification('تم إيقاف الرسم', false, 'analysis');
    }

    // مسح الرسم
    function clearDrawing() {
      ctxDrawing.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      ctxDrawing.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctxDrawing.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      manualSelectionData = null;
      showNotification('تم مسح الرسم', false, 'analysis');
    }

    // تطبيق الرسم على الصورة
    function applyDrawing() {
      if (!originalImageData) {
        showNotification('يجب تحميل صورة أولاً', true);
        return;
      }

      // الحصول على بيانات الرسم
      const drawingData = ctxDrawing.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
      
      // حفظ بيانات التحديد اليدوي
      manualSelectionData = drawingData;
      
      // تطبيق الرسم على الصورة الأصلية
      const combinedData = new ImageData(drawingCanvas.width, drawingCanvas.height);
      const originalData = originalImageData.data;
      
      for (let i = 0; i < originalData.length; i += 4) {
        // إذا كانت المنطقة مرسومة (غير شفافة)
        if (drawingData.data[i+3] > 50) {
          // تعزيز المنطقة المرسومة
          combinedData.data[i] = Math.min(255, originalData[i] * 1.2);
          combinedData.data[i+1] = Math.min(255, originalData[i+1] * 1.2);
          combinedData.data[i+2] = Math.min(255, originalData[i+2] * 1.2);
          combinedData.data[i+3] = 255;
        } else {
          // تخفيف المناطق غير المرسومة
          combinedData.data[i] = originalData[i] * 0.7;
          combinedData.data[i+1] = originalData[i+1] * 0.7;
          combinedData.data[i+2] = originalData[i+2] * 0.7;
          combinedData.data[i+3] = 255;
        }
      }
      
      // عرض الصورة المعدلة
      ctx2d.putImageData(combinedData, 0, 0);
      
      // إنشاء خريطة ارتفاع جديدة
      createHeightMapFromCanvas(canvas2d);
      
      showNotification('تم تطبيق الرسم على الصورة', false, 'analysis');
    }

    // رسم على اللوحة
    function drawOnCanvas(e) {
      if (!isDrawing) return;
      
      const rect = drawingCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const brushSize = parseInt(brushSizeInput.value);
      
      ctxDrawing.lineJoin = 'round';
      ctxDrawing.lineCap = 'round';
      ctxDrawing.lineWidth = brushSize;
      ctxDrawing.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      
      ctxDrawing.beginPath();
      ctxDrawing.moveTo(lastX, lastY);
      ctxDrawing.lineTo(x, y);
      ctxDrawing.stroke();
      
      lastX = x;
      lastY = y;
    }

    // إعداد أحداث الرسم
    drawingCanvas.addEventListener('mousedown', (e) => {
      if (!isDrawing) return;
      
      const rect = drawingCanvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
      
      // رسم نقطة عند النقر
      const brushSize = parseInt(brushSizeInput.value);
      ctxDrawing.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctxDrawing.beginPath();
      ctxDrawing.arc(lastX, lastY, brushSize/2, 0, Math.PI * 2);
      ctxDrawing.fill();
      
      drawingCanvas.addEventListener('mousemove', drawOnCanvas);
    });

    drawingCanvas.addEventListener('mouseup', () => {
      drawingCanvas.removeEventListener('mousemove', drawOnCanvas);
    });

    drawingCanvas.addEventListener('mouseleave', () => {
      drawingCanvas.removeEventListener('mousemove', drawOnCanvas);
    });

    // إعداد أزرار الرسم
    startDrawingBtn.addEventListener('click', () => {
      if (!originalImageData) {
        showNotification('يجب تحميل صورة أولاً', true);
        return;
      }
      
      if (isDrawing) {
        stopDrawing();
      } else {
        startDrawing();
      }
    });

    clearDrawingBtn.addEventListener('click', clearDrawing);
    applyDrawingBtn.addEventListener('click', applyDrawing);

    // ============== نهاية دوال الرسم اليدوي ==============

    // تبديل التابات
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const tabId = tab.getAttribute('data-tab');
        
        // إلغاء تفعيل جميع التابات
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(tc => tc.classList.remove('active'));
        
        // تفعيل التاب المحدد
        tab.classList.add('active');
        document.getElementById(`${tabId}-tab`).classList.add('active');
      });
    });

    // تحديث واجهة معالجة الخشب بناءً على نوع المادة
    materialType.addEventListener('change', function() {
      if (this.value === 'wood') {
        woodStages.style.display = 'grid';
      } else {
        woodStages.style.display = 'none';
      }
    });

    // دالة لتحسين الصورة
    function applyEnhancement(type) {
      if (!originalImageData) {
        showNotification('يجب تحميل صورة أولاً', true);
        return;
      }

      const canvas = document.createElement('canvas');
      canvas.width = canvas2d.width;
      canvas.height = canvas2d.height;
      const ctx = canvas.getContext('2d');
      ctx.putImageData(originalImageData, 0, 0);

      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      switch(type) {
        case 'brightness':
          // زيادة السطوع
          for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, data[i] + 30);
            data[i+1] = Math.min(255, data[i+1] + 30);
            data[i+2] = Math.min(255, data[i+2] + 30);
          }
          break;
        case 'contrast':
          // زيادة التباين
          const factor = 1.2;
          for (let i = 0; i < data.length; i += 4) {
            data[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));
            data[i+1] = Math.min(255, Math.max(0, factor * (data[i+1] - 128) + 128));
            data[i+2] = Math.min(255, Math.max(0, factor * (data[i+2] - 128) + 128));
          }
          break;
        case 'sharpen':
          // زيادة الحدة (تصفية بسيطة)
          const weights = [0, -1, 0, -1, 5, -1, 0, -1, 0];
          const tempData = new Uint8ClampedArray(data);
          for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
              for (let c = 0; c < 3; c++) {
                let sum = 0;
                for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                    const idx = ((y + ky) * canvas.width + (x + kx)) * 4 + c;
                    const weight = weights[(ky + 1) * 3 + (kx + 1)];
                    sum += tempData[idx] * weight;
                  }
                }
                const idx = (y * canvas.width + x) * 4 + c;
                data[idx] = Math.min(255, Math.max(0, sum));
              }
            }
          }
          break;
        case 'smooth':
          // تطبيق نعومة (تصفية Gaussian بسيطة)
          for (let y = 1; y < canvas.height - 1; y++) {
            for (let x = 1; x < canvas.width - 1; x++) {
              for (let c = 0; c < 3; c++) {
                let sum = 0;
                for (let ky = -1; ky <= 1; ky++) {
                  for (let kx = -1; kx <= 1; kx++) {
                    const idx = ((y + ky) * canvas.width + (x + kx)) * 4 + c;
                    sum += data[idx];
                  }
                }
                const idx = (y * canvas.width + x) * 4 + c;
                data[idx] = sum / 9;
              }
            }
          }
          break;
        case 'grayscale':
          // تحويل إلى تدرج رمادي
          for (let i = 0; i < data.length; i += 4) {
            const avg = 0.3 * data[i] + 0.59 * data[i+1] + 0.11 * data[i+2];
            data[i] = data[i+1] = data[i+2] = avg;
          }
          break;
        case 'reset':
          // إعادة تعيين إلى الصورة الأصلية
          ctx.putImageData(originalImageData, 0, 0);
          break;
      }

      ctx.putImageData(imageData, 0, 0);
      ctx2d.clearRect(0, 0, canvas2d.width, canvas2d.height);
      ctx2d.drawImage(canvas, 0, 0);
      
      // إنشاء خريطة ارتفاع جديدة من الصورة المحسنة
      createHeightMapFromCanvas(canvas);
    }

    // دالة لإنشاء خريطة ارتفاع من canvas
    function createHeightMapFromCanvas(canvas) {
      loading3d.style.display = 'flex';
      
      setTimeout(() => {
        const img = new Image();
        img.onload = () => {
          createHeightMap(img);
          loading3d.style.display = 'none';
        };
        img.src = canvas.toDataURL();
      }, 100);
    }

    // دالة لإنشاء خريطة الارتفاع
    function createHeightMap(image) {
      const w = Math.min(image.width, 100);
      const h = Math.min(image.height, 100);
      
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = w; 
      tempCanvas.height = h;
      const tctx = tempCanvas.getContext('2d');
      tctx.drawImage(image, 0, 0, w, h);
      const imgData = tctx.getImageData(0, 0, w, h).data;

      // حفظ بيانات الارتفاع للاستخدام لاحقاً في توليد G-code
      heightMapData = {
        data: new Uint8Array(imgData),
        width: w,
        height: h
      };

      // إنشاء شبكة 3D
      const geometry = new THREE.PlaneGeometry(100, 100, w-1, h-1);
      let min = 255, max = 0;
      const colors = [];
      
      for (let i = 0; i < geometry.attributes.position.count; i++) {
        const stride = i * 3;
        const x = i % w;
        const y = Math.floor(i / w);
        const idx = (y * w + x) * 4;
        const brightness = 0.34 * imgData[idx] + 0.5 * imgData[idx+1] + 0.16 * imgData[idx+2]; // تحويل إلى grayscale
        min = Math.min(min, brightness);
        max = Math.max(max, brightness);
        geometry.attributes.position.array[stride + 2] = brightness / heightFactor;

        const norm = (brightness - min) / (max - min || 1);
        const color = getHeatColor(norm, currentColormap);
        colors.push(color.r/255, color.g/255, color.b/255);
      }
      
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geometry.computeVertexNormals();

      const material = new THREE.MeshLambertMaterial({ 
        vertexColors: true, 
        side: THREE.DoubleSide,
        wireframe: false
      });
      
      if (mesh) scene.remove(mesh);
      mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      drawHeatmap(imgData, w, h, min, max);
    }

    // دالة لرسم خريطة الحرارة
    function drawHeatmap(imgData, w, h, min, max) {
      heatmap.width = w;
      heatmap.height = h;
      const heatData = ctxHeat.createImageData(w, h);
      
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = (y * w + x) * 4;
          const brightness = 0.34 * imgData[idx] + 0.5 * imgData[idx+1] + 0.16 * imgData[idx+2]; // تحويل إلى grayscale
          const norm = (brightness - min) / (max - min || 1);
          const color = getHeatColor(norm, currentColormap);
          heatData.data[idx] = color.r;
          heatData.data[idx+1] = color.g;
          heatData.data[idx+2] = color.b;
          heatData.data[idx+3] = 255;
        }
      }
      
      ctxHeat.putImageData(heatData, 0, 0);
    }

    // دالة للحصول على لون الخريطة الحرارية
    function getHeatColor(value, map) {
      let r=0, g=0, b=0;
      
      if(map === 'jet'){ 
        r = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-3),1),0));
        g = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-2),1),0));
        b = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-1),1),0));
      } else if(map === 'hot'){ 
        r = Math.floor(255 * Math.min(1, 3*value));
        g = Math.floor(255 * Math.min(1, 3*value-1));
        g = Math.max(g,0);
        b = Math.floor(255 * Math.min(1, 3*value-2));
        b = Math.max(b,0);
      } else if(map === 'cool'){
        r = Math.floor(255 * value);
        g = Math.floor(255 * (1-value));
        b = 255;
      } else if(map === 'gray'){
        r = g = b = Math.floor(255 * value);
      }
      
      return {r, g, b};
    }

    // دالة لتعيين خريطة الألوان
    function setColormap(map) {
      currentColormap = map;
      
      if(fileInput.files[0]){
        const img = new Image();
        img.onload = () => createHeightMap(img);
        img.src = URL.createObjectURL(fileInput.files[0]);
      }
    }

    // دورة الرسوم المتحركة
    function animate() {
      requestAnimationFrame(animate);
      if (mesh) mesh.rotation.y += rotationSpeed;
      renderer.render(scene, camera);
    }
    animate();

    // أحداث عناصر التحكم
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      fileName.textContent = file.name;
      
      const img = new Image();
      img.onload = () => {
        canvas2d.width = img.width;
        canvas2d.height = img.height;
        edgesCanvas.width = img.width;
        edgesCanvas.height = img.height;
        drawingCanvas.width = img.width;
        drawingCanvas.height = img.height;
        ctx2d.drawImage(img, 0, 0, canvas2d.width, canvas2d.height);
        
        // حفظ بيانات الصورة الأصلية
        originalImageData = ctx2d.getImageData(0, 0, canvas2d.width, canvas2d.height);
        
        // تهيئة لوحة الرسم
        initDrawingCanvas();
        
        createHeightMap(img);
        showNotification('تم تحميل الصورة بنجاح');
      };
      img.src = URL.createObjectURL(file);
    });

    rotationSpeedInput.addEventListener('input', () => {
      rotationSpeed = parseFloat(rotationSpeedInput.value);
    });

    zoomControl.addEventListener('input', () => {
      camera.position.z = parseFloat(zoomControl.value);
    });

    heightIntensity.addEventListener('input', () => {
      heightFactor = parseFloat(heightIntensity.value);
      if(fileInput.files[0]){
        const img = new Image();
        img.onload = () => createHeightMap(img);
        img.src = URL.createObjectURL(fileInput.files[0]);
      }
    });

    // تبديل الوضع الليلي/النهاري
    const themeToggle = document.getElementById('themeToggle');
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark');
      themeToggle.textContent = document.body.classList.contains('dark') ? "☀️" : "🌙";
      
      // تحديث لون خلفية المشهد ثلاثي الأبعاد
      scene.background = new THREE.Color(document.body.classList.contains('dark') ? 0x121212 : 0xf0f0f0);
    });

    // جعل النماذج ثلاثية الأبعاد متجاوبة
    window.addEventListener('resize', () => {
      renderer.setSize(preview3d.offsetWidth, preview3d.offsetHeight);
      camera.aspect = preview3d.offsetWidth / preview3d.offsetHeight;
      camera.updateProjectionMatrix();
    });

    // دالة لعرض الإشعارات
    function showNotification(message, isError = false, type = '') {
      notification.textContent = message;
      notification.className = 'notification';
      if (isError) {
        notification.classList.add('error');
      } else if (type === 'ai') {
        notification.classList.add('ai');
      } else if (type === 'analysis') {
        notification.classList.add('analysis');
      }
      notification.classList.add('show');
      
      setTimeout(() => {
        notification.classList.remove('show');
      }, 3000);
    }

    // دالة لتحديث شريط التقدم
    function updateProgress(percent) {
      progressContainer.style.display = 'block';
      progressBar.style.width = percent + '%';
      
      if (percent >= 100) {
        setTimeout(() => {
          progressContainer.style.display = 'none';
        }, 500);
      }
    }

    // ============== دوال كشف الحواف ==============

    // دالة لكشف الحواف باستخدام خوارزمية Sobel
    function detectEdges(algorithm) {
      if (!originalImageData) {
        showNotification('يجب تحميل صورة أولاً', true);
        return;
      }

      updateProgress(10);
      
      setTimeout(() => {
        const width = canvas2d.width;
        const height = canvas2d.height;
        
        // إنشاء canvas مؤقت
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(originalImageData, 0, 0);
        
        const imageData = tempCtx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        updateProgress(30);
        
        // تحويل الصورة إلى تدرج رمادي أولاً
        const grayData = new Uint8ClampedArray(width * height);
        for (let i = 0; i < data.length; i += 4) {
          const gray = 0.3 * data[i] + 0.59 * data[i+1] + 0.11 * data[i+2];
          grayData[i/4] = gray;
        }
        
        updateProgress(50);
        
        let edgeData;
        
        // تطبيق خوارزمية كشف الحواف المختارة
        switch(algorithm) {
          case 'sobel':
            edgeData = applySobel(grayData, width, height);
            break;
          case 'canny':
            edgeData = applyCanny(grayData, width, height);
            break;
          case 'laplacian':
            edgeData = applyLaplacian(grayData, width, height);
            break;
          default:
            edgeData = applySobel(grayData, width, height);
        }
        
        updateProgress(80);
        
        // رسم الحواف على canvas الحواف
        const edgeImageData = new ImageData(width, height);
        const threshold = parseInt(edgeThreshold.value);
        
        for (let i = 0; i < edgeData.length; i++) {
          const value = edgeData[i] > threshold ? 255 : 0;
          const idx = i * 4;
          edgeImageData.data[idx] = value;
          edgeImageData.data[idx+1] = value;
          edgeImageData.data[idx+2] = value;
          edgeImageData.data[idx+3] = 255;
        }
        
        ctxEdges.putImageData(edgeImageData, 0, 0);
        
        // حفظ بيانات الحواف للاستخدام لاحقاً
        edgesImageData = edgeImageData;
        
        updateProgress(100);
        showNotification('تم كشف الحواف بنجاح باستخدام ' + algorithm);
      }, 100);
    }

    // تطبيق كاشف Sobel
    function applySobel(grayData, width, height) {
      const sobelData = new Uint8ClampedArray(width * height);
      
      // مرشحات Sobel
      const sobelX = [-1, 0, 1, -2, 0, 2, -1, 0, 1];
      const sobelY = [-1, -2, -1, 0, 0, 0, 1, 2, 1];
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          let gx = 0;
          let gy = 0;
          
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx = (y + ky) * width + (x + kx);
              const kernelIdx = (ky + 1) * 3 + (kx + 1);
              
              gx += grayData[idx] * sobelX[kernelIdx];
              gy += grayData[idx] * sobelY[kernelIdx];
            }
          }
          
          const magnitude = Math.sqrt(gx * gx + gy * gy);
          sobelData[y * width + x] = magnitude;
        }
      }
      
      return sobelData;
    }

    // تطبيق كاشف Canny المبسط
    function applyCanny(grayData, width, height) {
      // أولاً نطبق Sobel للحصول على المقدار والاتجاه
      const sobelData = applySobel(grayData, width, height);
      
      // ثم نقوم بقمع غير القيم القصوى (تبسيط للخوارزمية)
      const cannyData = new Uint8ClampedArray(width * height);
      
      for (let y = 2; y < height - 2; y++) {
        for (let x = 2; x < width - 2; x++) {
          const idx = y * width + x;
          const value = sobelData[idx];
          
          // قمع غير القيم القصوى (تبسيط)
          if (value > sobelData[idx - 1] && value > sobelData[idx + 1]) {
            cannyData[idx] = value;
          } else {
            cannyData[idx] = 0;
          }
        }
      }
      
      return cannyData;
    }

    // تطبيق كاشف Laplacian
    function applyLaplacian(grayData, width, height) {
      const laplacianData = new Uint8ClampedArray(width * height);
      const laplacianKernel = [0, 1, 0, 1, -4, 1, 0, 1, 0];
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          let sum = 0;
          
          for (let ky = -1; ky <= 1; ky++) {
            for (let kx = -1; kx <= 1; kx++) {
              const idx = (y + ky) * width + (x + kx);
              const kernelIdx = (ky + 1) * 3 + (kx + 1);
              
              sum += grayData[idx] * laplacianKernel[kernelIdx];
            }
          }
          
          laplacianData[y * width + x] = Math.abs(sum);
        }
      }
      
      return laplacianData;
    }

    // تحديث كشف الحواف عند تغيير العتبة
    function updateEdgeDetection() {
      if (!edgesImageData) return;
      
      const width = edgesCanvas.width;
      const height = edgesCanvas.height;
      const threshold = parseInt(edgeThreshold.value);
      const newImageData = new ImageData(width, height);
      
      for (let i = 0; i < edgesImageData.data.length; i += 4) {
        const value = edgesImageData.data[i] > threshold ? 255 : 0;
        newImageData.data[i] = value;
        newImageData.data[i+1] = value;
        newImageData.data[i+2] = value;
        newImageData.data[i+3] = 255;
      }
      
      ctxEdges.putImageData(newImageData, 0, 0);
    }

    // ============== دوال تحليل الصورة ==============

    // دالة لتحليل الصورة باستخدام الذكاء الاصطناعي
    async function analyzeImage() {
      if (!originalImageData) {
        showNotification('يجب تحميل صورة أولاً', true);
        return;
      }

      showNotification('جاري تحليل الصورة بالذكاء الاصطناعي...', false, 'analysis');
      updateProgress(10);
      
      try {
        // محاكاة عملية التحليل
        await new Promise(resolve => setTimeout(resolve, 1000));
        updateProgress(30);
        
        // تحليل الارتفاعات والمنحدرات
        const analysis = await analyzeHeightsAndSlopes();
        updateProgress(70);
        
        // تحليل الحواف
        const edgeAnalysis = await analyzeEdges();
        updateProgress(90);
        
        // دمج نتائج التحليل
        analysisData = {
          ...analysis,
          ...edgeAnalysis,
          complexity: calculateComplexity(analysis, edgeAnalysis)
        };
        
        // عرض نتائج التحليل
        displayAnalysisResults(analysisData);
        updateProgress(100);
        
        showNotification('تم تحليل الصورة بنجاح', false, 'analysis');
      } catch (error) {
        console.error('Error analyzing image:', error);
        showNotification('فشل في تحليل الصورة', true);
      }
    }

    // دالة لتحليل الارتفاعات والمنحدرات
    async function analyzeHeightsAndSlopes() {
      if (!heightMapData) return {};
      
      const width = heightMapData.width;
      const height = heightMapData.height;
      const data = heightMapData.data;
      
      let minHeight = 255;
      let maxHeight = 0;
      let totalHeight = 0;
      let slopeSum = 0;
      let slopeCount = 0;
      
      // تحليل الارتفاعات
      for (let i = 0; i < data.length; i += 4) {
        const pixelHeight = 0.34 * data[i] + 0.5 * data[i+1] + 0.16 * data[i+2];
        minHeight = Math.min(minHeight, pixelHeight);
        maxHeight = Math.max(maxHeight, pixelHeight);
        totalHeight += pixelHeight;
      }
      
      const avgHeight = totalHeight / (data.length / 4);
      
      // تحليل المنحدرات
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          const idx = (y * width + x) * 4;
          const center = 0.34 * data[idx] + 0.5 * data[idx+1] + 0.16 * data[idx+2];
          
          // حساب المنحدر مع الجيران
          const right = 0.34 * data[idx+4] + 0.5 * data[idx+5] + 0.16 * data[idx+6];
          const bottom = 0.34 * data[idx+width*4] + 0.5 * data[idx+width*4+1] + 0.16 * data[idx+width*4+2];
          
          const slopeX = Math.abs(center - right);
          const slopeY = Math.abs(center - bottom);
          
          slopeSum += (slopeX + slopeY) / 2;
          slopeCount++;
        }
      }
      
      const avgSlope = slopeSum / slopeCount;
      
      return {
        minHeight: minHeight,
        maxHeight: maxHeight,
        avgHeight: avgHeight,
        heightRange: maxHeight - minHeight,
        avgSlope: avgSlope
      };
    }

    // دالة لتحليل الحواف
    async function analyzeEdges() {
      if (!edgesImageData) return {};
      
      const width = edgesCanvas.width;
      const height = edgesCanvas.height;
      const data = edgesImageData.data;
      
      let edgePixels = 0;
      let totalPixels = width * height;
      
      for (let i = 0; i < data.length; i += 4) {
        if (data[i] > 128) { // إذا كان البيكسل يعتبر حافة
          edgePixels++;
        }
      }
      
      const edgeDensity = edgePixels / totalPixels;
      
      return {
        edgePixels: edgePixels,
        edgeDensity: edgeDensity
      };
    }

    // دالة لحساب تعقيد الصورة
    function calculateComplexity(heightAnalysis, edgeAnalysis) {
      if (!heightAnalysis || !edgeAnalysis) return 0;
      
      // حساب التعقيد بناءً على نطاق الارتفاع وكثافة الحواف
      const heightComplexity = heightAnalysis.heightRange / 255; // تطبيع بين 0 و1
      const edgeComplexity = edgeAnalysis.edgeDensity * 10; // تضخيم التأثير
      const slopeComplexity = heightAnalysis.avgSlope / 100; // تطبيع
      
      // دمج العوامل مع أوزان مختلفة
      const complexity = (heightComplexity * 0.4) + (edgeComplexity * 0.4) + (slopeComplexity * 0.2);
      
      // التأكد من أن النتيجة بين 0 و1
      return Math.min(1, Math.max(0, complexity));
    }

    // دالة لعرض نتائج التحليل
    function displayAnalysisResults(analysis) {
      analysisPanel.style.display = 'block';
      
      analysisResults.innerHTML = `
        <div class="analysis-item">
          <h4>📏 نطاق الارتفاع</h4>
          <div class="analysis-value">${analysis.heightRange ? analysis.heightRange.toFixed(1) : 'N/A'}</div>
          <div>من ${analysis.minHeight ? analysis.minHeight.toFixed(1) : 'N/A'} إلى ${analysis.maxHeight ? analysis.maxHeight.toFixed(1) : 'N/A'}</div>
        </div>
        <div class="analysis-item">
          <h4>📈 متوسط الارتفاع</h4>
          <div class="analysis-value">${analysis.avgHeight ? analysis.avgHeight.toFixed(1) : 'N/A'}</div>
          <div>من 255</div>
        </div>
        <div class="analysis-item">
          <h4>🔄 متوسط المنحدر</h4>
          <div class="analysis-value">${analysis.avgSlope ? analysis.avgSlope.toFixed(2) : 'N/A'}</div>
          <div>درجة الانحدار</div>
        </div>
        <div class="analysis-item">
          <h4>🔍 كثافة الحواف</h4>
          <div class="analysis-value">${analysis.edgeDensity ? (analysis.edgeDensity * 100).toFixed(1) + '%' : 'N/A'}</div>
          <div>${analysis.edgePixels || 'N/A'} بيكسل</div>
        </div>
        <div class="analysis-item">
          <h4>🧩 مستوى التعقيد</h4>
          <div class="analysis-value">${analysis.complexity ? (analysis.complexity * 100).toFixed(1) + '%' : 'N/A'}</div>
          <div>${getComplexityLevel(analysis.complexity)}</div>
        </div>
      `;
    }

    // دالة للحصول على مستوى التعقيد كنص
    function getComplexityLevel(complexity) {
      if (complexity < 0.3) return 'منخفض';
      if (complexity < 0.6) return 'متوسط';
      return 'عالي';
    }

    // ============== دوال توليد G-code باستخدام الذكاء الاصطناعي ==============

    // دالة لتحويل الصورة إلى بيانات ارتفاع باستخدام TensorFlow.js
    async function processImageWithAI(imageData) {
      showNotification('جاري معالجة الصورة بالذكاء الاصطناعي...', false, 'ai');
      updateProgress(10);
      
      // تحويل ImageData إلى tensor
      const tensor = tf.browser.fromPixels(imageData);
      updateProgress(20);
      
      // تحويل إلى تدرج الرمادي
      let processed = tensor.mean(2).expandDims(2);
      updateProgress(30);
      
      // تطبيق مرشح Gaussian لتخفيف الضوضاء
      processed = tf.tidy(() => {
        const kernel = tf.tensor2d([
          [1, 2, 1],
          [2, 4, 2],
          [1, 2, 1]
        ], [3, 3]).div(16);
        
        return tf.depthwiseConv2d(
          processed, 
          kernel.expandDims(2).expandDims(3), 
          1, 
          'same'
        );
      });
      updateProgress(50);
      
      // زيادة التباين لتحسين نتائج القطع
      processed = tf.tidy(() => {
        const mean = processed.mean();
        const std = processed.sub(mean).square().mean().sqrt();
        return processed.sub(mean).div(std.add(1e-7)).clipByValue(-2, 2).add(2).div(4);
      });
      updateProgress(70);
      
      // الحصول على البيانات المعالجة
      const data = await processed.squeeze().array();
      updateProgress(90);
      
      // تنظيف الذاكرة
      tensor.dispose();
      processed.dispose();
      updateProgress(100);
      
      return data;
    }

    // دالة لتحسين المسارات باستخدام خوارزمية TSP المبسطة
    function optimizeToolpaths(points) {
      if (points.length <= 1) return points;
      
      // استخدام خوارزمية أقرب الجار لتحسين المسار
      const optimized = [points[0]];
      const remaining = points.slice(1);
      
      while (remaining.length > 0) {
        const lastPoint = optimized[optimized.length - 1];
        let closestIdx = 0;
        let minDist = Infinity;
        
        for (let i = 0; i < remaining.length; i++) {
          const dist = Math.sqrt(
            Math.pow(lastPoint.x - remaining[i].x, 2) + 
            Math.pow(lastPoint.y - remaining[i].y, 2)
          );
          
          if (dist < minDist) {
            minDist = dist;
            closestIdx = i;
          }
        }
        
        optimized.push(remaining[closestIdx]);
        remaining.splice(closestIdx, 1);
      }
      
      return optimized;
    }

    // دالة لاستخراج نقاط الحواف من بيانات الصورة
    function extractEdgePoints(edgeData, width, height, cutDepth) {
      const points = [];
      const threshold = parseInt(edgeThreshold.value);
      
      for (let y = 0; y < height; y += 2) { // تقليل العينة لتحسين الأداء
        for (let x = 0; x < width; x += 2) {
          const idx = y * width + x;
          if (edgeData[idx] > threshold) {
            points.push({
              x: (x / width) * 100 - 50, // تحويل إلى إحداثيات من -50 إلى 50
              y: (y / height) * 100 - 50,
              z: -cutDepth
            });
          }
        }
      }
      
      return points;
    }

    // دالة لاستخراج نقاط من التحديد اليدوي
    function extractManualSelectionPoints(manualData, width, height, cutDepth) {
      const points = [];
      const threshold = 50; // عتبة الشفافية
      
      for (let y = 0; y < height; y += 2) { // تقليل العينة لتحسين الأداء
        for (let x = 0; x < width; x += 2) {
          const idx = (y * width + x) * 4 + 3; // قناة الشفافية
          if (manualData.data[idx] > threshold) {
            points.push({
              x: (x / width) * 100 - 50, // تحويل إلى إحداثيات من -50 إلى 50
              y: (y / height) * 100 - 50,
              z: -cutDepth
            });
          }
        }
      }
      
      return points;
    }

    // دالة لتوليد G-code حقيقي من بيانات الصورة
    async function generateRealGcode(stage = null) {
      if (!heightMapData || !originalImageData) {
        showNotification('يجب تحميل صورة أولاً', true);
        return '';
      }

      const machineType = document.getElementById('machineType').value;
      const materialType = document.getElementById('materialType').value;
      let feedRate = parseInt(document.getElementById('feedRate').value);
      let spindleSpeed = parseInt(document.getElementById('spindleSpeed').value);
      let cutDepth = parseFloat(document.getElementById('cutDepth').value);
      let passDepth = parseFloat(document.getElementById('passDepth').value);
      const gcodePrecision = document.getElementById('gcodePrecision').value;
      const gcodeType = document.getElementById('gcodeType').value;
      const optimizePaths = document.getElementById('optimizePaths').checked;
      const smoothEdges = document.getElementById('smoothEdges').checked;
      const useEdges = document.getElementById('useEdges').checked;
      const startFromEdges = document.getElementById('startFromEdges').checked;
      const useManualSelection = document.getElementById('useManualSelection').checked;
      
      // إذا كانت مرحلة محددة، استخدام إعداداتها
      if (stage) {
        if (stage === 'roughing') {
          feedRate = parseInt(document.getElementById('roughingFeedRate').value);
          spindleSpeed = parseInt(document.getElementById('roughingSpindleSpeed').value);
          cutDepth = parseFloat(document.getElementById('roughingDepth').value);
        } else if (stage === 'finishing') {
          feedRate = parseInt(document.getElementById('finishingFeedRate').value);
          spindleSpeed = parseInt(document.getElementById('finishingSpindleSpeed').value);
          cutDepth = parseFloat(document.getElementById('finishingDepth').value);
        } else if (stage === 'smoothing') {
          feedRate = parseInt(document.getElementById('smoothingFeedRate').value);
          spindleSpeed = parseInt(document.getElementById('smoothingSpindleSpeed').value);
          cutDepth = parseFloat(document.getElementById('smoothingDepth').value);
        }
      }
      
      // تحديد الدقة بناءً على الإعدادات
      let resolution = 5; // منخفضة
      if (gcodePrecision === 'medium') resolution = 3;
      if (gcodePrecision === 'high') resolution = 1;
      
      updateProgress(10);
      
      let points = [];
      
      if (useManualSelection && manualSelectionData && gcodeType === 'manual') {
        // استخدام التحديد اليدوي لتوليد المسارات
        points = extractManualSelectionPoints(manualSelectionData, canvas2d.width, canvas2d.height, cutDepth);
        updateProgress(50);
      } else if (useEdges && edgesImageData && gcodeType === 'edges') {
        // استخدام حواف الصورة لتوليد المسارات
        const width = edgesCanvas.width;
        const height = edgesCanvas.height;
        const edgeData = new Uint8ClampedArray(width * height);
        
        for (let i = 0; i < edgesImageData.data.length; i += 4) {
          edgeData[i/4] = edgesImageData.data[i];
        }
        
        points = extractEdgePoints(edgeData, width, height, cutDepth);
        updateProgress(50);
      } else {
        // استخدام طريقة الارتفاع التقليدية
        const heightData = await processImageWithAI(originalImageData);
        updateProgress(50);
        
        const width = canvas2d.width;
        const height = canvas2d.height;
        
        for (let y = 0; y < height; y += resolution) {
          for (let x = 0; x < width; x += resolution) {
            const idx = Math.floor(y) * width + Math.floor(x);
            if (idx < heightData.length * width) {
              const pixelValue = heightData[Math.floor(y)][Math.floor(x)] || 0;
              // تحويل قيمة البيكسل إلى عمق قطع (القيم الأغمق = قطع أعمق)
              const depth = (1 - pixelValue) * cutDepth;
              
              points.push({
                x: (x / width) * 100 - 50, // تحويل إلى إحداثيات من -50 إلى 50
                y: (y / height) * 100 - 50,
                z: -depth
              });
            }
          }
        }
      }
      
      updateProgress(70);
      
      // البدء من الحواف إذا كان الخيار مفعلاً
      if (startFromEdges && edgesImageData) {
        points = sortPointsFromEdges(points);
      }
      
      // تحسين المسارات إذا كان الخيار مفعلاً
      toolPaths = optimizePaths ? optimizeToolpaths(points) : points;
      updateProgress(80);
      
      // توليد G-code
      let gcode = `; G-code generated by CNC AI with TensorFlow.js\n`;
      gcode += `; Machine: ${machineType}\n`;
      gcode += `; Material: ${materialType}\n`;
      if (stage) gcode += `; Stage: ${stage}\n`;
      gcode += `; Feed rate: ${feedRate} mm/min\n`;
      gcode += `; Spindle speed: ${spindleSpeed} RPM\n`;
      gcode += `; Total points: ${toolPaths.length}\n\n`;
      
      gcode += `G21 ; Set units to millimeters\n`;
      gcode += `G90 ; Absolute positioning\n`;
      gcode += `G0 Z5 ; Lift spindle\n`;
      gcode += `M3 S${spindleSpeed} ; Spindle on\n`;
      gcode += `G4 P2 ; Wait for spindle to reach speed\n\n`;
      
      gcode += `; Start cutting path\n`;
      gcode += `G0 X${toolPaths[0].x.toFixed(3)} Y${toolPaths[0].y.toFixed(3)} ; Move to start position\n`;
      
      // إضافة أوامر الحركة
      for (let i = 0; i < toolPaths.length; i++) {
        const point = toolPaths[i];
        gcode += `G1 X${point.x.toFixed(3)} Y${point.y.toFixed(3)} Z${point.z.toFixed(3)} F${feedRate}\n`;
      }
      
      gcode += `\nG0 Z5 ; Lift spindle\n`;
      gcode += `M5 ; Spindle off\n`;
      gcode += `G0 X0 Y0 ; Return to home\n`;
      gcode += `M30 ; End program\n`;
      
      updateProgress(100);
      return gcode;
    }

    // دالة لترتيب النقاط بدءًا من الحواف
    function sortPointsFromEdges(points) {
      if (!edgesImageData || points.length === 0) return points;
      
      // إنشاء نسخة من النقاط
      const sortedPoints = [...points];
      
      // تحديد النقاط التي تقع على الحواف
      const edgePoints = [];
      const nonEdgePoints = [];
      
      const width = edgesCanvas.width;
      const height = edgesCanvas.height;
      
      for (const point of sortedPoints) {
        // تحويل الإحداثيات إلى إحداثيات الصورة
        const x = Math.floor((point.x + 50) * width / 100);
        const y = Math.floor((point.y + 50) * height / 100);
        
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const idx = (y * width + x) * 4;
          if (edgesImageData.data[idx] > 128) {
            edgePoints.push(point);
          } else {
            nonEdgePoints.push(point);
          }
        } else {
          nonEdgePoints.push(point);
        }
      }
      
      // الجمع بين النقاط مع البدء بالحواف
      return [...edgePoints, ...nonEdgePoints];
    }

    // دالة لتوليد G-code
    async function generateGcode() {
      if (!heightMapData) {
        showNotification('يجب تحميل صورة أولاً', true);
        return;
      }

      gcodeOutput.textContent = "⏳ جاري توليد G-code باستخدام الذكاء الاصطناعي...";
      progressContainer.style.display = 'block';
      
      try {
        const gcode = await generateRealGcode();
        generatedGcode = gcode;
        gcodeOutput.textContent = gcode;
        
        // عرض إحصائيات G-code
        displayGcodeStats(gcode);
        
        // تحديث معاينة المسارات
        updatePathPreview();
        
        showNotification('تم توليد G-code بنجاح باستخدام الذكاء الاصطناعي', false, 'ai');
      } catch (error) {
        console.error('Error generating G-code:', error);
        showNotification('فشل في توليد G-code', true);
      }
    }

    // دالة لتوليد G-code لمرحلة محددة
    async function generateStageGcode(stage) {
      if (!heightMapData) {
        showNotification('يجب تحميل صورة أولاً', true);
        return;
      }

      showNotification(`جاري توليد G-code لمرحلة ${stage}...`, false, 'analysis');
      progressContainer.style.display = 'block';
      
      try {
        const gcode = await generateRealGcode(stage);
        stageGcodes[stage] = gcode;
        
        showNotification(`تم توليد G-code لمرحلة ${stage} بنجاح`, false, 'analysis');
      } catch (error) {
        console.error(`Error generating ${stage} G-code:`, error);
        showNotification(`فشل في توليد G-code لمرحلة ${stage}`, true);
      }
    }

    // دالة لتحميل G-code لمرحلة محددة
    function downloadStageGcode(stage) {
      if (!stageGcodes[stage]) {
        showNotification(`لا يوجد G-code لمرحلة ${stage}`, true);
        return;
      }
      
      const blob = new Blob([stageGcodes[stage]], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `cnc-ai-${stage}.gcode`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showNotification(`تم تحميل ملف ${stage} بنجاح`);
    }

    // دالة لعرض إحصائيات G-code
    function displayGcodeStats(gcode) {
      gcodePreview.style.display = 'block';
      
      // تحليل G-code لاستخراج الإحصائيات
      const lines = gcode.split('\n');
      const commandLines = lines.filter(line => line.startsWith('G0') || line.startsWith('G1'));
      const totalDistance = calculateTotalDistance(commandLines);
      const estimatedTime = calculateEstimatedTime(totalDistance);
      
      gcodeStats.innerHTML = `
        <div class="stat-item">
          <h4>📏 عدد المسارات</h4>
          <div class="stat-value">${commandLines.length}</div>
          <div>مسار قطع</div>
        </div>
        <div class="stat-item">
          <h4>📐 المسافة الإجمالية</h4>
          <div class="stat-value">${totalDistance.toFixed(2)}</div>
          <div>ملم</div>
        </div>
        <div class="stat-item">
          <h4>⏱ الوقت المتوقع</h4>
          <div class="stat-value">${estimatedTime.toFixed(1)}</div>
          <div>دقيقة</div>
        </div>
        <div class="stat-item">
          <h4>📊 حجم الملف</h4>
          <div class="stat-value">${(gcode.length / 1024).toFixed(2)}</div>
          <div>كيلوبا이트</div>
        </div>
      `;
    }

    // دالة لحساب المسافة الإجمالية من أوامر G-code
    function calculateTotalDistance(commandLines) {
      let totalDistance = 0;
      let lastX = 0;
      let lastY = 0;
      let lastZ = 0;
      
      for (const line of commandLines) {
        const xMatch = line.match(/X([-\d.]+)/);
        const yMatch = line.match(/Y([-\d.]+)/);
        const zMatch = line.match(/Z([-\d.]+)/);
        
        const x = xMatch ? parseFloat(xMatch[1]) : lastX;
        const y = yMatch ? parseFloat(yMatch[1]) : lastY;
        const z = zMatch ? parseFloat(zMatch[1]) : lastZ;
        
        const distance = Math.sqrt(
          Math.pow(x - lastX, 2) + 
          Math.pow(y - lastY, 2) + 
          Math.pow(z - lastZ, 2)
        );
        
        totalDistance += distance;
        
        lastX = x;
        lastY = y;
        lastZ = z;
      }
      
      return totalDistance;
    }

    // دالة لحساب الوقت المتوقع للقطع
    function calculateEstimatedTime(totalDistance) {
      const feedRate = parseInt(document.getElementById('feedRate').value);
      return totalDistance / feedRate * 60; // تحويل إلى دقائق
    }

    // دالة لتحميل G-code
    function downloadGcode() {
      if (!generatedGcode) {
        showNotification('لا يوجد G-code لتحميله', true);
        return;
      }
      
      const blob = new Blob([generatedGcode], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'cnc-ai-program.gcode';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showNotification('تم تحميل الملف بنجاح');
    }

    // دالة لتحديث معاينة مسارات القطع
    function updatePathPreview() {
      if (toolPaths.length === 0) return;
      
      const svg = document.getElementById('pathSvg');
      svg.innerHTML = '';
      
      const width = 400;
      const height = 300;
      const padding = 20;
      
      // إعداد عنصر SVG
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      
      // حساب نطاق الإحداثيات
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      
      for (const point of toolPaths) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
      
      // تحجيم الإحداثيات لتناسب SVG
      const scaleX = (width - 2 * padding) / (maxX - minX);
      const scaleY = (height - 2 * padding) / (maxY - minY);
      const scale = Math.min(scaleX, scaleY);
      
      // تحويل النقاط إلى إحداثيات SVG
      const svgPoints = toolPaths.map(point => {
        const x = padding + (point.x - minX) * scale;
        const y = height - padding - (point.y - minY) * scale;
        return { x, y, z: point.z };
      });
      
      // رسم المسارات
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      let d = `M ${svgPoints[0].x} ${svgPoints[0].y}`;
      
      for (let i = 1; i < svgPoints.length; i++) {
        d += ` L ${svgPoints[i].x} ${svgPoints[i].y}`;
      }
      
      path.setAttribute('d', d);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', '#4a90e2');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('stroke-linejoin', 'round');
      
      svg.appendChild(path);
      
      // رسم النقاط
      for (let i = 0; i < svgPoints.length; i += Math.floor(svgPoints.length / 50)) {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', svgPoints[i].x);
        circle.setAttribute('cy', svgPoints[i].y);
        circle.setAttribute('r', '2');
        circle.setAttribute('fill', '#e74c3c');
        svg.appendChild(circle);
      }
    }

    // دالة لتحسين المسارات
    function optimizePaths() {
      if (toolPaths.length === 0) {
        showNotification('لا توجد مسارات لتحسينها', true);
        return;
      }
      
      showNotification('جاري تحسين المسارات...', false, 'analysis');
      
      // محاكاة عملية التحسين
      setTimeout(() => {
        toolPaths = optimizeToolpaths(toolPaths);
        updatePathPreview();
        showNotification('تم تحسين المسارات بنجاح', false, 'analysis');
      }, 1000);
    }

    // دالة لتوليد مسارات متقدمة
    function generateAdvancedPaths() {
      if (toolPaths.length === 0) {
        showNotification('يجب توليد المسارات الأساسية أولاً', true);
        return;
      }
      
      showNotification('جاري توليد مسارات متقدمة...', false, 'analysis');
      
      // محاكاة عملية توليد المسارات المتقدمة
      setTimeout(() => {
        advancedToolPaths = [...toolPaths];
        
        // تطبيق تحسينات إضافية
        if (document.getElementById('adaptivePaths').checked) {
          advancedToolPaths = applyAdaptivePaths(advancedToolPaths);
        }
        
        if (document.getElementById('reduceLift').checked) {
          advancedToolPaths = reduceLiftMoves(advancedToolPaths);
        }
        
        if (document.getElementById('optimizeOrder').checked) {
          advancedToolPaths = optimizePathOrder(advancedToolPaths);
        }
        
        if (document.getElementById('minimizeTravel').checked) {
          advancedToolPaths = minimizeTravelDistance(advancedToolPaths);
        }
        
        // تحديث معاينة المسارات المتقدمة
        updateAdvancedPathPreview();
        
        showNotification('تم توليد المسارات المتقدمة بنجاح', false, 'analysis');
      }, 1500);
    }

    // دالة لتطبيق مسارات تكيفية
    function applyAdaptivePaths(paths) {
      // محاكاة المسارات التكيفية بناءً على الارتفاع
      return paths.map(point => {
        // تقليل كثافة النقاط في المناطق المسطحة
        const intensity = Math.abs(point.z) / 10;
        return {
          ...point,
          x: point.x + (Math.random() * 2 - 1) * intensity,
          y: point.y + (Math.random() * 2 - 1) * intensity
        };
      });
    }

    // دالة لتقليل عمليات الرفع
    function reduceLiftMoves(paths) {
      // محاكاة تقليل عمليات الرفع
      const newPaths = [];
      let lastZ = 0;
      
      for (const point of paths) {
        if (Math.abs(point.z - lastZ) < 2) {
          newPaths.push(point);
        } else {
          // إضافة نقطة وسيطة لتقليل الرفع المفاجئ
          newPaths.push({ x: point.x, y: point.y, z: lastZ + (point.z - lastZ) / 2 });
          newPaths.push(point);
        }
        lastZ = point.z;
      }
      
      return newPaths;
    }

    // دالة لتحسين ترتيب المسارات
    function optimizePathOrder(paths) {
      // محاكاة تحسين ترتيب المسارات
      return [...paths].sort((a, b) => {
        // ترتيب بناءً على الإحداثيات لتحسين الكفاءة
        if (a.x !== b.x) return a.x - b.x;
        if (a.y !== b.y) return a.y - b.y;
        return a.z - b.z;
      });
    }

    // دالة لتقليل مسافات التنقل
    function minimizeTravelDistance(paths) {
      // محاكاة تقليل مسافات التنقل
      if (paths.length <= 1) return paths;
      
      const optimized = [paths[0]];
      const remaining = paths.slice(1);
      
      while (remaining.length > 0) {
        const lastPoint = optimized[optimized.length - 1];
        let closestIdx = 0;
        let minDist = Infinity;
        
        for (let i = 0; i < remaining.length; i++) {
          const dist = Math.sqrt(
            Math.pow(lastPoint.x - remaining[i].x, 2) + 
            Math.pow(lastPoint.y - remaining[i].y, 2) + 
            Math.pow(lastPoint.z - remaining[i].z, 2)
          );
          
          if (dist < minDist) {
            minDist = dist;
            closestIdx = i;
          }
        }
        
        optimized.push(remaining[closestIdx]);
        remaining.splice(closestIdx, 1);
      }
      
      return optimized;
    }

    // دالة لتحديث معاينة المسارات المتقدمة
    function updateAdvancedPathPreview() {
      if (advancedToolPaths.length === 0) return;
      
      const svg = document.getElementById('advancedPathSvg');
      svg.innerHTML = '';
      
      const width = 400;
      const height = 300;
      const padding = 20;
      
      // إعداد عنصر SVG
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      
      // حساب نطاق الإحداثيات
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      
      for (const point of advancedToolPaths) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
      
      // تحجيم الإحداثيات لتناسب SVG
      const scaleX = (width - 2 * padding) / (maxX - minX);
      const scaleY = (height - 2 * padding) / (maxY - minY);
      const scale = Math.min(scaleX, scaleY);
      
      // تحويل النقاط إلى إحداثيات SVG
      const svgPoints = advancedToolPaths.map(point => {
        const x = padding + (point.x - minX) * scale;
        const y = height - padding - (point.y - minY) * scale;
        return { x, y, z: point.z };
      });
      
      // رسم المسارات
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      let d = `M ${svgPoints[0].x} ${svgPoints[0].y}`;
      
      for (let i = 1; i < svgPoints.length; i++) {
        d += ` L ${svgPoints[i].x} ${svgPoints[i].y}`;
      }
      
      path.setAttribute('d', d);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', '#9c27b0');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('stroke-linejoin', 'round');
      
      svg.appendChild(path);
      
      // رسم النقاط
      for (let i = 0; i < svgPoints.length; i += Math.floor(svgPoints.length / 50)) {
        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('cx', svgPoints[i].x);
        circle.setAttribute('cy', svgPoints[i].y);
        circle.setAttribute('r', '2');
        circle.setAttribute('fill', '#e74c3c');
        svg.appendChild(circle);
      }
    }

    // دالة لتحليل المسارات
    function analyzePaths() {
      if (advancedToolPaths.length === 0) {
        showNotification('لا توجد مسارات لتحليلها', true);
        return;
      }
      
      showNotification('جاري تحليل المسارات...', false, 'analysis');
      
      // محاكاة عملية التحليل
      setTimeout(() => {
        const totalDistance = calculatePathsDistance(advancedToolPaths);
        const efficiency = calculatePathsEfficiency(advancedToolPaths);
        
        showNotification(`تم تحليل المسارات: المسافة ${totalDistance.toFixed(2)} ملم، الكفاءة ${efficiency.toFixed(1)}%`, false, 'analysis');
      }, 1000);
    }

    // دالة لحساب مسافة المسارات
    function calculatePathsDistance(paths) {
      let totalDistance = 0;
      
      for (let i = 1; i < paths.length; i++) {
        const dist = Math.sqrt(
          Math.pow(paths[i].x - paths[i-1].x, 2) + 
          Math.pow(paths[i].y - paths[i-1].y, 2) + 
          Math.pow(paths[i].z - paths[i-1].z, 2)
        );
        totalDistance += dist;
      }
      
      return totalDistance;
    }

    // دالة لحساب كفاءة المسارات
    function calculatePathsEfficiency(paths) {
      if (paths.length <= 1) return 100;
      
      // حساب المسافة الفعلية
      const actualDistance = calculatePathsDistance(paths);
      
      // حساب المسافة المثالية (المسافة بين أول وآخر نقطة)
      const idealDistance = Math.sqrt(
        Math.pow(paths[paths.length-1].x - paths[0].x, 2) + 
        Math.pow(paths[paths.length-1].y - paths[0].y, 2) + 
        Math.pow(paths[paths.length-1].z - paths[0].z, 2)
      );
      
      // حساب الكفاءة
      return (idealDistance / actualDistance) * 100;
    }

    // دالة لحفظ الإعدادات المتقدمة
    function saveAdvancedSettings() {
      const settings = {
        xSpeed: document.getElementById('xSpeed').value,
        ySpeed: document.getElementById('ySpeed').value,
        zSpeed: document.getElementById('zSpeed').value,
        acceleration: document.getElementById('acceleration').value,
        tolerance: document.getElementById('tolerance').value,
        stepover: document.getElementById('stepover').value,
        resolution: document.getElementById('resolution').value,
        retractDistance: document.getElementById('retractDistance').value,
        retractSpeed: document.getElementById('retractSpeed').value,
        plungeSpeed: document.getElementById('plungeSpeed').value,
        coolant: document.getElementById('coolant').value
      };
      
      localStorage.setItem('cncAdvancedSettings', JSON.stringify(settings));
      showNotification('تم حفظ الإعدادات المتقدمة بنجاح');
    }

    // دالة لتحميل الإعدادات المتقدمة الافتراضية
    function loadDefaultAdvancedSettings() {
      document.getElementById('xSpeed').value = 3000;
      document.getElementById('ySpeed').value = 3000;
      document.getElementById('zSpeed').value = 1000;
      document.getElementById('acceleration').value = 500;
      document.getElementById('tolerance').value = 0.01;
      document.getElementById('stepover').value = 50;
      document.getElementById('resolution').value = 'medium';
      document.getElementById('retractDistance').value = 5;
      document.getElementById('retractSpeed').value = 1200;
      document.getElementById('plungeSpeed').value = 300;
      document.getElementById('coolant').value = 'none';
      
      showNotification('تم تحميل الإعدادات الافتراضية');
    }

    // تحميل الإعدادات المتقدمة المحفوظة
    window.addEventListener('load', () => {
      const savedSettings = localStorage.getItem('cncAdvancedSettings');
      if (savedSettings) {
        const settings = JSON.parse(savedSettings);
        document.getElementById('xSpeed').value = settings.xSpeed;
        document.getElementById('ySpeed').value = settings.ySpeed;
        document.getElementById('zSpeed').value = settings.zSpeed;
        document.getElementById('acceleration').value = settings.acceleration;
        document.getElementById('tolerance').value = settings.tolerance;
        document.getElementById('stepover').value = settings.stepover;
        document.getElementById('resolution').value = settings.resolution;
        document.getElementById('retractDistance').value = settings.retractDistance;
        document.getElementById('retractSpeed').value = settings.retractSpeed;
        document.getElementById('plungeSpeed').value = settings.plungeSpeed;
        document.getElementById('coolant').value = settings.coolant;
      }
    });

    // تحديث خيارات الخامة بناءً على نوع الماكينة
    document.getElementById('machineType').addEventListener('change', function() {
      const materialSelect = document.getElementById('materialType');
      const machineType = this.value;
      
      // مسح الخيارات الحالية
      materialSelect.innerHTML = '';
      
      // إضافة الخيارات المناسبة بناءً على نوع الماكينة
      if (machineType === 'cnc') {
        materialSelect.innerHTML = `
          <option value="wood">خشب</option>
          <option value="acrylic">أكريليك</option>
          <option value="aluminum">ألومنيوم</option>
          <option value="steel">صلب</option>
        `;
      } else if (machineType === 'laser') {
        materialSelect.innerHTML = `
          <option value="wood">خشب</option>
          <option value="acrylic">أكريليك</option>
          <option value="leather">جلد</option>
          <option value="fabric">قماش</option>
        `;
      } else if (machineType === '3dprinter') {
        materialSelect.innerHTML = `
          <option value="pla">PLA (بلاستيك)</option>
          <option value="abs">ABS (بلاستيك)</option>
          <option value="petg">PETG (بلاستيك)</option>
          <option value="tpu">TPU (مطاطي)</option>
        `;
      }
    });

    // تنظيف الذاكرة عند إغلاق الصفحة
    window.addEventListener('beforeunload', () => {
      // تنظيف Tensors إذا كانت موجودة
      if (tf && tf.memory) {
        tf.disposeVariables();
      }
      
      // تنظيف الذاكرة من Three.js
      if (mesh) {
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
        mesh = null;
      }
      
      // تنظيف بيانات الصور
      originalImageData = null;
      edgesImageData = null;
      manualSelectionData = null;
      heightMapData = null;
      
      // إلغاء عناصر DOM المخصصة
      URL.revokeObjectURL(fileInput.src);
    });

    // تحسين أداء معالجة الصور باستخدام Web Workers
    function createImageProcessingWorker() {
      const workerCode = `
        self.addEventListener('message', function(e) {
          const { data, width, height, type } = e.data;
          let result = new Uint8ClampedArray(data);
          
          switch(type) {
            case 'brightness':
              for (let i = 0; i < data.length; i += 4) {
                result[i] = Math.min(255, data[i] + 30);
                result[i+1] = Math.min(255, data[i+1] + 30);
                result[i+2] = Math.min(255, data[i+2] + 30);
                result[i+3] = data[i+3];
              }
              break;
            case 'contrast':
              const factor = 1.2;
              for (let i = 0; i < data.length; i += 4) {
                result[i] = Math.min(255, Math.max(0, factor * (data[i] - 128) + 128));
                result[i+1] = Math.min(255, Math.max(0, factor * (data[i+1] - 128) + 128));
                result[i+2] = Math.min(255, Math.max(0, factor * (data[i+2] - 128) + 128));
                result[i+3] = data[i+3];
              }
              break;
            // يمكن إضافة المزيد من أنواع المعالجة هنا
          }
          
          self.postMessage({ result: result.buffer }, [result.buffer]);
        });
      `;
      
      const blob = new Blob([workerCode], { type: 'application/javascript' });
      return new Worker(URL.createObjectURL(blob));
    }

    // استخدام Web Worker لمعالجة الصور إذا كان متاحًا
    let imageWorker = null;
    if (window.Worker) {
      imageWorker = createImageProcessingWorker();
      imageWorker.onmessage = function(e) {
        const processedData = new Uint8ClampedArray(e.data.result);
        const imageData = new ImageData(processedData, canvas2d.width, canvas2d.height);
        ctx2d.putImageData(imageData, 0, 0);
        createHeightMapFromCanvas(canvas2d);
      };
    }
  </script>
</body>
</html>
