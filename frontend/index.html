<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CNC AI Preview - Ù…Ø­Ø³Ù‘Ù†</title>
  <style>
    /* ======= Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¹Ø§Ù…Ø© ======= */
    :root {
      --bg-color: #f9f9f9;
      --text-color: #222;
      --primary-color: #0078d7;
      --secondary-color: #005a9e;
      --border-radius: 12px;
      --shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    [data-theme="dark"] {
      --bg-color: #1e1e1e;
      --text-color: #eee;
      --primary-color: #0a84ff;
      --secondary-color: #005bb5;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, sans-serif;
    }

    body {
      background: var(--bg-color);
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: var(--primary-color);
      color: white;
      padding: 1rem;
      text-align: center;
      font-size: 1.4rem;
      font-weight: bold;
      box-shadow: var(--shadow);
    }

    /* ======= Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© ======= */
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      padding: 20px;
      flex: 1;
    }

    .preview-block {
      background: white;
      border-radius: var(--border-radius);
      padding: 15px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    [data-theme="dark"] .preview-block {
      background: #2c2c2c;
    }

    canvas {
      max-width: 100%;
      border-radius: var(--border-radius);
      background: #ddd;
    }

    /* ======= Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… ======= */
    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      padding: 10px;
      flex-wrap: wrap;
    }

    .controls button,
    .controls input[type="file"],
    .controls select {
      padding: 10px 15px;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 0.9rem;
      transition: 0.3s;
    }

    .controls button {
      background: var(--primary-color);
      color: white;
    }

    .controls button:hover {
      background: var(--secondary-color);
    }

    .slider-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--primary-color);
      color: white;
      padding: 10px 20px;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow);
      opacity: 0;
      transition: opacity 0.5s;
    }

    .notification.show {
      opacity: 1;
    }

    /* ======= Ø«ÙŠÙ… Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ ======= */
    .theme-toggle {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      color: black;
      padding: 8px 12px;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 0.8rem;
      box-shadow: var(--shadow);
    }

    [data-theme="dark"] .theme-toggle {
      background: #444;
      color: white;
    }
  </style>
</head>
<body data-theme="light">
  <header>
    ğŸ› ï¸ CNC AI Preview - Ù…Ø­Ø³Ù‘Ù†
  </header>

  <div class="container">
    <!-- Ù…Ø¹Ø§ÙŠÙ†Ø© 2D -->
    <div class="preview-block">
      <h3>ğŸ“· Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</h3>
      <canvas id="canvas2d"></canvas>
    </div>

    <!-- Ù…Ø¹Ø§ÙŠÙ†Ø© Heatmap -->
    <div class="preview-block">
      <h3>ğŸ”¥ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª (Heatmap)</h3>
      <canvas id="heatmap"></canvas>
    </div>

    <!-- Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ -->
    <div class="preview-block" style="grid-column: span 2;">
      <h3>ğŸŒ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</h3>
      <div id="preview3d" style="width:100%;height:400px;background:#000;border-radius:var(--border-radius);"></div>
    </div>
  </div>

  <!-- Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… -->
  <div class="controls">
    <input type="file" id="fileInput" accept="image/*">
    <button onclick="setColormap('jet')">Jet</button>
    <button onclick="setColormap('hot')">Hot</button>
    <button onclick="setColormap('cool')">Cool</button>
    <button onclick="setColormap('gray')">Gray</button>

    <div class="slider-group">
      <label>ğŸ” Ø³Ø±Ø¹Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†</label>
      <input type="range" id="rotationSpeed" min="0" max="0.05" step="0.001" value="0.01">
    </div>

    <div class="slider-group">
      <label>ğŸ“ Ø§Ø±ØªÙØ§Ø¹ Z</label>
      <input type="range" id="heightIntensity" min="0.1" max="5" step="0.1" value="1">
    </div>

    <div class="slider-group">
      <label>ğŸ” ØªÙƒØ¨ÙŠØ±</label>
      <input type="range" id="zoomControl" min="2" max="10" step="0.1" value="5">
    </div>

    <div class="theme-toggle" onclick="toggleTheme()">ğŸŒ™ ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø«ÙŠÙ…</div>
  </div>

  <div class="notification" id="notification"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r148/three.min.js"></script>
  <script>
    const fileInput = document.getElementById('fileInput');
    const canvas2d = document.getElementById('canvas2d');
    const ctx2d = canvas2d.getContext('2d');
    const heatmap = document.getElementById('heatmap');
    const notification = document.getElementById('notification');

    let currentColormap = 'jet';
    let rotationSpeed = 0.01;
    let heightFactor = 1;
    let scene, camera, renderer, mesh;
    let heightMapData = null;

    const rotationSpeedInput = document.getElementById('rotationSpeed');
    const heightIntensity = document.getElementById('heightIntensity');
    const zoomControl = document.getElementById('zoomControl');

    // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø«ÙŠÙ…
    function toggleTheme() {
      const body = document.body;
      body.dataset.theme = body.dataset.theme === 'light' ? 'dark' : 'light';
    }

    // Ø¥Ø´Ø¹Ø§Ø±
    function showNotification(message, isError = false) {
      notification.textContent = message;
      notification.style.background = isError ? '#d9534f' : 'var(--primary-color)';
      notification.classList.add('show');
      setTimeout(() => notification.classList.remove('show'), 3000);
    }

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (evt) => {
        const img = new Image();
        img.onload = () => {
          canvas2d.width = img.width;
          canvas2d.height = img.height;
          ctx2d.drawImage(img, 0, 0);
          createHeightMap(img);
          showNotification('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­!');
        };
        img.src = evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª
    function createHeightMap(img) {
      const w = img.width;
      const h = img.height;
      const imageData = ctx2d.getImageData(0, 0, w, h);
      const data = imageData.data;
      let min = 255, max = 0;

      const heights = new Float32Array(w * h);

      for (let i = 0; i < data.length; i += 4) {
        const brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
        heights[i / 4] = brightness;
        if (brightness < min) min = brightness;
        if (brightness > max) max = brightness;
      }

      heightMapData = { heights, w, h, min, max };
      drawHeatmap(data, w, h, min, max);
      create3DPreview(heights, w, h, min, max);
    }

    // Ø±Ø³Ù… Heatmap
    function drawHeatmap(imgData, w, h, min, max) {
      heatmap.width = w * 1.5;
      heatmap.height = h * 1.5;

      const hctx = heatmap.getContext('2d');
      const imageData = hctx.createImageData(heatmap.width, heatmap.height);

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const idx = (y * w + x) * 4;
          const brightness = 0.34 * imgData[idx] + 0.5 * imgData[idx + 1] + 0.16 * imgData[idx + 2];
          const norm = (brightness - min) / (max - min || 1);
          const color = getHeatColor(norm, currentColormap);

          const newX = Math.floor(x * 1.5);
          const newY = Math.floor(y * 1.5);
          const newIdx = (newY * heatmap.width + newX) * 4;

          imageData.data[newIdx] = color.r;
          imageData.data[newIdx + 1] = color.g;
          imageData.data[newIdx + 2] = color.b;
          imageData.data[newIdx + 3] = 255;
        }
      }

      hctx.putImageData(imageData, 0, 0);
    }

    // Colormap
    function setColormap(type) {
      currentColormap = type;
      if (heightMapData) {
        drawHeatmap(ctx2d.getImageData(0, 0, canvas2d.width, canvas2d.height).data,
                    heightMapData.w, heightMapData.h, heightMapData.min, heightMapData.max);
        create3DPreview(heightMapData.heights, heightMapData.w, heightMapData.h, heightMapData.min, heightMapData.max);
      }
    }

    function getHeatColor(value, type = 'jet') {
      let r = 0, g = 0, b = 0;
      switch (type) {
        case 'jet':
          r = Math.max(0, 255 * (1.5 - Math.abs(4 * value - 3)));
          g = Math.max(0, 255 * (1.5 - Math.abs(4 * value - 2)));
          b = Math.max(0, 255 * (1.5 - Math.abs(4 * value - 1)));
          break;
        case 'hot':
          r = 255 * value;
          g = 255 * Math.min(1, value * 2);
          b = 255 * Math.min(1, value * 0.5);
          break;
        case 'cool':
          r = 255 * value;
          g = 255 * (1 - value);
          b = 255;
          break;
        case 'gray':
          r = g = b = 255 * value;
          break;
      }
      return { r, g, b };
    }

    // Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
    function create3DPreview(heights, w, h, min, max) {
      const container = document.getElementById('preview3d');
      if (!scene) {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.z = 5;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 0, 10);
        scene.add(light);
      }

      if (mesh) {
        scene.remove(mesh);
      }

      const geometry = new THREE.PlaneGeometry(5, 5, w - 1, h - 1);

      for (let i = 0; i < geometry.attributes.position.count; i++) {
        const x = i % w;
        const y = Math.floor(i / w);
        const height = ((heights[y * w + x] - min) / (max - min)) * heightFactor;
        geometry.attributes.position.setZ(i, height);
      }

      geometry.computeVertexNormals();

      const material = new THREE.MeshStandardMaterial({ color: 0xcccccc, wireframe: false, flatShading: true });
      mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI / 2;
      scene.add(mesh);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (mesh) {
        mesh.rotation.z += rotationSpeed;
        camera.position.z = zoomControl.value;
      }
      renderer.render(scene, camera);
    }
    animate();

    // Ø§Ù„ØªØ­ÙƒÙ… ÙÙŠ Ø§Ù„Ø³Ø±Ø¹Ø© ÙˆØ§Ù„Ø§Ø±ØªÙØ§Ø¹
    rotationSpeedInput.addEventListener('input', () => {
      rotationSpeed = parseFloat(rotationSpeedInput.value);
    });

    heightIntensity.addEventListener('input', () => {
      heightFactor = parseFloat(heightIntensity.value);
      if (heightMapData) {
        create3DPreview(heightMapData.heights, heightMapData.w, heightMapData.h, heightMapData.min, heightMapData.max);
      }
    });
  </script>
</body>
</html>
