<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>CncAi v2.3 โ Dual Mode Final (Router + Laser)</title>

  <!-- OpenCV -->
  <script src="https://docs.opencv.org/4.8.0/opencv.js" async></script>

  <style>
    *{box-sizing:border-box}
    body{margin:0;font-family:Tahoma,Arial,Segoe UI,system-ui;background:#061423;color:#e6eef6}
    .app{max-width:1200px;margin:12px auto;padding:14px}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;padding-bottom:12px;border-bottom:1px solid #123}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:14px}
    @media(max-width:1000px){.grid{grid-template-columns:1fr}}
    .panel{background:#091826;padding:14px;border-radius:10px;border:1px solid #1f3440}
    .tab-buttons{display:flex;gap:6px;margin-top:12px;background:rgba(8,15,20,0.5);padding:6px;border-radius:8px}
    .tab-buttons button{flex:1;border:none;padding:8px;border-radius:6px;background:transparent;color:#9bb0c8;cursor:pointer}
    .tab-buttons button.active{background:#0f2b37;color:#e6eef6;box-shadow:inset 0 -3px 0 #06b6d4}
    .tab-content{display:none;margin-top:12px}
    .tab-content.active{display:block}
    .canvas-placeholder{width:100%;min-height:220px;background:#021018;border-radius:6px;display:flex;align-items:center;justify-content:center;color:#8fb7c5;border:1px solid #243b45}
    canvas{max-width:100%;border-radius:6px;background:#000;display:block;border:1px solid #233a44}
    label{display:block;margin-top:10px;color:#cfeaf2;font-weight:600}
    input,select,textarea,button{font-size:.95rem}
    input,select{width:100%;padding:8px;border-radius:6px;border:1px solid #123540;background:#07262d;color:#e6eef6;margin-top:6px}
    .heatmap-toolbar{display:flex;gap:6px;align-items:center;margin-bottom:10px}
    .heatmap-toolbar button{background:#0b2430;color:#cfeaf2;border:1px solid #1f4954;padding:6px;border-radius:6px;cursor:pointer}
    .heatmap-toolbar button.active{background:#06b6d4;color:#021;border-color:#06b6d4}
    .small-meta{font-size:12px;color:#9bb0c8;margin-top:6px}
    .controls-row{display:flex;gap:8px;align-items:center}
    .controls-row > *{flex:1}
    .btn-row{display:flex;gap:8px;margin-top:12px}
    button.primary{background:#06b6d4;color:#021;padding:10px;border-radius:8px;border:none;cursor:pointer}
    button.secondary{background:#12353f;color:#cfeaf2;padding:10px;border-radius:8px;border:none;cursor:pointer}
    #toast{position:fixed;left:16px;bottom:16px;background:rgba(0,0,0,0.8);color:#fff;padding:8px 12px;border-radius:8px;display:none;z-index:10000}
    .meta-small{font-size:12px;color:#95b7c1}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h2>CncAi v2.3 โ Dual Mode Final (Router + Laser)</h2>
      <div id="cvState"><small style="opacity:.8">ุฌุงุฑู ุชุญููู OpenCV...</small></div>
    </header>

    <div class="grid">
      <!-- LEFT -->
      <div class="panel">
        <div style="display:flex;gap:8px;align-items:center">
          <input id="fileInput" type="file" accept="image/*"/>
          <label for="fileInput" style="display:inline-block;padding:8px 12px;background:#0f2b34;border-radius:6px;color:#e6eef6;cursor:pointer;border:1px dashed #234a52">๐ ุงุฎุชุฑ ุตูุฑุฉ</label>
          <div style="flex:1"></div>
          <label style="font-weight:normal;color:#9bb0c8;margin:0 6px">Edge Mode:</label>
          <select id="edgeMode" style="width:150px">
            <option value="auto">Canny</option>
            <option value="sobel">Sobel</option>
            <option value="laplace">Laplacian</option>
          </select>
        </div>

        <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
          <label style="margin:0;color:#9bb0c8">ุญุณุงุณูุฉ ุงูุญูุงู:</label>
          <input id="edgeSensitivity" type="range" min="0.05" max="1.0" step="0.05" value="0.33" style="flex:1">
          <div id="edgeValue" style="min-width:44px;text-align:center;color:#cfeaf2">0.33</div>
        </div>

        <div style="display:flex;gap:8px;align-items:center;margin-top:10px">
          <label style="font-weight:normal;color:#9bb0c8;margin:0 6px">ููุน ุงููุงูููุฉ:</label>
          <select id="machineType" style="width:220px">
            <option value="router" selected>๐ชต CNC Router</option>
            <option value="laser">๐ฅ Laser Engraving</option>
          </select>
        </div>

        <div class="tab-buttons" role="tablist">
          <button data-tab="original" class="active">๐ผ๏ธ ุงูุฃุตููุฉ</button>
          <button data-tab="heatmap">๐ฅ Heatmap</button>
          <button data-tab="contour">๐ Contours</button>
          <button data-tab="edgedetail">๐ ุชูุงุตูู ุงูุญูุงู</button>
          <button data-tab="laserDetail">๐ฌ Laser Detail</button>
          <button data-tab="topview">๐ Top View</button>
        </div>

        <div id="original" class="tab-content active">
          <div class="canvas-placeholder" id="originalPlaceholder">ุงูุตูุฑุฉ ุงูุฃุตููุฉ ุณุชุธูุฑ ููุง</div>
          <canvas id="canvasOriginal" style="display:none"></canvas>
        </div>

        <div id="heatmap" class="tab-content">
          <div class="heatmap-toolbar" id="heatmapToolbar">
            <span style="color:#9bb0c8;font-size:13px;margin-right:6px">Colormap:</span>
            <button data-map="jet" class="active">Jet</button>
            <button data-map="hot">Hot</button>
            <button data-map="cool">Cool</button>
            <button data-map="gray">Gray</button>
          </div>
          <div class="canvas-placeholder" id="heatmapPlaceholder">Heatmap ุณุชุธูุฑ ููุง</div>
          <canvas id="canvasHeatmap" style="display:none"></canvas>
          <div class="small-meta">ุชุบููุฑ ูููุฐุฌ ุงูุฃููุงู ูุคุซุฑ ุนูู ุงููุนุงููุฉ ูTop View</div>
        </div>

        <div id="contour" class="tab-content">
          <div class="canvas-placeholder" id="contourPlaceholder">Contours ุณุชุธูุฑ ููุง</div>
          <canvas id="canvasContour" style="display:none"></canvas>
        </div>

        <div id="edgedetail" class="tab-content">
          <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
            <label style="font-weight:normal"><input id="edgeAdaptive" type="checkbox"> ุงุณุชุฎุฏุงู Adaptive Threshold</label>
            <button id="edgeContrast" class="secondary" style="padding:6px 8px">ุชุญุณูู ุงูุชุจุงูู</button>
            <button id="edgeReAnalyze" class="secondary" style="padding:6px 8px">๐ ุฅุนุงุฏุฉ ุงูุชุญููู</button>
          </div>
          <div class="canvas-placeholder" id="edgeDetailPlaceholder">ุชูุงุตูู ุงูุญูุงู ุณุชุธูุฑ ููุง</div>
          <canvas id="canvasEdgeDetail" style="display:none"></canvas>
        </div>

        <div id="laserDetail" class="tab-content">
          <div class="canvas-placeholder" id="laserDetailPlaceholder">ุฎุฑูุทุฉ ุงูููุฒุฑ (Smooth Depth Map) ุณุชุธูุฑ ููุง</div>
          <canvas id="canvasLaserDetail" style="display:none"></canvas>
          <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
            <label style="font-weight:normal;color:#9bb0c8">ูุนููุฉ ุงูููุญูู:</label>
            <input id="laserSmoothness" type="range" min="0" max="12" step="0.5" value="3" style="flex:1">
            <div id="laserSmoothVal" style="min-width:36px;text-align:center;color:#cfeaf2">3.0</div>
            <button id="useLaserMap" class="primary" style="margin-left:8px">ุงุณุชุฎุฏู ูุฎุฑูุทุฉ ุงูููุฒุฑ</button>
          </div>
          <div class="small-meta">ุฎุฑูุทุฉ ููุณุงุก ูุชูููุฏ ููุญุฏ ููุทุงูุฉ โ ููู ููููุฒุฑ</div>
        </div>

        <div id="topview" class="tab-content">
          <div class="canvas-placeholder" id="topPlaceholder">
            <canvas id="topView" width="600" height="300"></canvas>
          </div>
          <div id="topLegend" style="height:14px;margin-top:6px;border-radius:6px;border:1px solid #2b3844;background:linear-gradient(90deg,#ddd,#333)"></div>
        </div>
      </div>

      <!-- RIGHT: settings & actions -->
      <div class="panel">
        <h3>โ๏ธ ุฅุนุฏุงุฏุงุช ุนุงูุฉ</h3>

        <div id="routerSettings" class="router-block">
          <label>ุนุฑุถ ุงูุนูู (ุณู)</label>
          <input id="workWidth" type="number" value="30" step="0.1">
          <label>ุงุฑุชูุงุน ุงูุนูู (ุณู)</label>
          <input id="workHeight" type="number" value="20" step="0.1">
          <label>ุฎุทูุฉ ุงููุณุญ (ูู)</label>
          <input id="stepOver" type="number" value="5" step="0.1">
          <label>ุฃูุตู ุนูู (ูู)</label>
          <input id="maxDepth" type="number" value="3.0" step="0.1">
          <label>ุณุฑุนุฉ ุงูุชุบุฐูุฉ (ูู/ุฏ)</label>
          <input id="feedRate" type="number" value="800">
          <label>ุงุฑุชูุงุน ุงูุฃูุงู (ูู)</label>
          <input id="safeZ" type="number" value="5">
        </div>

        <div id="laserSettings" class="laser-block" style="display:none">
          <label>ููุฉ ุงูููุฒุฑ (ูุฑุฌุนูุฉ)</label>
          <input id="laserPower" type="number" value="60" min="1" max="100">
          <label>ุฏูุฉ ุงูููุด (DPI)</label>
          <input id="laserDpi" type="number" value="300" min="50" max="2400">
          <label>ูููุงุณ ุงูุชุนุฑุถ</label>
          <input id="laserExposureScale" type="range" min="0.1" max="3" step="0.1" value="1">
        </div>

        <div class="btn-row">
          <button id="btnGen" class="primary">โก ุชูููุฏ G-code</button>
          <button id="btnDownload" class="secondary">๐พ ุชุญููู G-code</button>
        </div>

        <div id="estTime" style="margin-top:12px;color:#9bb0c8;text-align:center;padding:8px;background:#072a30;border-radius:6px"></div>

        <label style="margin-top:12px">๐ ูุฎุฑุฌุงุช G-code</label>
        <textarea id="gcodeOut" readonly style="height:200px;background:#021024;color:#cfeaf2;border-radius:8px;padding:10px"></textarea>
        <div class="meta-small" style="margin-top:8px">ุงูุญูุธ: ุงุญูุธ ุงูููู ูุจู ุชุดุบููู ุนูู ูุงูููุฉ ุงููุนููุฉ ูุชุญูู ูู ุฅุนุฏุงุฏุงุช ุงูุฃูุงู.</div>
      </div>
    </div>

    <div id="toast"></div>
  </div>

  <script>
    // ================= State =================
    let cvReady = false;
    let previewCanvas = null;
    let grayMat = null;
    let contour = null;
    let additionalContours = [];
    let currentColormap = 'jet';
    let laserMap = null, laserMapW = 0, laserMapH = 0;
    let machineMode = 'router';
    let laserMapPrepared = false;

    // ================= UI helpers =================
    function showToast(txt, ms = 2200) {
      const t = document.getElementById('toast');
      t.textContent = txt; t.style.display = 'block';
      clearTimeout(t._t); t._t = setTimeout(()=> t.style.display = 'none', ms);
      console.log('[toast]', txt);
    }

    // Wait for OpenCV
    (function waitForCv(){
      if (typeof cv !== 'undefined' && cv.getBuildInformation) {
        cvReady = true;
        document.getElementById('cvState').innerHTML = 'โ OpenCV ุฌุงูุฒ';
        showToast('ุชู ุชุญููู OpenCV');
      } else {
        setTimeout(waitForCv, 120);
      }
    })();

    // ================= Utilities =================
    function cmToMm(cm){ return (parseFloat(cm)||0) * 10; }
    function clamp(v,a=0,b=1){ return Math.max(a, Math.min(b, v)); }

    // ================= Tabs =================
    document.querySelectorAll('.tab-buttons button').forEach(btn=>{
      btn.addEventListener('click', ()=> {
        document.querySelectorAll('.tab-buttons button').forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab).classList.add('active');
      });
    });

    // ================= Machine mode handling =================
    const machineSelect = document.getElementById('machineType');
    machineSelect.addEventListener('change', ()=> applyMachineMode());

    function clearPreviews() {
      // hide canvases and clear maps to avoid cross-mode contamination
      ['canvasHeatmap','canvasContour','canvasEdgeDetail','canvasLaserDetail','canvasOriginal'].forEach(id=>{
        const el=document.getElementById(id); if(el) el.style.display='none';
      });
      laserMap = null; laserMapW = laserMapH = 0; laserMapPrepared = false;
      // clear top view
      const top = document.getElementById('topView'); if(top){ const ctx=top.getContext('2d'); ctx.clearRect(0,0,top.width,top.height); }
      document.getElementById('gcodeOut').value = '';
      document.getElementById('estTime').innerText = '';
    }

    function applyMachineMode(){
      // clear previews to avoid confusion
      clearPreviews();
      machineMode = machineSelect.value;
      document.getElementById('laserSettings').style.display = (machineMode === 'laser') ? 'block' : 'none';
      document.getElementById('routerSettings').style.display = (machineMode === 'router') ? 'block' : 'none';
      showToast('ุงููุถุน: ' + (machineMode === 'laser' ? 'Laser Engraving' : 'CNC Router'), 1000);
    }
    applyMachineMode();

    // ================= File load =================
    document.getElementById('fileInput').addEventListener('change', async (e) => {
      const f = e.target.files[0]; if(!f) return;
      if(!f.type.match('image.*')) { showToast('ุงูุฑุฌุงุก ุงุฎุชูุงุฑ ููู ุตูุฑุฉ'); return; }
      try {
        cleanupMats();
        const img = new Image();
        img.src = URL.createObjectURL(f);
        await img.decode();
        previewCanvas = document.getElementById('canvasOriginal');
        const ctx = previewCanvas.getContext('2d');
        const maxPixels = 1024*1024;
        let w = img.width, h = img.height;
        if (w*h > maxPixels) { const ratio = Math.sqrt(maxPixels/(w*h)); w = Math.floor(w*ratio); h = Math.floor(h*ratio); showToast('ุชู ุชูููู ุฏูุฉ ุงููุนุงููุฉ ููุฃุฏุงุก'); }
        previewCanvas.width = w; previewCanvas.height = h;
        ctx.drawImage(img, 0, 0, w, h);
        document.getElementById('originalPlaceholder').style.display = 'none';
        previewCanvas.style.display = 'block';
        if (cvReady) await detectContours(); else showToast('ูู ุงูุชุธุงุฑ OpenCV...');
      } catch(err) { console.error(err); showToast('ุฎุทุฃ ูู ุชุญููู ุงูุตูุฑุฉ'); }
    });

    // ================= Cleanup =================
    function cleanupMats(){
      try{ if(grayMat && !grayMat.isDeleted){ grayMat.delete(); grayMat = null; } } catch(e){}
      try{ if(contour && !contour.isDeleted && contour.delete){ contour.delete(); contour = null; } } catch(e){}
      try{ additionalContours.forEach(c=>{ if(c.contour && !c.contour.isDeleted) c.contour.delete(); }); } catch(e){}
      additionalContours = [];
      laserMap = null; laserMapW = laserMapH = 0; laserMapPrepared = false;
    }

    // ================= Image helpers =================
    function contrastStretchMat(src) {
      try {
        const dst = new cv.Mat();
        const mm = cv.minMaxLoc(src);
        const minV = mm.minVal, maxV = mm.maxVal;
        if (maxV <= minV) { src.copyTo(dst); return dst; }
        const alpha = 255.0 / (maxV - minV); const beta = -minV * alpha;
        src.convertTo(dst, cv.CV_8U, alpha, beta);
        return dst;
      } catch(e) { console.warn('contrastStretch error', e); const d = new cv.Mat(); src.copyTo(d); return d; }
    }

    // ================= Edge detection & contours =================
    async function detectContours() {
      if (!cvReady || !previewCanvas) return;
      try {
        const src = cv.imread(previewCanvas);
        const gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
        const stretched = contrastStretchMat(gray);
        const blurred = new cv.Mat(); cv.GaussianBlur(stretched, blurred, new cv.Size(5,5), 0);

        const sens = parseFloat(document.getElementById('edgeSensitivity').value) || 0.33;
        const median = cv.mean(blurred)[0];
        const low = Math.max(0, (1.0 - sens) * median);
        const high = Math.min(255, (1.0 + sens) * median);

        const mode = document.getElementById('edgeMode').value || 'auto';
        const useAdaptive = document.getElementById('edgeAdaptive').checked;

        let edges = new cv.Mat();
        if (useAdaptive) {
          try {
            const tmpStr = contrastStretchMat(gray);
            const adapt = new cv.Mat();
            cv.adaptiveThreshold(tmpStr, adapt, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
            cv.Canny(blurred, edges, low*0.7, high*1.1);
            cv.bitwise_or(edges, adapt, edges);
            adapt.delete(); tmpStr.delete();
          } catch(e) {
            cv.Canny(blurred, edges, low, high);
          }
        } else {
          if (mode === 'sobel') {
            const gx = new cv.Mat(), gy = new cv.Mat();
            cv.Sobel(blurred, gx, cv.CV_16S, 1, 0);
            cv.Sobel(blurred, gy, cv.CV_16S, 0, 1);
            cv.convertScaleAbs(gx, gx); cv.convertScaleAbs(gy, gy);
            cv.addWeighted(gx, 0.5, gy, 0.5, 0, edges);
            gx.delete(); gy.delete();
          } else if (mode === 'laplace') {
            cv.Laplacian(blurred, edges, cv.CV_16S);
            cv.convertScaleAbs(edges, edges);
          } else {
            cv.Canny(blurred, edges, low, high);
          }
        }

        const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
        cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);
        cv.morphologyEx(edges, edges, cv.MORPH_OPEN, kernel);

        const contours = new cv.MatVector(), hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

        const minArea = (stretched.cols * stretched.rows) * 0.001;
        const valid = [];
        for (let i=0;i<contours.size();i++){
          const cnt = contours.get(i);
          const area = cv.contourArea(cnt);
          if (area > minArea) valid.push({contour:cnt, area});
          else try{ cnt.delete(); } catch(e){}
        }

        if (valid.length > 0) {
          valid.sort((a,b)=>b.area - a.area);
          contour = valid[0].contour;
          additionalContours = valid.slice(1).map(v=>({contour:v.contour, area:v.area}));
          showToast('ุชู ูุดู ' + valid.length + ' ูููุชูุฑ');
        } else {
          contour = null; additionalContours = []; showToast('ูู ูุชู ุงูุนุซูุฑ ุนูู ุญูุงู ูุงููุฉ');
        }

        if (grayMat) try{ grayMat.delete(); } catch(e){}
        grayMat = stretched.clone();

        // render previews
        renderHeatmap();
        renderContour();
        renderEdgeDetail();
        renderLaserMapPreview();

        // cleanup
        src.delete(); gray.delete(); blurred.delete(); edges.delete(); kernel.delete(); contours.delete(); hierarchy.delete(); stretched.delete();
      } catch(err) {
        console.error('detectContours error', err);
        showToast('ุฎุทุฃ ูู ูุดู ุงูุญูุงู');
      }
    }

    // ================= Colormap =================
    function getColormapColor(t, map) {
      t = clamp(t);
      if (map === 'hot') {
        if (t < 0.33) return {r: Math.round(t/0.33*128), g:0, b:0};
        if (t < 0.66) return {r: Math.round(128 + (t-0.33)/0.33*127), g: Math.round((t-0.33)/0.33*128), b:0};
        return { r:255, g: Math.round(128 + (t-0.66)/0.34*127), b: Math.round((t-0.66)/0.34*127) };
      } else if (map === 'cool') {
        return { r: Math.round(255*t), g: Math.round(255*(1-t)), b:255 };
      } else if (map === 'gray') {
        const v = Math.round(255*t); return { r:v,g:v,b:v };
      } else {
        const r = Math.round(255 * clamp(1.5 - Math.abs(1.0 - 4.0*(t-0.5)), 0, 1));
        const g = Math.round(255 * clamp(1.5 - Math.abs(0.5 - 4.0*(t-0.25)), 0, 1));
        const b = Math.round(255 * clamp(1.5 - Math.abs(0.5 - 4.0*(t)), 0, 1));
        return { r, g, b };
      }
    }

    // ================= Rendering previews =================
    function renderHeatmap() {
      if (!grayMat || !previewCanvas) return;
      const c = document.getElementById('canvasHeatmap'), ctx = c.getContext('2d');
      c.width = grayMat.cols; c.height = grayMat.rows;
      const img = ctx.createImageData(c.width, c.height);
      const data = grayMat.data;
      for (let i=0;i<data.length;i++) {
        const v = data[i], t = v / 255.0, col = getColormapColor(t, currentColormap), idx = i*4;
        img.data[idx] = col.r; img.data[idx+1] = col.g; img.data[idx+2] = col.b; img.data[idx+3] = 255;
      }
      ctx.putImageData(img, 0, 0);
      document.getElementById('heatmapPlaceholder').style.display = 'none';
      c.style.display = 'block';
    }

    function renderContour() {
      if (!grayMat) return;
      const c = document.getElementById('canvasContour'), ctx = c.getContext('2d');
      c.width = grayMat.cols; c.height = grayMat.rows;
      try { ctx.drawImage(document.getElementById('canvasHeatmap'), 0, 0); } catch(e) { ctx.fillStyle='#111'; ctx.fillRect(0,0,c.width,c.height); }
      if (contour) {
        ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 2; ctx.beginPath();
        const d = contour.data32S;
        for (let i=0;i<d.length;i+=2) { const x=d[i], y=d[i+1]; if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
        ctx.closePath(); ctx.stroke();
      }
      additionalContours.forEach(ci=>{
        try{
          ctx.strokeStyle = '#ffd24d'; ctx.lineWidth = 1; ctx.beginPath();
          const d = ci.contour.data32S;
          for (let i=0;i<d.length;i+=2) { if(i===0) ctx.moveTo(d[i],d[i+1]); else ctx.lineTo(d[i],d[i+1]); }
          ctx.closePath(); ctx.stroke();
        } catch(e){}
      });
      document.getElementById('contourPlaceholder').style.display='none';
      c.style.display='block';
    }

    function renderEdgeDetail() {
      const canvas = document.getElementById('canvasEdgeDetail'), ph = document.getElementById('edgeDetailPlaceholder');
      if(!grayMat || !previewCanvas){ ph.style.display='flex'; canvas.style.display='none'; return; }
      ph.style.display='none'; canvas.style.display='block';
      const tmp = new cv.Mat();
      try {
        const useAdaptive = document.getElementById('edgeAdaptive').checked;
        if (useAdaptive) {
          const stretched = contrastStretchMat(grayMat);
          const adapt = new cv.Mat();
          cv.adaptiveThreshold(stretched, adapt, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
          cv.Canny(stretched, tmp, 40, 120);
          cv.bitwise_and(tmp, adapt, tmp);
          adapt.delete(); stretched.delete();
        } else {
          cv.Canny(grayMat, tmp, 50, 150);
        }
        const w = tmp.cols, h = tmp.rows; canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d'); const img = ctx.createImageData(w,h);
        for (let y=0;y<h;y++){
          for (let x=0;x<w;x++){
            const v = tmp.ucharPtr(y,x)[0] / 255.0, col = getColormapColor(v, currentColormap), idx = (y*w + x)*4;
            img.data[idx] = col.r; img.data[idx+1] = col.g; img.data[idx+2] = col.b; img.data[idx+3] = 255;
          }
        }
        ctx.putImageData(img,0,0);
      } catch(e){ console.warn('renderEdgeDetail', e); }
      finally { try{ tmp.delete(); } catch(e){} }
    }

    // ================= Laser map: smoothing + preview =================
    function generateLaserMap(smoothness=3.0) {
      if(!grayMat || !previewCanvas) return null;
      const w = grayMat.cols, h = grayMat.rows;
      // base normalized depth (0..1): darker -> deeper
      const base = new Float32Array(w*h);
      for (let i=0;i<w*h;i++) base[i] = (255 - grayMat.data[i]) / 255.0;
      // smoothing: iterative box blur proportional to smoothness
      const passes = Math.max(1, Math.round(smoothness / 2));
      let tmp = base.slice();
      const rad = Math.max(1, Math.round(smoothness/2));
      for (let p=0;p<passes;p++){
        const out = new Float32Array(w*h);
        for (let y=0;y<h;y++){
          for (let x=0;x<w;x++){
            let s=0,cnt=0;
            for (let oy=-rad;oy<=rad;oy++){
              const ny=y+oy; if(ny<0||ny>=h) continue;
              for (let ox=-rad;ox<=rad;ox++){
                const nx=x+ox; if(nx<0||nx>=w) continue;
                s += tmp[ny*w + nx]; cnt++;
              }
            }
            out[y*w + x] = s / Math.max(1,cnt);
          }
        }
        tmp = out;
      }
      laserMap = tmp; laserMapW = w; laserMapH = h; laserMapPrepared = true;
      return {map: tmp, w, h};
    }

    function renderLaserMapPreview() {
      const res = generateLaserMap(parseFloat(document.getElementById('laserSmoothness').value) || 3.0);
      const canvas = document.getElementById('canvasLaserDetail'), ph = document.getElementById('laserDetailPlaceholder');
      if(!res){ ph.style.display='flex'; canvas.style.display='none'; return; }
      ph.style.display='none'; canvas.style.display='block';
      const w=res.w, h=res.h; canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d'); const img = ctx.createImageData(w,h);
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          const v = res.map[y*w + x]; const col = getColormapColor(v, currentColormap);
          const idx = (y*w + x)*4;
          img.data[idx] = col.r; img.data[idx+1] = col.g; img.data[idx+2] = col.b; img.data[idx+3] = 255;
        }
      }
      ctx.putImageData(img,0,0);
    }

    // ================= Generate Laser G-code =================
    function generateLaserGcode() {
      if(!laserMapPrepared || !laserMap) { showToast('ูู ุชูุญุถูุฑ ุฎุฑูุทุฉ ุงูููุฒุฑ. ุงุถุบุท "ุงุณุชุฎุฏู ูุฎุฑูุทุฉ ุงูููุฒุฑ"'); return ''; }
      const w = laserMapW, h = laserMapH;
      const workWidth = cmToMm(document.getElementById('workWidth').value || 30);
      const workHeight = cmToMm(document.getElementById('workHeight').value || 20);
      const scaleX = workWidth / w, scaleY = workHeight / h;
      const exposureScale = parseFloat(document.getElementById('laserExposureScale').value) || 1.0;
      const basePower = parseFloat(document.getElementById('laserPower').value) || 60;
      const feed = Math.max(100, Math.round((parseFloat(document.getElementById('laserDpi').value)||300)/2));
      const lines = [];
      lines.push('; Laser Mode G-code (raster approximate)');
      lines.push('G21 G90 (mm, absolute)');
      for (let row=0; row<h; row++){
        const y_mm = (row * scaleY);
        const leftToRight = (row % 2 === 0);
        const xStart = leftToRight ? 0 : w-1;
        const xEnd = leftToRight ? w-1 : 0;
        lines.push(`G0 X${(xStart*scaleX).toFixed(3)} Y${y_mm.toFixed(3)} F${feed}`);
        let x = xStart;
        while(true){
          const intensity = laserMap[row*w + x];
          const power = Math.round(Math.min(1000, intensity * basePower * exposureScale * 10));
          lines.push(`M3 S${power}`);
          lines.push(`G1 X${(x*scaleX).toFixed(3)} Y${y_mm.toFixed(3)} F${feed}`);
          if (x === xEnd) break;
          x = leftToRight ? x+1 : x-1;
        }
        lines.push('M5');
      }
      lines.push('M5','M30');
      showToast('ุชู ุชูููุฏ G-code ููููุฒุฑ');
      return lines.join('\n');
    }

    // ================= Generate Router G-code =================
    function generateRouterGcode() {
      if(!grayMat) { showToast('ูุง ุชูุฌุฏ ุจูุงูุงุช ูุงููุฉ ููู Router'); return ''; }
      const w = grayMat.cols, h = grayMat.rows;
      const workWidth = cmToMm(document.getElementById('workWidth').value || 30);
      const workHeight = cmToMm(document.getElementById('workHeight').value || 20);
      const scaleX = workWidth / w, scaleY = workHeight / h;
      const step = Math.max(1, Math.round(parseFloat(document.getElementById('stepOver').value) || 5));
      const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3.0;
      const feed = parseFloat(document.getElementById('feedRate').value) || 800;
      const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
      const lines = [];
      lines.push('; Router Raster G-code (approx)');
      lines.push('G21 G90');
      lines.push(`G0 Z${safeZ.toFixed(2)}`);
      let totalLen = 0;
      for (let y=0; y<h; y += step) {
        const row = [];
        for (let x=0; x<w; x += 2) {
          const v = grayMat.data[y*w + x];
          const z = -((255 - v)/255.0) * maxDepth;
          row.push({x: x*scaleX, y: y*scaleY, z});
        }
        if (row.length === 0) continue;
        lines.push(`G0 X${row[0].x.toFixed(2)} Y${row[0].y.toFixed(2)} Z${safeZ.toFixed(2)}`);
        lines.push(`G1 F${feed}`);
        for (let p of row) lines.push(`G1 X${p.x.toFixed(2)} Y${p.y.toFixed(2)} Z${p.z.toFixed(3)}`);
        lines.push(`G0 Z${safeZ.toFixed(2)}`);
        for (let i=1;i<row.length;i++) totalLen += Math.hypot(row[i].x-row[i-1].x, row[i].y-row[i-1].y);
      }
      lines.push('M5','M30');
      const avgSpeed = Math.max(10, feed);
      const timeMin = (totalLen / avgSpeed);
      document.getElementById('estTime').innerText = 'โฑ๏ธ ุชูุฏูุฑ ุงูููุช: ' + timeMin.toFixed(1) + ' ุฏูููุฉ';
      showToast('ุชู ุชูููุฏ G-code ููู Router');
      return lines.join('\n');
    }

    // ================= Top view rendering =================
    function renderTopViewFromGcode() {
      const top = document.getElementById('topView'); if(!top || !previewCanvas) return;
      const ctx = top.getContext('2d');
      const w = previewCanvas.width, h = previewCanvas.height; top.width = w; top.height = h;
      const img = ctx.createImageData(w,h);
      if (machineMode === 'laser' && laserMapPrepared && laserMap) {
        for (let y=0;y<h;y++){
          for (let x=0;x<w;x++){
            const v = laserMap[y*w + x] || 0;
            const col = getColormapColor(v, currentColormap);
            const idx = (y*w + x)*4; img.data[idx]=col.r; img.data[idx+1]=col.g; img.data[idx+2]=col.b; img.data[idx+3]=255;
          }
        }
      } else if (grayMat) {
        for (let i=0;i<grayMat.data.length;i++){
          const t = grayMat.data[i]/255.0; const col = getColormapColor(t, currentColormap); const idx = i*4;
          img.data[idx]=col.r; img.data[idx+1]=col.g; img.data[idx+2]=col.b; img.data[idx+3]=255;
        }
      }
      ctx.putImageData(img,0,0); drawTopLegend(currentColormap);
    }

    function drawTopLegend(map) {
      try {
        const legend = document.getElementById('topLegend'); const steps = 6; const stops = [];
        for (let i=0;i<=steps;i++){ const t = i/steps; const c = getColormapColor(t,map); stops.push(`rgb(${c.r},${c.g},${c.b}) ${Math.round((i/steps)*100)}%`); }
        legend.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
      } catch(e){}
    }

    // ================= UI bindings =================
    document.querySelectorAll('#heatmapToolbar button[data-map]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('#heatmapToolbar button[data-map]').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        currentColormap = btn.dataset.map;
        renderHeatmap(); renderEdgeDetail(); renderLaserMapPreview(); renderTopViewFromGcode();
      });
    });

    document.getElementById('laserSmoothness').addEventListener('input', (e)=>{
      document.getElementById('laserSmoothVal').innerText = parseFloat(e.target.value).toFixed(1);
      renderLaserMapPreview();
    });

    document.getElementById('useLaserMap').addEventListener('click', ()=>{
      generateLaserMap(parseFloat(document.getElementById('laserSmoothness').value) || 3.0);
      renderLaserMapPreview();
      showToast('ุชู ุชูุนูู ุฎุฑูุทุฉ ุงูููุฒุฑ ููุงุณุชุฎุฏุงู ุนูุฏ ุงูุชูููุฏ');
    });

    document.getElementById('edgeSensitivity').addEventListener('input', (e)=>{
      document.getElementById('edgeValue').textContent = parseFloat(e.target.value).toFixed(2);
      if (previewCanvas && cvReady) detectContours();
    });

    document.getElementById('edgeReAnalyze').addEventListener('click', ()=> detectContours());
    document.getElementById('edgeContrast').addEventListener('click', ()=>{ if(previewCanvas) detectContours(); showToast('ุชู ุชุญุณูู ุงูุชุจุงูู ูุฅุนุงุฏุฉ ุงูุชุญููู'); });

    document.getElementById('btnGen').addEventListener('click', ()=>{
      let g = '';
      if (machineMode === 'laser') g = generateLaserGcode();
      else g = generateRouterGcode();
      document.getElementById('gcodeOut').value = g;
      renderTopViewFromGcode();
    });

    document.getElementById('btnDownload').addEventListener('click', ()=>{
      const text = document.getElementById('gcodeOut').value;
      if(!text){ showToast('ูุง ููุฌุฏ G-code ูุชุญูููู'); return; }
      const blob = new Blob([text], {type: 'text/plain'}); const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'cnc_output.gcode'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
      showToast('ุชู ุชุญููู ุงูููู');
    });

    document.addEventListener('keydown', (e)=>{ if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='g') { e.preventDefault(); document.getElementById('btnGen').click(); } });

    // ================= Initial boot =================
    (function init(){
      ['canvasHeatmap','canvasContour','canvasEdgeDetail','canvasLaserDetail','canvasOriginal'].forEach(id=>{ const el=document.getElementById(id); if(el) el.style.display='none'; });
      setTimeout(()=>{ if(cvReady) { showToast('ุฌุงูุฒ ููุงุฎุชุจุงุฑ'); detectContours().catch(()=>{}); } else { showToast('OpenCV ูุง ูุฒุงู ูุชุญูู โ ุงูุชุธุฑ ุซูุงูู'); } }, 800);
    })();

    // ================= Cleanup on unload =================
    window.addEventListener('beforeunload', ()=>{ try{ cleanupMats(); } catch(e){} });

    // ================= End =================
  </script>
</body>
</html>
