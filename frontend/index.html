<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>CNC AI â€” CNC Router & Laser Engraving</title>

  <!-- Ù…ÙƒØªØ¨Ø§Øª -->
  <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: Arial, Segoe UI, system-ui; background: #041022; color:#e6eef6; line-height:1.45 }
    .app { max-width:1400px; margin:12px auto; padding:14px }
    header { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #1e293b }
    .grid { display:grid; grid-template-columns:1fr 520px; gap:16px }
    @media (max-width:1100px){ .grid{ grid-template-columns:1fr } }
    .panel { background:#0b1320; padding:16px; border-radius:10px; border:1px solid #1e293b }
    /* tabs improved */
    .tab-buttons { display:flex; gap:8px; margin-top:12px; background: rgba(14,23,33,0.6); padding:6px; border-radius:8px }
    .tab-buttons button { flex:1; border:none; padding:8px 10px; border-radius:6px; background:transparent; color:#9bb0c8; cursor:pointer }
    .tab-buttons button.active { background:#0f172a; color:#e6eef6; box-shadow: inset 0 -3px 0 #06b6d4; }
    .tab-content { display:none; margin-top:12px }
    .tab-content.active { display:block }
    canvas { max-width:100%; border-radius:6px; background:#000; display:block; margin:0 auto; border:1px solid #334155 }
    #threeContainer { width:100%; height:420px; background:#081224; border-radius:8px; overflow:hidden; position:relative }
    label { display:block; margin-top:12px; color:#cfeaf2; font-weight:bold }
    input, select, textarea, button { font-size:0.9rem }
    input, select { width:100%; padding:8px 10px; border-radius:6px; border:1px solid #1e293b; background:#0f172a; color:#e6eef6; margin-top:6px }
    .button-group { display:flex; flex-direction:column; gap:8px; margin-top:12px }
    .button-row { display:flex; gap:8px; }
    button { background:#1e293b; color:#e6eef6; border:none; padding:10px; border-radius:8px; cursor:pointer }
    button.primary { background:#06b6d4; color:#021; font-weight:bold }
    button.secondary { background:#334155; }
    #toast { position:fixed; left:16px; bottom:16px; background:rgba(0,0,0,0.85); color:#fff; padding:10px 14px; border-radius:8px; display:none; z-index:10000 }
    .canvas-placeholder { width:100%; min-height:260px; background:#000; border-radius:6px; display:flex; align-items:center; justify-content:center; color:#9bb0c8; border:1px solid #334155 }
    .small-meta { font-size:12px; color:#9bb0c8; margin-top:6px }

    /* Debug overlay */
    #debugOverlay {
      position: fixed;
      right: 16px;
      bottom: 16px;
      width: 420px;
      max-height: 55vh;
      background: rgba(2,6,23,0.9);
      color: #e6eef6;
      border: 1px solid rgba(102, 126, 234, 0.08);
      border-radius: 8px;
      font-size: 13px;
      z-index: 20000;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 0 8px 40px rgba(0,0,0,0.6);
    }
    #debugOverlay.minimized { height: 36px; width: 160px; cursor: pointer; }
    #debugHeader {
      display:flex; align-items:center; justify-content:space-between; padding:8px 10px; border-bottom:1px solid rgba(255,255,255,0.03);
      background: linear-gradient(90deg, rgba(6,182,212,0.06), rgba(8,145,178,0.02));
    }
    #debugHeader b { color:#aee8f2; }
    #debugControls { display:flex; gap:6px; align-items:center; }
    .dbg-btn { background:transparent; border:1px solid rgba(255,255,255,0.06); color:#cfeaf2; padding:6px 8px; border-radius:6px; cursor:pointer; font-size:12px; }
    #debugList { overflow:auto; padding:8px; display:flex; flex-direction:column; gap:6px; }
    .dbg-item { padding:8px; border-radius:6px; background:rgba(255,255,255,0.02); line-height:1.2; max-height:120px; overflow:auto; font-family:monospace; font-size:12px; }
    .dbg-time { opacity:0.7; font-size:11px; margin-bottom:6px; display:block; }
    .dbg-error { border-left:4px solid #ef4444; }
    .dbg-warn { border-left:4px solid #f59e0b; }
    .dbg-info { border-left:4px solid #06b6d4; color:#cfeaf2; }
    .dbg-meta { opacity:0.75; font-size:11px; margin-top:6px; color:#9bb0c8; }
    #debugFooter { padding:6px 10px; border-top:1px solid rgba(255,255,255,0.02); text-align:right; font-size:12px; color:#9bb0c8; background:rgba(0,0,0,0.03); display:flex; justify-content:space-between; align-items:center; }

    /* Simulation controls */
    .sim-controls { position:absolute; top:10px; left:10px; z-index:120; display:flex; gap:8px; align-items:center; background:rgba(0,0,0,0.35); padding:6px;border-radius:6px }
    .sim-controls button { background:rgba(0,0,0,0.55); color:white; border:1px solid #06b6d4; border-radius:4px; padding:6px 8px; cursor:pointer; font-size:0.9rem }
    .sim-progress { position:absolute; bottom:10px; left:10px; z-index:120; background:rgba(0,0,0,0.35); padding:6px 8px;border-radius:6px; color:#cfeaf2; font-size:12px }

    /* Top view + legend */
    #topViewContainer { margin-top:12px; display:flex; flex-direction:column; gap:6px; align-items:center; }
    #topView { width:100%; height:200px; background:#0d1722; border-radius:6px; border:1px solid #334155; display:block }
    #topLegend { width:100%; height:18px; border-radius:6px; border:1px solid #2b3844; background:linear-gradient(90deg,#ddd,#333); }

    /* colormap buttons */
    .colormap-section {
      margin: 16px 0;
      padding: 16px;
      background: rgba(14, 23, 33, 0.8);
      border-radius: 10px;
      border: 1px solid #334155;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    .colormap-title {
      text-align: center;
      margin-bottom: 12px;
      color: #cfeaf2;
      font-weight: bold;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .colormap-buttons { display:flex; gap:8px; justify-content:center; margin-top:8px; flex-wrap:wrap; }
    .colormap-buttons button {
      background:#141b22; color:#cfeaf2; border:1px solid #26343f; padding:10px 16px; border-radius:8px; 
      cursor:pointer; font-size:14px; font-weight:bold; transition:all 0.3s ease; min-width:80px;
    }
    .colormap-buttons button:hover { background:#1e293b; border-color:#06b6d4; transform:translateY(-2px); }
    .colormap-buttons button.active { background:#06b6d4; color:#021; border-color:#06b6d4; box-shadow:0 4px 12px rgba(6,182,212,0.3); }

    /* Machine category styles */
    .machine-settings { transition: all 0.3s ease; }
    .laser-specific { border-left: 3px solid #ff4444; padding-left: 10px; margin: 8px 0; background: rgba(255, 0, 0, 0.05); }
    .router-specific { border-left: 3px solid #06b6d4; padding-left: 10px; margin: 8px 0; background: rgba(6, 182, 212, 0.05); }
    .laser-edge-settings {
      border: 1px solid #ff4444;
      border-radius: 6px;
      padding: 10px;
      margin: 8px 0;
      background: rgba(255, 68, 68, 0.05);
    }
    .laser-mode-description {
      font-size: 11px;
      color: #9bb0c8;
      margin-top: 4px;
      line-height: 1.3;
    }

    .loading-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      background: rgba(6, 182, 212, 0.1);
      border-radius: 6px;
      border: 1px solid rgba(6, 182, 212, 0.3);
    }

    .loading-spinner {
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #06b6d4;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin { 0%{transform:rotate(0)}100%{transform:rotate(360deg)} }
    
    /* Laser preview styles */
    .laser-preview {
      border: 2px solid #ff4444;
      background: rgba(255, 68, 68, 0.05);
      padding: 8px;
      border-radius: 6px;
      margin-top: 8px;
    }
    
    .power-indicator {
      height: 4px;
      background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
      border-radius: 2px;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>CNC AI â€” CNC Router & Laser Engraving</h1>
      <div id="cvState" class="loading-indicator">
        <div class="loading-spinner"></div>
        <span>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ OpenCV...</span>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT panel -->
      <div class="panel">
        <div style="display:flex;gap:8px;align-items:center;">
          <input id="fileInput" type="file" accept="image/*"/>
          <label class="file-input-label" for="fileInput" style="display:inline-block;padding:8px 12px;background:#1e293b;border-radius:6px;color:#e6eef6;cursor:pointer;border:1px dashed #334155">ğŸ“ Ø§Ø®ØªØ± ØµÙˆØ±Ø©</label>
          <div style="flex:1"></div>

          <label for="edgeMode" style="font-weight:normal;color:#9bb0c8">Edge Mode:</label>
          <select id="edgeMode" style="width:140px">
            <option value="auto">Canny (Ø¹Ø§Ø¯ÙŠ)</option>
            <option value="sobel">Sobel (Ø¯Ù‚ÙŠÙ‚)</option>
            <option value="laplace">Laplacian (Ù†Ø§Ø¹Ù€Ù…)</option>
          </select>
        </div>

        <!-- Edge sensitivity slider -->
        <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
          <label style="margin:0;color:#9bb0c8">Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ø­ÙˆØ§Ù:</label>
          <input id="edgeSensitivity" type="range" min="0.1" max="1.0" step="0.05" value="0.33" style="flex:1">
          <div id="edgeValue" style="min-width:44px;text-align:center;color:#cfeaf2">0.33</div>
        </div>

        <!-- ========== Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù€ Colormap Ø§Ù„Ø«Ø§Ø¨ØªØ© ========== -->
        <div class="colormap-section">
          <div class="colormap-title">
            <span>ğŸ¨</span>
            Ø®ÙŠØ§Ø±Ø§Øª ØªØ¯Ø±Ø¬ Ø§Ù„Ø£Ù„ÙˆØ§Ù†
            <span>ğŸ¨</span>
          </div>
          <div class="colormap-buttons" id="colormapButtons">
            <button data-map="jet" class="active" title="Jet - Ø§Ù„Ø£Ø²Ø±Ù‚ Ø¥Ù„Ù‰ Ø§Ù„Ø£Ø­Ù…Ø±">
              <div style="display:flex;flex-direction:column;align-items:center;gap:4px">
                <div>Jet</div>
                <div style="width:100%;height:4px;background:linear-gradient(90deg,#0000ff,#00ffff,#ffff00,#ff0000);border-radius:2px"></div>
              </div>
            </button>
            <button data-map="hot" title="Hot - Ø§Ù„Ø£Ø³ÙˆØ¯ Ø¥Ù„Ù‰ Ø§Ù„Ø£Ø­Ù…Ø± Ø¥Ù„Ù‰ Ø§Ù„Ø£ØµÙØ±">
              <div style="display:flex;flex-direction:column;align-items:center;gap:4px">
                <div>Hot</div>
                <div style="width:100%;height:4px;background:linear-gradient(90deg,#000000,#ff0000,#ffff00,#ffffff);border-radius:2px"></div>
              </div>
            </button>
            <button data-map="cool" title="Cool - Ø§Ù„Ø³Ù…Ø§ÙˆÙŠ Ø¥Ù„Ù‰ Ø§Ù„Ø£Ø±Ø¬ÙˆØ§Ù†ÙŠ">
              <div style="display:flex;flex-direction:column;align-items:center;gap:4px">
                <div>Cool</div>
                <div style="width:100%;height:4px;background:linear-gradient(90deg,#00ffff,#ff00ff);border-radius:2px"></div>
              </div>
            </button>
            <button data-map="gray" title="Gray - Ø§Ù„ØªØ¯Ø±Ø¬ Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ">
              <div style="display:flex;flex-direction:column;align-items:center;gap:4px">
                <div>Gray</div>
                <div style="width:100%;height:4px;background:linear-gradient(90deg,#000000,#ffffff);border-radius:2px"></div>
              </div>
            </button>
          </div>
          <div class="small-meta" style="text-align: center; margin-top: 8px;">
            Ø§Ù„ØªØºÙŠÙŠØ± ÙŠØ·Ø¨Ù‚ Ø¹Ù„Ù‰: Heatmap â€¢ Top View â€¢ Contours â€¢ ÙƒÙ„ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø§Øª
          </div>
        </div>

        <div class="tab-buttons" role="tablist">
          <button data-tab="original" class="active">ğŸ–¼ï¸ Ø§Ù„Ø£ØµÙ„ÙŠØ©</button>
          <button data-tab="heatmap">ğŸ”¥ Heatmap</button>
          <button data-tab="contour">ğŸ“ Contours</button>
          <button data-tab="topview">ğŸ” Top View</button>
          <button data-tab="simulation">ğŸ¬ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©</button>
          <button data-tab="laserpreview" id="laserPreviewTab" style="display:none">ğŸ”´ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù„ÙŠØ²Ø±</button>
        </div>

        <div id="original" class="tab-content active">
          <div class="canvas-placeholder" id="originalPlaceholder">Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
          <canvas id="canvasOriginal" style="display:none;"></canvas>
        </div>

        <div id="heatmap" class="tab-content">
          <div class="canvas-placeholder" id="heatmapPlaceholder">Heatmap Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
          <canvas id="canvasHeatmap" style="display:none;"></canvas>
        </div>

        <div id="contour" class="tab-content">
          <div class="canvas-placeholder" id="contourPlaceholder">Contours Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
          <canvas id="canvasContour" style="display:none;"></canvas>
          <div class="small-meta">ØªØ¨Ø¯ÙŠÙ„ ÙˆØ¶Ø¹ ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ø£Ùˆ ØªØ­Ø±ÙŠÙƒ Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ø­ÙˆØ§Ù ÙŠØ­Ø¯Ø« Ø¥Ø¹Ø§Ø¯Ø© Ù…Ø¹Ø§Ù„Ø¬Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ©</div>
        </div>

        <div id="topview" class="tab-content">
          <div id="topViewContainer">
            <canvas id="topView"></canvas>
            <div id="topLegend" title="Ø¹Ù…Ù‚ Ø§Ù„Ù†Ù‚Ø´ â€” Ø§Ù„Ø£Ù„ÙˆØ§Ù† ÙÙ‚Ø·"></div>
          </div>
          <div class="small-meta">Ù…Ø¹Ø§ÙŠÙ†Ø© Ù…Ù† Ø§Ù„Ø£Ø¹Ù„Ù‰ Ù„Ù„Ø¹Ù…Ù‚ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹ Ø¨Ø¹Ø¯ ØªÙ†ÙÙŠØ° G-code (Ø§Ù„Ø£Ù„ÙˆØ§Ù† ØªØªØ¨Ø¹ Ø§Ø®ØªÙŠØ§Ø± Colormap)</div>
        </div>

        <div id="simulation" class="tab-content">
          <div id="threeContainer">
            <div class="canvas-placeholder" id="simulationPlaceholder">Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªÙˆÙ„ÙŠØ¯ G-code</div>
          </div>
        </div>

        <div id="laserpreview" class="tab-content">
          <div class="laser-preview">
            <div class="canvas-placeholder" id="laserPreviewPlaceholder">Ù…Ø¹Ø§ÙŠÙ†Ø© Ù†Ù‚Ø´ Ø§Ù„Ù„ÙŠØ²Ø± Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
            <canvas id="canvasLaserPreview" style="display:none;"></canvas>
            <div class="small-meta">Ù…Ø¹Ø§ÙŠÙ†Ø© ØªØ£Ø«ÙŠØ± Ø§Ù„Ù„ÙŠØ²Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø§Ø¯Ø© - Ø§Ù„Ø£Ø­Ù…Ø± = Ù‚ÙˆØ© Ø¹Ø§Ù„ÙŠØ©ØŒ Ø§Ù„Ø£ØµÙØ± = Ù‚ÙˆØ© Ù…ØªÙˆØ³Ø·Ø©ØŒ Ø§Ù„Ø£Ø®Ø¶Ø± = Ù‚ÙˆØ© Ù…Ù†Ø®ÙØ¶Ø©</div>
            <div class="power-indicator"></div>
          </div>
        </div>
      </div>

      <!-- RIGHT panel -->
      <div class="panel">
        <h3>âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</h3>

        <!-- Machine Category Selection -->
        <label for="machineCategory">Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ</label>
        <select id="machineCategory">
          <option value="router">CNC Router (Ù†Ø­Øª Ø®Ø´Ø¨)</option>
          <option value="laser">Laser Engraver (Ù†Ù‚Ø´ Ù„ÙŠØ²Ø±)</option>
        </select>

        <!-- CNC Router Settings -->
        <div id="routerSettings" class="machine-settings">
          <h4 class="router-specific">ğŸ”„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª CNC Router</h4>
          
          <label for="workWidth">Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
          <input id="workWidth" type="number" value="300" step="1" min="10" max="2000"/>
          
          <label for="workHeight">Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
          <input id="workHeight" type="number" value="200" step="1" min="10" max="2000"/>

          <label for="workDepth">Ø¹Ù…Ù‚ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
          <input id="workDepth" type="number" value="3.0" step="0.1" min="0.1" max="50"/>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
            <div>
              <label for="originX">Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„ X (Ù…Ù…)</label>
              <input id="originX" type="number" value="0" step="1"/>
            </div>
            <div>
              <label for="originY">Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„ Y (Ù…Ù…)</label>
              <input id="originY" type="number" value="0" step="1"/>
            </div>
          </div>
          <div style="margin-top:6px"><button id="btnCenterOrigin" class="secondary">ğŸ¯ ØªÙˆØ³ÙŠØ· Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„</button></div>

          <hr style="border-color:#122433;margin:12px 0"/>

          <label for="feedRate">Ø³Ø±Ø¹Ø© Ø§Ù„ØªØºØ°ÙŠØ© (Ù…Ù…/Ø¯Ù‚ÙŠÙ‚Ø©)</label>
          <input id="feedRate" type="number" value="800" min="10" max="5000"/>
          
          <label for="safeZ">Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø£Ù…Ø§Ù† (Ù…Ù…)</label>
          <input id="safeZ" type="number" value="5" step="0.1" min="0" max="100"/>

          <label for="scanDir">Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª (Raster)</label>
          <select id="scanDir">
            <option value="x">Ø£ÙÙ‚ÙŠ (X)</option>
            <option value="y">Ø±Ø£Ø³ÙŠ (Y)</option>
          </select>

          <label for="stepOver">Ø®Ø·ÙˆØ© Ø§Ù„Ù…Ø³Ø­ (Ù…Ù…)</label>
          <input id="stepOver" type="number" value="5" step="0.1" min="0.1" max="50"/>
          
          <label for="maxDepth">Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ (Ù…Ù…)</label>
          <input id="maxDepth" type="number" value="3.0" step="0.1" min="0.1" max="50"/>

          <!-- Fixed Z + Invert Z -->
          <div style="display:flex;gap:8px;margin-top:10px;align-items:center">
            <label style="font-weight:normal;"><input id="fixedZ" type="checkbox" /> Ø§Ø³ØªØ®Ø¯Ø§Ù… Z Ø«Ø§Ø¨Øª</label>
            <input id="fixedZValue" type="number" value="-1.0" step="0.1" style="width:120px" />
          </div>
          
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <label style="font-weight:normal;"><input id="invertZ" type="checkbox" /> Ø¹ÙƒØ³ Z</label>
            <div style="flex:1"></div>
            <label style="font-weight:normal;color:#9bb0c8">Ù„ÙˆÙ† Ø§Ù„Ø®Ø´Ø¨:</label>
            <select id="woodColor" style="width:140px">
              <option value="#deb887">Ø®Ø´Ø¨ ÙØ§ØªØ­</option>
              <option value="#a0522d" selected>Ø®Ø´Ø¨ Ù…ØªÙˆØ³Ø·</option>
              <option value="#d2b48c">Ø¨ÙŠØ¬</option>
              <option value="#8b5a2b">Ù…Ø§Ù‡ÙˆØ¬Ù†ÙŠ</option>
            </select>
          </div>

          <div class="button-group">
            <div class="button-row">
              <button id="btnGen" class="primary">âš¡ ØªÙˆÙ„ÙŠØ¯ G-code (Raster)</button>
              <button id="btnQuick" class="secondary">ğŸ§ª Ø§Ø®ØªØ¨Ø§Ø± Ø³Ø±ÙŠØ¹</button>
            </div>

            <div style="margin-top:8px">
              <label for="contourMode">Ù†Ø·Ø§Ù‚ Ø§Ù„Ø­ÙˆØ§Ù (Contour)</label>
              <select id="contourMode">
                <option value="outer">Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ© ÙÙ‚Ø·</option>
                <option value="all">ÙƒÙ„ Ø§Ù„Ø­ÙˆØ§Ù</option>
              </select>
              <div style="height:8px"></div>
              <div class="button-row">
                <button id="btnContour" class="secondary">ğŸŒ€ ØªÙˆÙ„ÙŠØ¯ G-code (Contour)</button>
                <button id="btnDownload" class="secondary">ğŸ’¾ ØªØ­Ù…ÙŠÙ„ G-code</button>
              </div>
            </div>
          </div>
        </div>

        <!-- Laser Engraver Settings -->
        <div id="laserSettings" class="machine-settings" style="display:none;">
          <h4 class="laser-specific">âš¡ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Laser Engraver</h4>
          
          <label for="laserWorkWidth">Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
          <input id="laserWorkWidth" type="number" value="300" step="1" min="10" max="2000"/>
          
          <label for="laserWorkHeight">Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
          <input id="laserWorkHeight" type="number" value="200" step="1" min="10" max="2000"/>

          <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
            <div>
              <label for="laserOriginX">Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„ X (Ù…Ù…)</label>
              <input id="laserOriginX" type="number" value="0" step="1"/>
            </div>
            <div>
              <label for="laserOriginY">Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„ Y (Ù…Ù…)</label>
              <input id="laserOriginY" type="number" value="0" step="1"/>
            </div>
          </div>
          <div style="margin-top:6px"><button id="btnLaserCenterOrigin" class="secondary">ğŸ¯ ØªÙˆØ³ÙŠØ· Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„</button></div>

          <!-- Laser Edge Detection Settings -->
          <div class="laser-edge-settings">
            <label for="laserEdgeMode">Ù†Ù…Ø· ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ù„Ù„Ù„ÙŠØ²Ø±</label>
            <select id="laserEdgeMode">
              <option value="canny">Canny (Ø¹Ø§Ø¯ÙŠ)</option>
              <option value="adaptive">Adaptive Threshold (Ù„Ù„Ù†Ù‚Ø´)</option>
              <option value="morphological">Morphological (Ù„Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø©)</option>
              <option value="gradient">Gradient-Based (Ù„Ù„ØªØ¯Ø±Ø¬Ø§Øª)</option>
            </select>
            <div class="laser-mode-description" id="laserModeDesc">
              Adaptive Threshold - Ù…Ù…ØªØ§Ø² Ù„Ù„ØµÙˆØ± Ø°Ø§Øª Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© ØºÙŠØ± Ø§Ù„Ù…ØªØ¬Ø§Ù†Ø³Ø©
            </div>

            <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
              <label style="margin:0;color:#9bb0c8">Ø¯Ù‚Ø© Ø§Ù„Ù„ÙŠØ²Ø±:</label>
              <input id="laserDetail" type="range" min="1" max="10" value="5" step="1" style="flex:1">
              <div id="laserDetailValue" style="min-width:44px;text-align:center;color:#ff4444">5</div>
            </div>
          </div>

          <div style="margin-top: 8px;">
            <button id="btnRedetectLaser" class="secondary">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ÙƒØ´Ù Ø­ÙˆØ§Ù Ø§Ù„Ù„ÙŠØ²Ø±</button>
          </div>

          <hr style="border-color:#ff4444;margin:12px 0"/>

          <!-- Laser Power & Speed -->
          <div style="display:flex;align-items:center;gap:8px;margin-top:12px">
            <label style="margin:0;color:#9bb0c8">Ù‚ÙˆØ© Ø§Ù„Ù„ÙŠØ²Ø±:</label>
            <input id="laserPower" type="range" min="0" max="100" value="80" step="1" style="flex:1">
            <div id="laserPowerValue" style="min-width:44px;text-align:center;color:#ff4444">80%</div>
          </div>

          <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
            <label style="margin:0;color:#9bb0c8">Ø³Ø±Ø¹Ø© Ø§Ù„Ù„ÙŠØ²Ø±:</label>
            <input id="laserSpeed" type="range" min="100" max="5000" value="2000" step="100" style="flex:1">
            <div id="laserSpeedValue" style="min-width:60px;text-align:center;color:#06b6d4">2000</div>
          </div>

          <!-- Laser Mode -->
          <label for="laserMode">ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠØ²Ø±</label>
          <select id="laserMode">
            <option value="grayscale">Ù†Ù‚Ø´ ØªØ¯Ø±Ø¬ Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ</option>
            <option value="dithering">Ù†Ù‚Ø´ Ù…ØªÙ‚Ø·Ø¹ (Dithering)</option>
            <option value="contour">Ù‚Øµ ÙƒÙˆÙ†ØªÙˆØ±</option>
            <option value="combined">Ù†Ù‚Ø´ + Ù‚Øµ</option>
          </select>

          <!-- Dithering Settings -->
          <div id="ditheringSettings" style="margin-top:8px; padding:8px; background:rgba(255,68,68,0.05); border-radius:6px; border:1px solid rgba(255,68,68,0.3)">
            <label for="ditheringType">Ù†ÙˆØ¹ Ø§Ù„ØªÙ‚Ø·ÙŠØ¹</label>
            <select id="ditheringType">
              <option value="floyd">Floyd-Steinberg</option>
              <option value="atkinson">Atkinson</option>
              <option value="bayer">Bayer Matrix</option>
            </select>
            
            <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
              <label style="margin:0;color:#9bb0c8">Ø¯Ù‚Ø© Ø§Ù„ØªÙ‚Ø·ÙŠØ¹:</label>
              <input id="ditheringQuality" type="range" min="1" max="10" value="5" step="1" style="flex:1">
              <div id="ditheringQualityValue" style="min-width:44px;text-align:center;color:#ffaa00">5</div>
            </div>
          </div>

          <!-- Advanced Settings -->
          <div style="margin-top:12px; padding:8px; background:rgba(6,182,212,0.05); border-radius:6px; border:1px solid rgba(6,182,212,0.3)">
            <label style="color:#06b6d4">ğŸ› ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù…ØªÙ‚Ø¯Ù…Ø©</label>
            
            <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
              <label style="font-weight:normal;">
                <input id="laserDynamic" type="checkbox" checked /> 
                Ù‚ÙˆØ© Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© (Ø­Ø³Ø¨ Ø§Ù„Ø¸Ù„Ø§Ù…)
              </label>
            </div>

            <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
              <label style="font-weight:normal;">
                <input id="laserAirAssist" type="checkbox" /> 
                Air Assist
              </label>
            </div>

            <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
              <label style="font-weight:normal;">
                <input id="laserOptimize" type="checkbox" checked /> 
                ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
              </label>
            </div>

            <label for="laserPasses" style="margin-top:8px">Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø±Ø§Øª</label>
            <input id="laserPasses" type="number" value="1" min="1" max="10"/>
          </div>

          <!-- Laser Buttons -->
          <div class="button-group">
            <div class="button-row">
              <button id="btnLaserEngrave" class="primary" style="background:#ff4444; display:none;">âš¡ ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ Ù„ÙŠØ²Ø±</button>
              <button id="btnLaserPreview" class="secondary" style="display:none;">ğŸ‘ï¸ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù„ÙŠØ²Ø±</button>
            </div>
            <div class="button-row">
              <button id="btnLaserOptimize" class="secondary" style="display:none;">ğŸ”„ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª</button>
              <button id="btnLaserDownload" class="secondary" style="display:none;">ğŸ’¾ ØªØ­Ù…ÙŠÙ„ ÙƒÙˆØ¯ Ø§Ù„Ù„ÙŠØ²Ø±</button>
            </div>
          </div>
        </div>

        <div id="estTime" style="margin-top:12px;color:#9bb0c8;text-align:center;padding:8px;background:#0f172a;border-radius:6px"></div>

        <label for="gcodeOut" style="margin-top:12px">ğŸ“„ Ù…Ø®Ø±Ø¬Ø§Øª G-code</label>
        <textarea id="gcodeOut" readonly placeholder="Ø³ÙŠØ¸Ù‡Ø± G-code Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙˆÙ„ÙŠØ¯..." style="height:180px;background:#021024;color:#cfeaf2;border-radius:8px;padding:10px;"></textarea>

      </div>
    </div>
  </div>

  <!-- Debug Overlay -->
  <div id="debugOverlay" aria-live="polite" role="status">
    <div id="debugHeader">
      <div><b>Debug</b> â€” Console</div>
      <div id="debugControls">
        <button id="dbgToggleSize" class="dbg-btn" title="ØªØµØºÙŠØ±/ØªÙƒØ¨ÙŠØ±">ğŸ”½</button>
        <button id="dbgCopy" class="dbg-btn" title="Ù†Ø³Ø® Ø§Ù„Ø³Ø¬Ù„">ğŸ“‹ Ù†Ø³Ø®</button>
        <button id="dbgClear" class="dbg-btn" title="Ù…Ø³Ø­ Ø§Ù„Ø³Ø¬Ù„">ğŸ§¹ Ù…Ø³Ø­</button>
      </div>
    </div>
    <div id="debugList"></div>
    <div id="debugFooter">
      <div id="debugSummary">0 Ø³Ø¬Ù„Ø§Øª</div>
      <div style="flex:1"></div>
      <div style="font-size:12px;color:#9bb0c8">Ø§Ù†Ù‚Ø± Ø§Ù„ØªØµØºÙŠØ± Ù„Ø­ÙØ¸ Ø§Ù„Ø´Ø§Ø´Ø©</div>
    </div>
  </div>

  <div id="toast"></div>

  <script>
    // ================= Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    class ResourceManager {
        constructor() {
            this.mats = new Set();
            this.canvases = new Map();
            this.cleanupInterval = setInterval(() => this.cleanup(), 30000); // ØªÙ†Ø¸ÙŠÙ ÙƒÙ„ 30 Ø«Ø§Ù†ÙŠØ©
        }

        registerMat(mat) {
            if (mat && !mat.isDeleted) {
                this.mats.add(mat);
            }
            return mat;
        }

        registerCanvas(key, canvas) {
            this.canvases.set(key, canvas);
        }

        cleanup() {
            let cleanedMats = 0;
            this.mats.forEach(mat => {
                if (mat && !mat.isDeleted) {
                    try {
                        mat.delete();
                        cleanedMats++;
                    } catch (e) {
                        console.warn('Failed to delete mat:', e);
                    }
                }
            });
            this.mats.clear();
            
            if (cleanedMats > 0) {
                console.log(`ResourceManager: Cleaned ${cleanedMats} mats`);
            }
        }

        destroy() {
            this.cleanup();
            clearInterval(this.cleanupInterval);
        }
    }

    // ================= Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø­Ø§Ù„Ø© =================
    class AppState {
        constructor() {
            this.state = {
                machineType: 'router',
                isProcessing: false,
                currentImage: null,
                gcode: '',
                simulation: {
                    isPlaying: false,
                    progress: 0
                }
            };
            this.listeners = new Set();
        }

        setState(updater) {
            const newState = typeof updater === 'function' ? updater(this.state) : updater;
            this.state = { ...this.state, ...newState };
            this.notifyListeners();
        }

        subscribe(listener) {
            this.listeners.add(listener);
            return () => this.listeners.delete(listener);
        }

        notifyListeners() {
            this.listeners.forEach(listener => listener(this.state));
        }
    }

    // ================= Ù†Ø¸Ø§Ù… Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø£Ø¯Ø§Ø¡ =================
    class PerformanceMonitor {
        constructor() {
            this.metrics = {
                memory: 0,
                fps: 0,
                processingTime: 0
            };
            this.lastTime = performance.now();
            this.frameCount = 0;
        }

        startFrame() {
            this.frameCount++;
            const currentTime = performance.now();
            if (currentTime - this.lastTime >= 1000) {
                this.metrics.fps = this.frameCount;
                this.frameCount = 0;
                this.lastTime = currentTime;
                
                // Ù‚ÙŠØ§Ø³ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© (ØªÙ‚Ø±ÙŠØ¨ÙŠ)
                if (performance.memory) {
                    this.metrics.memory = Math.round(performance.memory.usedJSHeapSize / 1048576);
                }
            }
        }

        startMeasurement(operation) {
            const startTime = performance.now();
            return {
                operation,
                end: () => {
                    const duration = performance.now() - startTime;
                    this.metrics.processingTime = duration;
                    return duration;
                }
            };
        }

        getMetrics() {
            return { ...this.metrics };
        }
    }

    // ================= Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ© =================
    const resourceManager = new ResourceManager();
    const appState = new AppState();
    const performanceMonitor = new PerformanceMonitor();

    // ================= Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø© =================
    let cvReady = false;
    let grayMat = null;
    let contour = null;
    let previewCanvas = null;
    let additionalContours = [];
    let lastScanDir = 'x';
    let lastGeneratedGcode = '';
    let currentColormap = 'jet';

    // Simulation / Three
    let scene, camera, renderer, controls;
    let simulation = { 
        isPlaying: false, 
        animationFrame: null,
        tool: null, 
        toolPath: null, 
        pathPoints: [], 
        index: 0, 
        speed: 1,
        maxPoints: 2000
    };

    const SIM_SCALE = 0.1;

    // ================= Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„ÙŠØ²Ø± =================
    let laserPreviewData = null;
    let optimizedPath = null;

    // ================= Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ù…Ø­Ø³Ù†Ø© =================
    function safeMatDelete(mat) {
        if (mat && !mat.isDeleted && mat.delete) {
            try {
                mat.delete();
            } catch (e) {
                console.warn('Error deleting mat:', e);
            }
        }
    }

    function isMatValid(mat) {
        return mat && !mat.isDeleted && mat.data && mat.data.length > 0;
    }

    function showToast(msg, ms = 3000) {
        const t = document.getElementById('toast');
        t.textContent = msg;
        t.style.display = 'block';
        clearTimeout(t._t);
        t._t = setTimeout(() => t.style.display = 'none', ms);
        console.log('Toast:', msg);
    }

    function showElement(elementId, hidePlaceholderId) {
        const element = document.getElementById(elementId);
        const placeholder = document.getElementById(hidePlaceholderId);
        if (element && placeholder) {
            element.style.display = 'block';
            placeholder.style.display = 'none';
        }
    }

    function validateImageFile(file) {
        const errors = [];
        
        if (!file.type.match('image.*')) {
            errors.push('Ø§Ù„Ù…Ù„Ù ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† ØµÙˆØ±Ø©');
        }
        
        if (file.size > 10 * 1024 * 1024) {
            errors.push('Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© ÙŠØ¬Ø¨ Ø£Ù„Ø§ ÙŠØªØ¬Ø§ÙˆØ² 10MB');
        }
        
        return {
            isValid: errors.length === 0,
            errors
        };
    }

    // ================= Ù†Ø¸Ø§Ù… OpenCV Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    function onOpenCvReady() {
        const measurement = performanceMonitor.startMeasurement('OpenCV Load');
        
        try {
            cvReady = true;
            const cvState = document.getElementById('cvState');
            cvState.innerHTML = '<div style="color:#10b981">âœ… OpenCV Ø¬Ø§Ù‡Ø²</div>';
            
            console.log('OpenCV version:', cv.getBuildInformation ? cv.getBuildInformation() : 'Loaded successfully');
            
            // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙŠ ØµÙˆØ±Ø© Ù…Ø­Ù…Ù„Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹
            if (previewCanvas && previewCanvas.width > 0) {
                const isLaser = document.getElementById('machineCategory').value === 'laser';
                setTimeout(() => {
                    if (isLaser) {
                        detectLaserContours();
                    } else {
                        detectContours();
                    }
                }, 100);
            }
            
            const duration = measurement.end();
            showToast(`ØªÙ… ØªØ­Ù…ÙŠÙ„ OpenCV Ø¨Ù†Ø¬Ø§Ø­ (${duration.toFixed(0)}ms)`, 2000);
            
        } catch (e) {
            console.error('OpenCV initialization error:', e);
            showToast('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ OpenCV', 5000);
        }
    }

    function waitForCv() {
        if (typeof cv !== 'undefined' && cv.getBuildInformation) {
            onOpenCvReady();
        } else {
            setTimeout(waitForCv, 200);
        }
    }

    // Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
    waitForCv();

    // ================= Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ†Ù‚ÙŠØ­ Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    (function initDebugOverlay(){
      const debugList = document.getElementById('debugList');
      const dbgClear = document.getElementById('dbgClear');
      const dbgCopy = document.getElementById('dbgCopy');
      const dbgToggleSize = document.getElementById('dbgToggleSize');
      const debugOverlay = document.getElementById('debugOverlay');
      const debugSummary = document.getElementById('debugSummary');
      const logs = [];

      function formatTime(d) { return d.toISOString().slice(11, 23); }
      function updateSummary() { debugSummary.textContent = logs.length + ' Ø³Ø¬Ù„Ø§Øª'; }

      function addEntry(type, message, stack) {
        const time = new Date();
        const entry = { time, type, message, stack };
        logs.push(entry);
        updateSummary();

        const div = document.createElement('div');
        div.className = 'dbg-item ' + (type === 'error' ? 'dbg-error' : (type === 'warn' ? 'dbg-warn' : 'dbg-info'));
        const tspan = document.createElement('span');
        tspan.className = 'dbg-time';
        tspan.textContent = `[${formatTime(time)}] ${type.toUpperCase()}`;
        const msg = document.createElement('div');
        msg.textContent = message;
        div.appendChild(tspan);
        div.appendChild(msg);
        if (stack) {
          const meta = document.createElement('div');
          meta.className = 'dbg-meta';
          meta.textContent = String(stack).split('\n').slice(0,3).join(' | ');
          div.appendChild(meta);
        }
        debugList.prepend(div);
      }

      dbgClear.addEventListener('click', () => {
        debugList.innerHTML = '';
        logs.length = 0;
        updateSummary();
      });

      dbgCopy.addEventListener('click', async () => {
        try {
          const text = logs.map(l => `[${l.time.toISOString()}] ${l.type.toUpperCase()}: ${l.message}\n${l.stack||''}`).join('\n\n');
          await navigator.clipboard.writeText(text);
          addEntry('info', 'ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø³Ø¬Ù„ Ø¥Ù„Ù‰ Ø§Ù„Ø­Ø§ÙØ¸Ø©');
        } catch (e) {
          addEntry('error', 'ÙØ´Ù„ Ù†Ø³Ø® Ø§Ù„Ø³Ø¬Ù„: ' + (e.message || e));
        }
      });

      dbgToggleSize.addEventListener('click', (ev) => {
        ev.stopPropagation();
        debugOverlay.classList.toggle('minimized');
        dbgToggleSize.textContent = debugOverlay.classList.contains('minimized') ? 'ğŸ”¼' : 'ğŸ”½';
      });

      debugOverlay.addEventListener('click', (ev) => {
        if (debugOverlay.classList.contains('minimized')) {
          debugOverlay.classList.remove('minimized');
          dbgToggleSize.textContent = 'ğŸ”½';
        }
      });

      // override console methods
      const _log = console.log, _warn = console.warn, _error = console.error;
      console.log = function(...args) {
        try { addEntry('info', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' ')); } catch(e){}
        _log.apply(console, args);
      };
      console.warn = function(...args) {
        try { addEntry('warn', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' '), new Error().stack); } catch(e){}
        _warn.apply(console, args);
      };
      console.error = function(...args) {
        try { addEntry('error', args.map(a=> (typeof a==='object' ? JSON.stringify(a) : String(a))).join(' '), new Error().stack); } catch(e){}
        _error.apply(console, args);
      };

      window.addEventListener('error', function(ev){
        try { addEntry('error', ev.message + ' (' + ev.filename + ':' + ev.lineno + ')', ev.error && ev.error.stack ? ev.error.stack : ev.filename + ':' + ev.lineno); } catch(e){}
      });

      window.addEventListener('unhandledrejection', function(ev){
        try { addEntry('error', 'UnhandledRejection: ' + (ev.reason && ev.reason.message ? ev.reason.message : String(ev.reason)), ev.reason && ev.reason.stack ? ev.reason.stack : ''); } catch(e){}
      });

    })();

    // ================= Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    function cleanupMats() {
        try {
            if (grayMat && !grayMat.isDeleted) { 
                grayMat.delete(); 
                grayMat = null; 
            }
        } catch (e) { console.warn('cleanup grayMat', e); }
        
        try {
            if (contour && !contour.isDeleted && contour.delete) {
                contour.delete();
                contour = null;
            }
        } catch (e) { console.warn('cleanup contour', e); }
        
        try {
            additionalContours.forEach(item => {
                if (item && item.contour && !item.contour.isDeleted) {
                    item.contour.delete();
                }
            });
            additionalContours = [];
        } catch (e) { console.warn('cleanup additionalContours', e); }
        
        resourceManager.cleanup();
    }

    // ================= Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª =================
    document.querySelectorAll('.tab-buttons button').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.tab-buttons button').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
            btn.classList.add('active');
            document.getElementById(btn.dataset.tab).classList.add('active');

            if (btn.dataset.tab === 'simulation' && document.getElementById('gcodeOut').value) {
                initSimulation();
            }
        });
    });

    // ================= Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    document.getElementById('machineCategory').addEventListener('change', function(e) {
        const isLaser = e.target.value === 'laser';
        
        document.getElementById('routerSettings').style.display = isLaser ? 'none' : 'block';
        document.getElementById('laserSettings').style.display = isLaser ? 'block' : 'none';
        
        updateButtonVisibility(isLaser);
        updateLaserUI();
        
        if (previewCanvas && cvReady) {
            if (isLaser) {
                detectLaserContours();
            } else {
                detectContours();
            }
        }
        
        appState.setState({ machineType: e.target.value });
        showToast(isLaser ? 'ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠØ²Ø±' : 'ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ ÙˆØ¶Ø¹ Ø§Ù„Ø±ÙˆØ§ØªØ±');
    });

    function updateButtonVisibility(isLaser) {
        const elements = {
            router: ['btnGen', 'btnContour', 'btnQuick'],
            laser: ['btnLaserEngrave', 'btnLaserPreview', 'btnLaserOptimize', 'btnLaserDownload', 'btnRedetectLaser']
        };

        elements.router.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = isLaser ? 'none' : 'block';
        });

        elements.laser.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = isLaser ? 'block' : 'none';
        });
    }

    // ================= Ù†Ø¸Ø§Ù… Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    async function detectContours() {
        if (!cvReady) {
            showToast('OpenCV ØºÙŠØ± Ø¬Ø§Ù‡Ø² Ø¨Ø¹Ø¯');
            return;
        }
        
        if (!previewCanvas || previewCanvas.width === 0 || previewCanvas.height === 0) {
            showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© ØµØ§Ù„Ø­Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©');
            return;
        }
        
        const measurement = performanceMonitor.startMeasurement('Contour Detection');
        let src = null, gray = null, blurred = null, edges = null, hierarchy = null, contours = null, kernel = null;
        
        try {
            src = cv.imread(previewCanvas);
            if (src.empty()) {
                showToast('Ø§Ù„ØµÙˆØ±Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©');
                return;
            }
            
            gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            blurred = new cv.Mat();
            cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);

            const mode = document.getElementById('edgeMode').value || 'auto';
            const sens = parseFloat(document.getElementById('edgeSensitivity').value) || 0.33;

            const median = cv.mean(blurred)[0];
            const lowerThreshold = Math.max(0, (1.0 - sens) * median);
            const upperThreshold = Math.min(255, (1.0 + sens) * median);

            edges = new cv.Mat();
            if (mode === 'sobel') {
                const gradX = new cv.Mat(), gradY = new cv.Mat();
                cv.Sobel(blurred, gradX, cv.CV_16S, 1, 0, 3, 1, 0, cv.BORDER_DEFAULT);
                cv.Sobel(blurred, gradY, cv.CV_16S, 0, 1, 3, 1, 0, cv.BORDER_DEFAULT);
                cv.convertScaleAbs(gradX, gradX);
                cv.convertScaleAbs(gradY, gradY);
                cv.addWeighted(gradX, 0.5, gradY, 0.5, 0, edges);
                gradX.delete(); gradY.delete();
            } else if (mode === 'laplace') {
                cv.Laplacian(blurred, edges, cv.CV_16S, 3, 1, 0, cv.BORDER_DEFAULT);
                cv.convertScaleAbs(edges, edges);
            } else {
                cv.Canny(blurred, edges, lowerThreshold, upperThreshold);
            }

            kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
            cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);

            contours = new cv.MatVector();
            hierarchy = new cv.Mat();
            cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

            const minArea = (gray.cols * gray.rows) * 0.01;
            const validContours = [];
            for (let i = 0; i < contours.size(); i++) {
                const cnt = contours.get(i);
                const area = cv.contourArea(cnt);
                if (area > minArea) {
                    validContours.push({ contour: cnt, area });
                } else {
                    safeMatDelete(cnt);
                }
            }

            if (validContours.length > 0) {
                validContours.sort((a,b)=> b.area - a.area);
                contour = validContours[0].contour;
                additionalContours = validContours.slice(1).map(v => ({ contour: v.contour, area: v.area }));
                showToast(`ØªÙ… ÙƒØ´Ù ${validContours.length} ÙƒÙˆÙ†ØªÙˆØ±`);
            } else {
                showToast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­ÙˆØ§Ù ÙˆØ§Ø¶Ø­Ø© ÙÙŠ Ø§Ù„ØµÙˆØ±Ø©');
                return;
            }

            if (grayMat) { safeMatDelete(grayMat); }
            grayMat = resourceManager.registerMat(gray.clone());

            renderHeatmap();
            renderContour(gray, contour);

            const duration = measurement.end();
            console.log(`Contour detection completed in ${duration.toFixed(0)}ms`);

        } catch (err) {
            console.error('detectContours error', err);
            showToast('ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©');
        } finally {
            safeMatDelete(src);
            safeMatDelete(blurred);
            safeMatDelete(edges);
            safeMatDelete(hierarchy);
            safeMatDelete(contours);
            safeMatDelete(kernel);
            safeMatDelete(gray);
        }
    }

    // ================= Ù†Ø¸Ø§Ù… Ø§Ù„Ù„ÙŠØ²Ø± Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    async function detectLaserContours() {
        if (!cvReady) {
            showToast('OpenCV ØºÙŠØ± Ø¬Ø§Ù‡Ø² Ø¨Ø¹Ø¯');
            return;
        }
        
        if (!previewCanvas || previewCanvas.width === 0 || previewCanvas.height === 0) {
            showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© ØµØ§Ù„Ø­Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©');
            return;
        }
        
        const measurement = performanceMonitor.startMeasurement('Laser Contour Detection');
        showToast('Ø¬Ø§Ø±ÙŠ ÙƒØ´Ù Ø­ÙˆØ§Ù Ø§Ù„Ù„ÙŠØ²Ø±...');
        
        let src = null, gray = null, edges = null, hierarchy = null, contours = null;
        
        try {
            src = cv.imread(previewCanvas);
            if (src.empty()) {
                showToast('Ø§Ù„ØµÙˆØ±Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©');
                return;
            }
            
            gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            
            const mode = document.getElementById('laserEdgeMode').value || 'adaptive';
            const detailLevel = parseInt(document.getElementById('laserDetail').value) || 5;
            
            edges = new cv.Mat();
            
            if (mode === 'adaptive') {
                const adaptive = new cv.Mat();
                const blockSize = Math.max(3, 2 * Math.floor(detailLevel) + 1);
                cv.adaptiveThreshold(gray, adaptive, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, blockSize, 2);
                
                const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                cv.morphologyEx(adaptive, edges, cv.MORPH_CLOSE, kernel);
                
                safeMatDelete(adaptive);
                safeMatDelete(kernel);
                
            } else if (mode === 'morphological') {
                const blurred = new cv.Mat();
                cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0);
                
                const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
                const dilated = new cv.Mat();
                const eroded = new cv.Mat();
                
                cv.dilate(blurred, dilated, kernel);
                cv.erode(blurred, eroded, kernel);
                cv.subtract(dilated, eroded, edges);
                
                cv.normalize(edges, edges, 0, 255, cv.NORM_MINMAX);
                
                safeMatDelete(blurred);
                safeMatDelete(kernel);
                safeMatDelete(dilated);
                safeMatDelete(eroded);
                
            } else if (mode === 'gradient') {
                const blurred = new cv.Mat();
                cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
                
                const gradX = new cv.Mat();
                const gradY = new cv.Mat();
                const absGradX = new cv.Mat();
                const absGradY = new cv.Mat();
                
                cv.Sobel(blurred, gradX, cv.CV_16S, 1, 0, 3, 1, 0, cv.BORDER_DEFAULT);
                cv.Sobel(blurred, gradY, cv.CV_16S, 0, 1, 3, 1, 0, cv.BORDER_DEFAULT);
                
                cv.convertScaleAbs(gradX, absGradX);
                cv.convertScaleAbs(gradY, absGradY);
                cv.addWeighted(absGradX, 0.5, absGradY, 0.5, 0, edges);
                
                const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(2, 2));
                cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);
                
                safeMatDelete(blurred);
                safeMatDelete(gradX);
                safeMatDelete(gradY);
                safeMatDelete(absGradX);
                safeMatDelete(absGradY);
                safeMatDelete(kernel);
                
            } else {
                const blurred = new cv.Mat();
                cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0);
                cv.Canny(blurred, edges, 50, 150);
                safeMatDelete(blurred);
            }

            if (detailLevel > 5) {
                const kernelSize = Math.min(3, Math.floor(detailLevel / 3));
                const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(kernelSize, kernelSize));
                cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);
                safeMatDelete(kernel);
            }

            contours = new cv.MatVector();
            hierarchy = new cv.Mat();
            cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

            const minArea = (gray.cols * gray.rows) * 0.002;
            const validContours = [];
            
            for (let i = 0; i < contours.size(); i++) {
                const cnt = contours.get(i);
                const area = cv.contourArea(cnt);
                if (area > minArea) {
                    validContours.push({ contour: cnt, area });
                } else {
                    safeMatDelete(cnt);
                }
            }

            if (validContours.length > 0) {
                validContours.sort((a,b)=> b.area - a.area);
                contour = validContours[0].contour;
                additionalContours = validContours.slice(1).map(v => ({ contour: v.contour, area: v.area }));
                showToast(`ØªÙ… ÙƒØ´Ù ${validContours.length} ÙƒÙˆÙ†ØªÙˆØ± Ù„Ù„Ù„ÙŠØ²Ø±`);
            } else {
                showToast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­ÙˆØ§Ù Ù…Ù†Ø§Ø³Ø¨Ø© Ù„Ù„Ù„ÙŠØ²Ø±');
                return;
            }

            if (grayMat) { safeMatDelete(grayMat); }
            grayMat = resourceManager.registerMat(gray.clone());

            renderHeatmap();
            renderContour(gray, contour);

            const duration = measurement.end();
            console.log(`Laser contour detection completed in ${duration.toFixed(0)}ms`);

        } catch (err) {
            console.error('detectLaserContours error', err);
            showToast('ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ù„ÙŠØ²Ø±');
        } finally {
            safeMatDelete(src);
            safeMatDelete(gray);
            safeMatDelete(edges);
            safeMatDelete(hierarchy);
            safeMatDelete(contours);
        }
    }

    // ================= Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙ„ÙˆÙŠÙ† Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    function clamp(v, a=0, b=1){ return Math.max(a, Math.min(b, v)); }
    
    function getColormapColor(t, map) {
        t = clamp(t);
        if (map === 'hot') {
            if (t < 0.33) return { r: Math.round(t/0.33*128), g: 0, b: 0 };
            if (t < 0.66) return { r: Math.round(128 + (t-0.33)/0.33*127), g: Math.round((t-0.33)/0.33*128), b: 0 };
            return { r: 255, g: Math.round(128 + (t-0.66)/0.34*127), b: Math.round((t-0.66)/0.34*127) };
        } else if (map === 'cool') {
            return { r: Math.round(255 * t), g: Math.round(255 * (1 - t)), b: 255 };
        } else if (map === 'gray') {
            const v = Math.round(255 * t);
            return { r: v, g: v, b: v };
        } else {
            const r = Math.round(255 * clamp(1.5 - Math.abs(1.0 - 4.0*(t-0.5)), 0, 1));
            const g = Math.round(255 * clamp(1.5 - Math.abs(0.5 - 4.0*(t-0.25)), 0, 1));
            const b = Math.round(255 * clamp(1.5 - Math.abs(0.5 - 4.0*(t)), 0, 1));
            if (!r && !g && !b) {
                const jr = Math.round(255 * clamp(1.5 - Math.abs(1 - 4*(t-0.5))));
                const jg = Math.round(255 * clamp(1.5 - Math.abs(0.5 - 4*(t-0.25))));
                const jb = Math.round(255 * clamp(1.5 - Math.abs(0.5 - 4*t)));
                return { r: jr, g: jg, b: jb };
            }
            return { r, g, b };
        }
    }

    function hexToRgb(hex) {
        if (!hex) return { r:160, g:82, b:45 };
        const h = hex.replace('#','');
        const hh = (h.length===3) ? h.split('').map(c=>c+c).join('') : h;
        const bigint = parseInt(hh, 16);
        return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
    }
    
    function mixColors(c1, c2, t) {
        return {
            r: Math.round(c1.r * (1 - t) + c2.r * t),
            g: Math.round(c1.g * (1 - t) + c2.g * t),
            b: Math.round(c1.b * (1 - t) + c2.b * t)
        };
    }

    function renderHeatmap() {
        if (!grayMat || !previewCanvas) return;
        const heatCanvas = document.getElementById('canvasHeatmap');
        const ctx = heatCanvas.getContext('2d');
        heatCanvas.width = grayMat.cols;
        heatCanvas.height = grayMat.rows;
        const imgData = ctx.createImageData(heatCanvas.width, heatCanvas.height);
        const data = grayMat.data;
        for (let i = 0; i < data.length; i++) {
            const value = data[i];
            const t = value / 255.0;
            const col = getColormapColor(t, currentColormap);
            const idx = i * 4;
            imgData.data[idx] = col.r;
            imgData.data[idx + 1] = col.g;
            imgData.data[idx + 2] = col.b;
            imgData.data[idx + 3] = 255;
        }
        ctx.putImageData(imgData, 0, 0);
        showElement('canvasHeatmap', 'heatmapPlaceholder');

        try {
            if (contour) renderContour(grayMat, contour);
        } catch(e){}
        
        if (lastGeneratedGcode) renderTopViewFromGcode(lastGeneratedGcode);
    }

    function renderContour(gray, mainContour) {
        const contourCanvas = document.getElementById('canvasContour');
        const ctx = contourCanvas.getContext('2d');
        contourCanvas.width = gray.cols;
        contourCanvas.height = gray.rows;
        const heatCanvas = document.getElementById('canvasHeatmap');
        
        try {
            ctx.drawImage(heatCanvas, 0, 0);
        } catch(e) {
            ctx.fillStyle = '#222';
            ctx.fillRect(0,0,contourCanvas.width, contourCanvas.height);
        }
        
        if (mainContour) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const data = mainContour.data32S;
            for (let i = 0; i < data.length; i += 2) {
                const x = data[i], y = data[i + 1];
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.stroke();
        }
        
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 1;
        additionalContours.forEach(ci => {
            try {
                const cnt = ci.contour;
                ctx.beginPath();
                const d = cnt.data32S;
                for (let i = 0; i < d.length; i += 2) {
                    const x = d[i], y = d[i+1];
                    if (i === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
                }
                ctx.closePath();
                ctx.stroke();
            } catch(e) { console.warn('renderContour extra error', e); }
        });
        
        showElement('canvasContour', 'contourPlaceholder');
    }

    // ================= Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø§Øª Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    function sampleGrayAt(x, y) {
        if (!grayMat || !previewCanvas || !isMatValid(grayMat)) return 128;
        const gw = grayMat.cols, gh = grayMat.rows;
        const gx_f = (x / previewCanvas.width) * (gw - 1);
        const gy_f = (y / previewCanvas.height) * (gh - 1);
        const x0 = Math.floor(gx_f), y0 = Math.floor(gy_f);
        const x1 = Math.min(gw - 1, x0 + 1), y1 = Math.min(gh - 1, y0 + 1);
        const sx = gx_f - x0, sy = gy_f - y0;
        const v00 = grayMat.data[y0 * gw + x0];
        const v10 = grayMat.data[y0 * gw + x1];
        const v01 = grayMat.data[y1 * gw + x0];
        const v11 = grayMat.data[y1 * gw + x1];
        const v0 = v00 * (1 - sx) + v10 * sx;
        const v1 = v01 * (1 - sx) + v11 * sx;
        return Math.round(v0 * (1 - sy) + v1 * sy);
    }

    // ================= Ù†Ø¸Ø§Ù… G-code Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    function generateRasterGcode(scaleDown = false) {
        if (!grayMat || !contour) {
            showToast("Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©");
            return "";
        }
        
        const measurement = performanceMonitor.startMeasurement('G-code Generation');
        
        try {
            const dir = document.getElementById('scanDir').value;
            lastScanDir = dir;
            const stepOver = parseFloat(document.getElementById('stepOver').value) || 5;
            const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
            const feed = parseFloat(document.getElementById('feedRate').value) || 800;
            const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;

            const useFixedZ = document.getElementById('fixedZ').checked;
            const fixedZValue = parseFloat(document.getElementById('fixedZValue').value) || -1.0;
            const invertZ = document.getElementById('invertZ').checked;

            const workWidth = parseFloat(document.getElementById('workWidth').value) || 300;
            const workHeight = parseFloat(document.getElementById('workHeight').value) || 200;
            const originX = parseFloat(document.getElementById('originX').value) || 0;
            const originY = parseFloat(document.getElementById('originY').value) || 0;

            const lines = [];
            lines.push('G21 G90 G17');
            lines.push('G0 Z' + safeZ.toFixed(2));

            let totalLen = 0;
            const step = scaleDown ? stepOver * 4 : stepOver;
            const scaleX = workWidth / previewCanvas.width;
            const scaleY = workHeight / previewCanvas.height;

            function addSegmentPoints(rowPoints, startX, endX, y, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue) {
                for (let x = startX; x <= endX; x += 2) {
                    const pv = sampleGrayAt(x, y);
                    let z;
                    if (useFixedZ) {
                        z = fixedZValue;
                    } else {
                        z = -((255 - pv) / 255.0) * maxDepth;
                    }
                    if (invertZ) z = -z;
                    const scaledX = (x * scaleX) + originX;
                    const scaledY = (y * scaleY) + originY;
                    rowPoints.push({ x: scaledX, y: scaledY, z });
                }
            }

            function processRowPoints(rowPoints, lines, feed, safeZ, reverse) {
                if (reverse) rowPoints.reverse();
                lines.push('G0 X' + rowPoints[0].x.toFixed(2) + ' Y' + rowPoints[0].y.toFixed(2) + ' Z' + safeZ.toFixed(2));
                lines.push('G1 F' + feed.toFixed(0));
                for (let i = 0; i < rowPoints.length; i++) {
                    const p = rowPoints[i];
                    lines.push('G1 X' + p.x.toFixed(2) + ' Y' + p.y.toFixed(2) + ' Z' + p.z.toFixed(3));
                }
                lines.push('G0 Z' + safeZ.toFixed(2));
            }

            function calculateRowLength(rowPoints) {
                let length = 0;
                for (let i = 1; i < rowPoints.length; i++) {
                    length += Math.hypot(rowPoints[i].x - rowPoints[i-1].x, rowPoints[i].y - rowPoints[i-1].y);
                }
                return length;
            }

            if (dir === 'x') {
                for (let y = 0; y < previewCanvas.height; y += step) {
                    const rowPoints = [];
                    let inContour = false;
                    let segmentStart = -1;
                    for (let x = 0; x < previewCanvas.width; x += 2) {
                        const pt = new cv.Point(x, y);
                        const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
                        if (inside && !inContour) { segmentStart = x; inContour = true; }
                        else if (!inside && inContour) {
                            addSegmentPoints(rowPoints, segmentStart, x - 1, y, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
                            inContour = false;
                        }
                    }
                    if (inContour) addSegmentPoints(rowPoints, segmentStart, previewCanvas.width - 1, y, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
                    if (rowPoints.length > 1) {
                        processRowPoints(rowPoints, lines, feed, safeZ, (y / step) % 2 !== 0);
                        totalLen += calculateRowLength(rowPoints);
                    }
                }
            } else if (dir === 'y') {
                for (let x = 0; x < previewCanvas.width; x += step) {
                    const colPoints = [];
                    let inContour = false;
                    let segmentStart = -1;
                    for (let y = 0; y < previewCanvas.height; y += 2) {
                        const pt = new cv.Point(x, y);
                        const inside = cv.pointPolygonTest(contour, pt, false) >= 0;
                        if (inside && !inContour) { segmentStart = y; inContour = true; }
                        else if (!inside && inContour) {
                            addSegmentPoints(colPoints, x, x, segmentStart, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
                            inContour = false;
                        }
                    }
                    if (inContour) addSegmentPoints(colPoints, x, x, previewCanvas.height - 1, scaleX, scaleY, originX, originY, maxDepth, invertZ, useFixedZ, fixedZValue);
                    if (colPoints.length > 1) {
                        processRowPoints(colPoints, lines, feed, safeZ, (x / step) % 2 !== 0);
                        totalLen += calculateRowLength(colPoints);
                    }
                }
            }

            lines.push('M5');
            lines.push('M30');

            const timeMin = (totalLen / (feed || 1)) + ((Math.max(0, safeZ) / 50) * (totalLen / 1000));
            const minutes = Math.floor(timeMin);
            const seconds = Math.round((timeMin - minutes) * 60);
            document.getElementById('estTime').innerHTML = `â±ï¸ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ØªÙ‚Ø¯ÙŠØ±ÙŠ: ${minutes} Ø¯Ù‚ÙŠÙ‚Ø© ${seconds} Ø«Ø§Ù†ÙŠØ©`;

            const duration = measurement.end();
            console.log(`G-code generated in ${duration.toFixed(0)}ms`);

            return lines.join('\n');
        } catch (error) {
            console.error('generateRasterGcode error', error);
            showToast('ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ G-code (Raster)');
            return "";
        }
    }

    // ================= Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    function checkThreeJSLoaded() {
        if (typeof THREE === 'undefined') {
            console.warn('THREE.js not loaded yet');
            return false;
        }
        
        if (typeof THREE.OrbitControls === 'undefined') {
            console.warn('OrbitControls not loaded');
        }
        
        return true;
    }

    function parseGcodeForSimulation(gcode) {
        if (!gcode || gcode.length === 0) return [];
        
        const lines = gcode.split('\n');
        const path = [];
        let pos = { x: 0, y: 0, z: 0 };
        let pointCount = 0;
        const maxPoints = simulation.maxPoints || 2000;
        
        for (let line of lines) {
            if (pointCount >= maxPoints) break;
            
            line = line.trim();
            if (!line || line.startsWith(';')) continue;
            
            if (line.startsWith('G0') || line.startsWith('G1')) {
                const xm = line.match(/X([-\d.]+)/i);
                const ym = line.match(/Y([-\d.]+)/i);
                const zm = line.match(/Z([-\d.]+)/i);
                
                if (xm) pos.x = parseFloat(xm[1]);
                if (ym) pos.y = parseFloat(ym[1]);
                if (zm) pos.z = parseFloat(zm[1]);
                
                if (pointCount % 5 === 0) {
                    path.push({ x: pos.x, y: pos.y, z: pos.z });
                }
                pointCount++;
            }
        }
        
        return path;
    }

    function cleanupSimulation() {
        simulation.isPlaying = false;
        simulation.animationFrame && cancelAnimationFrame(simulation.animationFrame);
        simulation.animationFrame = null;
        simulation.index = 0;
        simulation.pathPoints = [];
        
        if (controls) {
            controls.dispose();
            controls = null;
        }
        
        if (renderer) {
            try {
                if (renderer.domElement && renderer.domElement.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                }
                renderer.dispose();
                renderer = null;
            } catch (e) {
                console.warn('Error disposing renderer:', e);
            }
        }
        
        scene = null;
        camera = null;
        simulation.tool = null;
        simulation.toolPath = null;
    }

    function initSimulation() {
        const container = document.getElementById('threeContainer');
        
        if (!checkThreeJSLoaded()) {
            showToast('Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ ØºÙŠØ± Ø¬Ø§Ù‡Ø²Ø©. Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰...');
            setTimeout(initSimulation, 1000);
            return;
        }
        
        cleanupSimulation();
        
        const placeholder = document.getElementById('simulationPlaceholder');
        if (placeholder) placeholder.style.display = 'none';

        try {
            const gcode = document.getElementById('gcodeOut').value;
            if (!gcode || gcode.trim().length === 0) {
                showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
                if (placeholder) placeholder.style.display = 'flex';
                return;
            }

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x081224);

            const containerW = container.clientWidth || 800;
            const containerH = container.clientHeight || 400;
            
            camera = new THREE.PerspectiveCamera(60, containerW / containerH, 0.1, 2000);
            camera.position.set(100, 100, 100);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                antialias: false,
                preserveDrawingBuffer: true
            });
            renderer.setSize(containerW, containerH);
            container.appendChild(renderer.domElement);

            if (typeof THREE.OrbitControls !== 'undefined') {
                try {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = false;
                    controls.screenSpacePanning = true;
                } catch (e) {
                    console.warn('Failed to initialize OrbitControls:', e);
                }
            }

            const ambient = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambient);

            const isLaser = document.getElementById('machineCategory').value === 'laser';
            
            const workWidth = isLaser ? 
                parseFloat(document.getElementById('laserWorkWidth').value) || 300 / 10 :
                parseFloat(document.getElementById('workWidth').value) || 300 / 10;
            const workHeight = isLaser ?
                parseFloat(document.getElementById('laserWorkHeight').value) || 200 / 10 :
                parseFloat(document.getElementById('workHeight').value) || 200 / 10;
            
            const platformGeometry = new THREE.BoxGeometry(workWidth, 0.5, workHeight);
            const platformMaterial = new THREE.MeshPhongMaterial({ 
                color: isLaser ? 0x666666 : 0x8B4513 
            });
            const platformMesh = new THREE.Mesh(platformGeometry, platformMaterial);
            platformMesh.position.set(workWidth/2, -0.25, workHeight/2);
            scene.add(platformMesh);

            const pathPoints = parseGcodeForSimulation(gcode);
            
            if (pathPoints.length > 3000) {
                const simplifiedPoints = [];
                for (let i = 0; i < pathPoints.length; i += 5) {
                    simplifiedPoints.push(pathPoints[i]);
                }
                simulation.pathPoints = simplifiedPoints;
                showToast('ØªÙ… ØªØ¨Ø³ÙŠØ· Ø§Ù„Ù…Ø³Ø§Ø± Ø¥Ù„Ù‰ ' + simplifiedPoints.length + ' Ù†Ù‚Ø·Ø©');
            } else {
                simulation.pathPoints = pathPoints;
            }

            if (simulation.pathPoints.length > 1) {
                const points = simulation.pathPoints.map(p => 
                    new THREE.Vector3((p.x * SIM_SCALE), -p.z, (p.y * SIM_SCALE))
                );
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: isLaser ? 0xff4444 : 0x10b981 
                });
                simulation.toolPath = new THREE.Line(geometry, material);
                scene.add(simulation.toolPath);
            }

            const toolGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
            const toolMaterial = new THREE.MeshPhongMaterial({ 
                color: isLaser ? 0xff4444 : 0xffff00 
            });
            simulation.tool = new THREE.Mesh(toolGeometry, toolMaterial);
            simulation.tool.rotation.x = Math.PI / 2;
            scene.add(simulation.tool);

            const gridHelper = new THREE.GridHelper(Math.max(workWidth, workHeight), 10);
            gridHelper.position.set(workWidth/2, 0, workHeight/2);
            scene.add(gridHelper);

            simulation.index = 0;
            simulation.isPlaying = false;
            simulation.animationFrame = null;

            addSimulationControls(container);

            (function renderLoop() {
                performanceMonitor.startFrame();
                requestAnimationFrame(renderLoop);
                if (controls) controls.update();
                renderer.render(scene, camera);
            })();

            showToast('ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©: ' + simulation.pathPoints.length + ' Ù†Ù‚Ø·Ø©');

        } catch (error) {
            console.error('initSimulation error', error);
            showToast('ÙØ´Ù„ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
            if (placeholder) placeholder.style.display = 'flex';
        }
    }

    function addSimulationControls(container) {
        const old = container.querySelector('.sim-controls');
        if (old) old.remove();
        const oldInfo = container.querySelector('.sim-progress');
        if (oldInfo) oldInfo.remove();

        const controlsDiv = document.createElement('div');
        controlsDiv.className = 'sim-controls';
        controlsDiv.innerHTML = `
            <button id="simPlay">â–¶</button><button id="simPause">â¸</button><button id="simReset">â®</button>
            <label style="color:#cfeaf2;font-size:12px;margin-left:6px">Ø³Ø±Ø¹Ø©</label>
            <input id="simSpeed" type="range" min="0.2" max="3" step="0.1" value="${simulation.speed}" style="width:120px">
            <span id="simSpeedLabel" style="min-width:36px;text-align:center">${simulation.speed.toFixed(1)}x</span>
        `;
        container.appendChild(controlsDiv);

        const prog = document.createElement('div');
        prog.className = 'sim-progress';
        prog.innerHTML = `Ø§Ù„Ø­Ø§Ù„Ø©: <span id="simStatus">Ø¬Ø§Ù‡Ø²</span> â€” ØªÙ‚Ø¯Ù…: <span id="simProgress">0%</span>`;
        container.appendChild(prog);

        document.getElementById('simPlay').addEventListener('click', () => {
            if (!simulation.pathPoints || simulation.pathPoints.length === 0) return;
            if (!simulation.isPlaying) {
                simulation.isPlaying = true;
                animateSimPath();
                document.getElementById('simStatus').textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ´ØºÙŠÙ„';
                showToast('Ø¨Ø¯Ø£Øª Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
            }
        });
        
        document.getElementById('simPause').addEventListener('click', () => {
            if (simulation.isPlaying) {
                simulation.isPlaying = false;
                cancelAnimationFrame(simulation.animationFrame);
                document.getElementById('simStatus').textContent = 'Ù…ØªÙˆÙ‚Ù';
                showToast('Ø£Ù‚ÙÙ„Øª Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ù…Ø¤Ù‚ØªØ§Ù‹');
            }
        });
        
        document.getElementById('simReset').addEventListener('click', () => {
            simulation.isPlaying = false;
            cancelAnimationFrame(simulation.animationFrame);
            simulation.index = 0;
            simulation.elapsedTime = 0;
            updateToolPosition(0);
            document.getElementById('simProgress').textContent = '0%';
            document.getElementById('simStatus').textContent = 'Ø¬Ø§Ù‡Ø²';
            showToast('ØªÙ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
        });

        const speedSlider = document.getElementById('simSpeed');
        const speedLabel = document.getElementById('simSpeedLabel');
        speedSlider.addEventListener('input', (e) => {
            simulation.speed = parseFloat(e.target.value);
            speedLabel.textContent = simulation.speed.toFixed(1) + 'x';
        });
    }

    function animateSimPath() {
        if (!simulation.pathPoints || simulation.pathPoints.length === 0) return;
        const total = simulation.pathPoints.length;
        function step() {
            if (!simulation.isPlaying) return;
            simulation.index += simulation.speed;
            if (simulation.index >= total) {
                simulation.index = total - 1;
                updateToolPosition(simulation.index);
                document.getElementById('simProgress').textContent = '100%';
                document.getElementById('simStatus').textContent = 'Ù…ÙƒØªÙ…Ù„';
                simulation.isPlaying = false;
                cancelAnimationFrame(simulation.animationFrame);
                showToast('Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
                return;
            }
            updateToolPosition(simulation.index);
            const prog = ((Math.floor(simulation.index) + 1) / total) * 100;
            document.getElementById('simProgress').textContent = prog.toFixed(1) + '%';
            simulation.animationFrame = requestAnimationFrame(step);
        }
        if (!simulation.animationFrame) step();
    }

    function updateToolPosition(index) {
        if (!simulation.tool || !simulation.pathPoints || simulation.pathPoints.length === 0) return;
        const i = Math.floor(index);
        const p = simulation.pathPoints[i];
        if (!p) return;
        simulation.tool.position.set((p.x * SIM_SCALE), -p.z, (p.y * SIM_SCALE));
    }

    // ================= Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ø¹Ù„ÙˆÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    function renderTopViewFromGcode(gcode) {
        try {
            if (!previewCanvas) return;
            const topCanvas = document.getElementById('topView');
            const legendDiv = document.getElementById('topLegend');
            const tw = previewCanvas.width, th = previewCanvas.height;
            topCanvas.width = tw; topCanvas.height = th;
            const ctx = topCanvas.getContext('2d');

            const depthMap = new Float32Array(tw * th);
            const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3.0;

            const points = parseGcodeForSimulation(gcode);

            const isLaser = document.getElementById('machineCategory').value === 'laser';
            
            const baseRgb = isLaser ? { r: 40, g: 40, b: 40 } : hexToRgb(document.getElementById('woodColor').value || '#a0522d');
            const blackRgb = { r: 10, g: 6, b: 3 };

            const workWidth = isLaser ? 
                parseFloat(document.getElementById('laserWorkWidth').value) || 300 :
                parseFloat(document.getElementById('workWidth').value) || 300;
            const workHeight = isLaser ?
                parseFloat(document.getElementById('laserWorkHeight').value) || 200 :
                parseFloat(document.getElementById('workHeight').value) || 200;
            const originX = isLaser ?
                parseFloat(document.getElementById('laserOriginX').value) || 0 :
                parseFloat(document.getElementById('originX').value) || 0;
            const originY = isLaser ?
                parseFloat(document.getElementById('laserOriginY').value) || 0 :
                parseFloat(document.getElementById('originY').value) || 0;

            function mmToPixel(px_mm_x, px_mm_y) {
                const xRatio = (px_mm_x - originX) / workWidth;
                const yRatio = (px_mm_y - originY) / workHeight;
                const xPix = Math.round(xRatio * (tw - 1));
                const yPix = th - 1 - Math.round(yRatio * (th - 1));
                return { x: xPix, y: yPix };
            }

            for (let i=0;i<depthMap.length;i++) depthMap[i]=0;

            if (!points || points.length === 0) {
                const imgData = ctx.createImageData(tw, th);
                for (let y=0;y<th;y++){
                    for (let x=0;x<tw;x++){
                        const v = sampleGrayAt(x,y);
                        const depth = ((255 - v)/255.0)*maxDepth;
                        const t = depth / maxDepth;
                        const cmapCol = getColormapColor(t, currentColormap);
                        const mixed1 = mixColors(baseRgb, blackRgb, t*0.6);
                        const finalCol = mixColors(mixed1, cmapCol, isLaser ? 0.5 : 0.35);
                        const idx = (y*tw + x)*4;
                        imgData.data[idx]=finalCol.r; imgData.data[idx+1]=finalCol.g; imgData.data[idx+2]=finalCol.b; imgData.data[idx+3]=255;
                    }
                }
                ctx.putImageData(imgData,0,0);
                drawTopLegend(currentColormap);
                return;
            }

            for (let i=0;i<points.length;i++) {
                const p = points[i];
                if (typeof p.x === 'undefined') continue;
                const coords = mmToPixel(p.x, p.y);
                if (coords.x < 0 || coords.x >= tw || coords.y < 0 || coords.y >= th) continue;
                const depth = isLaser ? Math.abs(p.z) : Math.min(Math.abs(p.z), maxDepth);
                const idx = coords.y * tw + coords.x;
                depthMap[idx] = Math.max(depthMap[idx], depth);
                const spread = isLaser ? 1 : 2;
                for (let oy=-spread; oy<=spread; oy++) {
                    for (let ox=-spread; ox<=spread; ox++) {
                        const nx = coords.x + ox, ny = coords.y + oy;
                        if (nx<0||nx>=tw||ny<0||ny>=th) continue;
                        const nIdx = ny*tw + nx;
                        const weight = Math.max(0, 1 - (Math.hypot(ox,oy) / (spread + 0.1)));
                        depthMap[nIdx] = Math.max(depthMap[nIdx], depth * weight);
                    }
                }
            }

            const imgData = ctx.createImageData(tw, th);
            for (let y=0;y<th;y++) {
                for (let x=0;x<tw;x++) {
                    const idx = y*tw + x;
                    const d = Math.min(depthMap[idx], maxDepth);
                    const t = (maxDepth === 0) ? 0 : (d / maxDepth);
                    const cmapCol = getColormapColor(t, currentColormap);
                    const mixed1 = mixColors(baseRgb, blackRgb, t*0.6);
                    const finalCol = mixColors(mixed1, cmapCol, isLaser ? 0.5 : 0.35);
                    const di = (y*tw + x)*4;
                    imgData.data[di] = finalCol.r;
                    imgData.data[di+1] = finalCol.g;
                    imgData.data[di+2] = finalCol.b;
                    imgData.data[di+3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);

            drawTopLegend(currentColormap);

        } catch (e) {
            console.error('renderTopViewFromGcode error', e);
        }
    }

    function drawTopLegend(map) {
        try {
            const legend = document.getElementById('topLegend');
            const steps = 6;
            const stops = [];
            for (let i=0;i<=steps;i++){
                const t = i / steps;
                const c = getColormapColor(t, map);
                stops.push(`rgb(${c.r},${c.g},${c.b}) ${Math.round((i/steps)*100)}%`);
            }
            legend.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
        } catch(e){}
    }

    // ================= Ù†Ø¸Ø§Ù… Ø§Ù„Ù„ÙŠØ²Ø± Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    function updateLaserUI() {
        const isLaser = document.getElementById('machineCategory').value === 'laser';
        const laserPreviewTab = document.getElementById('laserPreviewTab');
        
        if (isLaser) {
            laserPreviewTab.style.display = 'block';
            const ditheringSettings = document.getElementById('ditheringSettings');
            const laserMode = document.getElementById('laserMode').value;
            ditheringSettings.style.display = laserMode === 'dithering' ? 'block' : 'none';
        } else {
            laserPreviewTab.style.display = 'none';
        }
    }

    const laserModeDescriptions = {
        canny: 'Canny - ÙƒØ´Ù Ø­ÙˆØ§Ù ØªÙ‚Ù„ÙŠØ¯ÙŠ Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„ØµÙˆØ± Ø§Ù„Ø¹Ø§Ù…Ø©',
        adaptive: 'Adaptive Threshold - Ù…Ù…ØªØ§Ø² Ù„Ù„ØµÙˆØ± Ø°Ø§Øª Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© ØºÙŠØ± Ø§Ù„Ù…ØªØ¬Ø§Ù†Ø³Ø©',
        morphological: 'Morphological - Ù„Ù„Ø­ÙˆØ§Ù Ø§Ù„Ø¯Ù‚ÙŠÙ‚Ø© ÙˆØ§Ù„Ù†Ø§Ø¹Ù…Ø© ÙˆØ§Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„ØµØºÙŠØ±Ø©',
        gradient: 'Gradient-Based - Ù„Ù„ØªØ¯Ø±Ø¬Ø§Øª Ø§Ù„Ù„ÙˆÙ†ÙŠØ© ÙˆØ§Ù„ØµÙˆØ± Ø°Ø§Øª Ø§Ù„ØªØ¨Ø§ÙŠÙ† Ø§Ù„Ø¹Ø§Ù„ÙŠ'
    };

    // ================= Ù†Ø¸Ø§Ù… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…Ø­Ø³Ù‘Ù† =================
    document.getElementById('fileInput').addEventListener('change', async function (e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const validation = validateImageFile(file);
        if (!validation.isValid) {
            showToast(validation.errors[0]);
            return;
        }
        
        try {
            cleanupMats();
            const img = new Image();
            
            img.onerror = function() {
                showToast('ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù ØµØ§Ù„Ø­');
            };
            
            img.src = URL.createObjectURL(file);
            await img.decode();

            previewCanvas = document.getElementById('canvasOriginal');
            const ctx = previewCanvas.getContext('2d');

            const maxPixels = 1024 * 1024;
            let w = img.width, h = img.height;
            const currentPixels = w * h;
            if (currentPixels > maxPixels) {
                const ratio = Math.sqrt(maxPixels / currentPixels);
                w = Math.floor(w * ratio);
                h = Math.floor(h * ratio);
                showToast('ØªÙ… ØªØ­Ø³ÙŠÙ† Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ø£ÙØ¶Ù„');
            }

            previewCanvas.width = w;
            previewCanvas.height = h;
            ctx.drawImage(img, 0, 0, w, h);
            showElement('canvasOriginal', 'originalPlaceholder');

            appState.setState({ currentImage: { width: w, height: h } });

            if (cvReady) {
                const isLaser = document.getElementById('machineCategory').value === 'laser';
                if (isLaser) {
                    detectLaserContours();
                } else {
                    detectContours();
                }
            } else {
                showToast('ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± OpenCV...');
                setTimeout(async () => { 
                    if (cvReady) {
                        const isLaser = document.getElementById('machineCategory').value === 'laser';
                        if (isLaser) {
                            detectLaserContours();
                        } else {
                            detectContours();
                        }
                    }
                }, 800);
            }
        } catch (error) {
            console.error('image load error', error);
            showToast('ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©');
        }
    });

    // ================= Ø§Ù„Ø±Ø¨Ø· Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù„Ø£Ø­Ø¯Ø§Ø« =================
    document.addEventListener('DOMContentLoaded', () => {
        showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨Ù†Ø¬Ø§Ø­', 1200);
        
        document.getElementById('fileInput').addEventListener('click', function(e) {
            this.value = '';
        });
        
        let updateTimeout;
        const updateDim = () => {
            clearTimeout(updateTimeout);
            updateTimeout = setTimeout(() => {
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ø±ÙˆØ¶ Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
            }, 200);
        };
        
        document.getElementById('workWidth').addEventListener('input', updateDim);
        document.getElementById('workHeight').addEventListener('input', updateDim);
        document.getElementById('laserWorkWidth').addEventListener('input', updateDim);
        document.getElementById('laserWorkHeight').addEventListener('input', updateDim);

        const machineDefaults = {
            router: { feed: 800, safeZ: 5, maxDepth: 3, stepOver: 5 },
            laser: { feed: 2000, safeZ: 0, maxDepth: 0, stepOver: 0.2 }
        };
        
        document.getElementById('machineCategory').addEventListener('change', (e) => {
            const def = machineDefaults[e.target.value];
            if (def) {
                document.getElementById('feedRate').value = def.feed;
                document.getElementById('safeZ').value = def.safeZ;
                document.getElementById('maxDepth').value = def.maxDepth;
                document.getElementById('stepOver').value = def.stepOver;
                document.getElementById('laserSpeed').value = def.feed;
                showToast(`ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ${e.target.value}`);
            }
        });
        
        updateLaserUI();

        // Ø±Ø¨Ø· Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù„ÙŠØ²Ø±
        document.getElementById('laserPower').addEventListener('input', function(e) {
            document.getElementById('laserPowerValue').textContent = e.target.value + '%';
            document.getElementById('laserPowerValue').style.color = `hsl(${e.target.value * 1.2}, 100%, 60%)`;
        });

        document.getElementById('laserSpeed').addEventListener('input', function(e) {
            document.getElementById('laserSpeedValue').textContent = e.target.value;
        });

        document.getElementById('ditheringQuality').addEventListener('input', function(e) {
            document.getElementById('ditheringQualityValue').textContent = e.target.value;
        });

        document.getElementById('laserMode').addEventListener('change', function() {
            updateLaserUI();
        });

        document.getElementById('laserEdgeMode').addEventListener('change', function(e) {
            document.getElementById('laserModeDesc').textContent = laserModeDescriptions[e.target.value] || '';
            if (!previewCanvas) return;
            const isLaser = document.getElementById('machineCategory').value === 'laser';
            if (isLaser && cvReady && previewCanvas && previewCanvas.width > 0) {
                detectLaserContours();
            }
        });

        document.getElementById('laserDetail').addEventListener('input', function(e) {
            document.getElementById('laserDetailValue').textContent = e.target.value;
        });

        document.getElementById('btnRedetectLaser').addEventListener('click', () => {
            if (!previewCanvas) {
                showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ù…Ø­Ù…Ù„Ø©');
                return;
            }
            if (cvReady) {
                detectLaserContours();
            }
        });

        // Ø±Ø¨Ø· Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ø­ÙˆØ§Ù
        document.getElementById('edgeMode').addEventListener('change', () => {
            if (!previewCanvas) return;
            const isLaser = document.getElementById('machineCategory').value === 'laser';
            if (!isLaser && cvReady && previewCanvas && previewCanvas.width > 0) detectContours();
        });
        
        document.getElementById('edgeSensitivity').addEventListener('input', (e) => {
            document.getElementById('edgeValue').textContent = parseFloat(e.target.value).toFixed(2);
            if (!previewCanvas) return;
            const isLaser = document.getElementById('machineCategory').value === 'laser';
            if (!isLaser && cvReady && previewCanvas && previewCanvas.width > 0) detectContours();
        });

        // Ø±Ø¨Ø· Ø£Ø²Ø±Ø§Ø± G-code
        document.getElementById('btnGen').addEventListener('click', () => {
            const gcode = generateRasterGcode(false);
            document.getElementById('gcodeOut').value = gcode;
            lastGeneratedGcode = gcode;
            if (gcode) {
                showToast("ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code (Raster)");
                renderTopViewFromGcode(gcode);
                document.querySelector('.tab-buttons button[data-tab="simulation"]').click();
            }
        });

        document.getElementById('btnQuick').addEventListener('click', () => {
            const gcode = generateRasterGcode(true);
            document.getElementById('gcodeOut').value = gcode;
            lastGeneratedGcode = gcode;
            if (gcode) {
                showToast("ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code Ø³Ø±ÙŠØ¹ (Raster)");
                renderTopViewFromGcode(gcode);
                document.querySelector('.tab-buttons button[data-tab="simulation"]').click();
            }
        });

        document.getElementById('btnContour').addEventListener('click', () => {
            const gcode = generateContourGcode();
            document.getElementById('gcodeOut').value = gcode;
            lastGeneratedGcode = gcode;
            if (gcode) {
                showToast("ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code (Contour)");
                renderTopViewFromGcode(gcode);
                document.querySelector('.tab-buttons button[data-tab="simulation"]').click();
            }
        });

        document.getElementById('btnDownload').addEventListener('click', () => {
            const text = document.getElementById('gcodeOut').value;
            if (!text) { showToast("Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„ØªØ­Ù…ÙŠÙ„Ù‡"); return; }
            try {
                const now = new Date();
                const dateStr = now.toISOString().slice(0, 19).replace(/[:.]/g, '-');
                const machineType = document.getElementById('machineCategory').value;
                const filename = `${machineType}_output_${dateStr}.gcode`;
                const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast(`ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù: ${filename}`);
            } catch (error) {
                console.error('file download error', error);
                showToast('ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù');
            }
        });

        document.getElementById('btnCenterOrigin').addEventListener('click', () => {
            const workWidth = parseFloat(document.getElementById('workWidth').value) || 0;
            const workHeight = parseFloat(document.getElementById('workHeight').value) || 0;
            document.getElementById('originX').value = (workWidth / 2).toFixed(1);
            document.getElementById('originY').value = (workHeight / 2).toFixed(1);
            showToast("ØªÙ… ØªÙˆØ³ÙŠØ· Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„");
        });

        document.getElementById('btnLaserCenterOrigin').addEventListener('click', function() {
            const workWidth = parseFloat(document.getElementById('laserWorkWidth').value) || 0;
            const workHeight = parseFloat(document.getElementById('laserWorkHeight').value) || 0;
            document.getElementById('laserOriginX').value = (workWidth / 2).toFixed(1);
            document.getElementById('laserOriginY').value = (workHeight / 2).toFixed(1);
            showToast("ØªÙ… ØªÙˆØ³ÙŠØ· Ù†Ù‚Ø·Ø© Ø§Ù„Ø£ØµÙ„ Ù„Ù„Ù„ÙŠØ²Ø±");
        });

        // Ø±Ø¨Ø· Ø£Ø²Ø±Ø§Ø± Colormap
        document.querySelectorAll('#colormapButtons button').forEach(btn=>{
            btn.addEventListener('click', ()=>{
                document.querySelectorAll('#colormapButtons button').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
                currentColormap = btn.dataset.map;
                
                if (document.getElementById('heatmap').classList.contains('active')) {
                    renderHeatmap();
                }
                
                if (lastGeneratedGcode) {
                    renderTopViewFromGcode(lastGeneratedGcode);
                }
                
                if (document.getElementById('contour').classList.contains('active') && grayMat && contour) {
                    renderContour(grayMat, contour);
                }
                
                showToast('ØªÙ… ØªØºÙŠÙŠØ± Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø¥Ù„Ù‰ ' + currentColormap);
            });
        });

        // Ø§Ø®ØªØµØ§Ø±Ø§Øª Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
        document.addEventListener('keydown', function (e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 'g': e.preventDefault(); 
                        if (document.getElementById('machineCategory').value === 'laser') {
                            // document.getElementById('btnLaserEngrave').click();
                        } else {
                            document.getElementById('btnGen').click();
                        }
                        break;
                    case 'r': e.preventDefault(); 
                        if (document.getElementById('machineCategory').value === 'laser') {
                            // document.getElementById('btnLaserPreview').click();
                        } else {
                            document.getElementById('btnQuick').click();
                        }
                        break;
                    case 'd': e.preventDefault(); document.getElementById('btnDownload').click(); break;
                    case '`': e.preventDefault(); document.getElementById('dbgToggleSize').click(); break;
                }
            }
        });
    });

    // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø­Ø¬Ù…
    window.addEventListener('resize', () => {
        const container = document.getElementById('threeContainer');
        if (camera && renderer && container) {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        try {
            const top = document.getElementById('topView');
            if (previewCanvas && top) {
                top.width = previewCanvas.width; top.height = previewCanvas.height;
            }
        } catch(e){}
    });

    // Ø§Ù„ØªÙ†Ø¸ÙŠÙ Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØµÙØ­Ø©
    window.addEventListener('beforeunload', () => {
        resourceManager.destroy();
        cleanupMats();
        cleanupSimulation();
    });

  </script>
</body>
</html>
