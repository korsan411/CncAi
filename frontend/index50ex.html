<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CNC Raster 3D Engraver — Stable</title>

<!-- مكتبات -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

<style>
:root{--bg:#041022;--panel:#0b1320;--accent:#06b6d4;--muted:#9bb0c8}
body{margin:0;font-family:Arial,Segoe UI,system-ui;background:linear-gradient(180deg,#021021,#041022);color:#e6eef6}
.app{max-width:1200px;margin:16px auto;padding:14px}
header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
h1{margin:0;color:var(--accent)}
.grid{display:grid;grid-template-columns:1fr 460px;gap:12px}
.panel{background:var(--panel);padding:12px;border-radius:10px}
.tabs{display:flex;gap:8px;margin-top:8px}
.tab{padding:6px 10px;border-radius:8px;cursor:pointer;background:rgba(255,255,255,0.02)}
.tab.active{background:rgba(6,182,212,0.13);color:var(--accent)}
.preview-wrap{position:relative;background:#000;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
canvas{display:block;width:100%;height:auto}
.controls-row{display:flex;gap:8px;margin-top:8px}
label{display:block;margin-top:8px;color:var(--muted)}
input,select,button,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#e6eef6;box-sizing:border-box}
button.primary{background:var(--accent);color:#042;border:none;cursor:pointer;font-weight:700}
button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
textarea{height:220px;background:#021024;color:#cfeaf2;font-family:monospace;white-space:pre-wrap;overflow:auto}
.small{font-size:13px;color:var(--muted)}
#toast{position:fixed;left:16px;bottom:16px;background:rgba(0,0,0,0.85);color:#fff;padding:8px 10px;border-radius:8px;display:none;z-index:10000}
@media(max-width:980px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="app">
  <header>
    <div>
      <h1>CNC Raster 3D Engraver — Stable</h1>
      <div class="small">Raster-fill داخل الحد الخارجي + Heatmap → G-code Router 3D</div>
    </div>
    <div class="small" id="cvState">OpenCV: جاري التحميل...</div>
  </header>

  <div class="grid">
    <!-- Left: previews -->
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <input id="fileInput" type="file" accept="image/*"/>
          <div class="small" style="margin-top:4px">حمّل صورة (JPEG/PNG)</div>
        </div>
        <div class="small" id="imgInfo">لم تُحمّل صورة</div>
      </div>

      <div class="tabs" role="tablist">
        <div class="tab active" data-tab="original">الأصلية</div>
        <div class="tab" data-tab="heatmap">Heatmap</div>
        <div class="tab" data-tab="contour">Contour</div>
        <div class="tab" data-tab="3d">3D Preview</div>
      </div>

      <div id="view-original" class="preview-wrap" style="margin-top:10px">
        <canvas id="previewCanvas" width="900" height="600"></canvas>
      </div>

      <div id="view-heatmap" class="preview-wrap" style="margin-top:10px;display:none">
        <canvas id="heatmapCanvas"></canvas>
      </div>

      <div id="view-contour" class="preview-wrap" style="margin-top:10px;display:none">
        <canvas id="contourCanvas"></canvas>
      </div>

      <div id="view-3d" style="margin-top:10px;display:none">
        <div id="threeContainer" style="height:440px;border-radius:8px;overflow:hidden"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="btnShowAll" class="secondary">عرض كل المسارات</button>
          <button id="btnShowSample" class="secondary">عرض عيّنة</button>
        </div>
      </div>

      <div class="controls-row" style="margin-top:10px">
        <button id="btnDetect" class="primary">كشف الحواف وتهيئة Heatmap</button>
        <button id="btnQuickTest" class="secondary">اختبار سريع (low-res)</button>
        <button id="btnHeat" class="secondary">عرض Heatmap</button>
      </div>
    </div>

    <!-- Right: Settings & generation -->
    <div class="panel">
      <h3 style="margin:0 0 8px 0">إعدادات التوليد</h3>

      <label>عرض العمل الحقيقي (مم) — يربط px → mm
        <input id="realWidth" type="number" value="200" step="1"/>
      </label>

      <div style="display:flex;gap:8px;margin-top:8px">
        <label style="flex:1">Feed (مم/دقيقة)<input id="feedRate" type="number" value="800" step="1"/></label>
        <label style="flex:1">Safe Z (مم)<input id="safeZ" type="number" value="5.0" step="0.1"/></label>
      </div>

      <label style="margin-top:8px">Invert Z
        <select id="invertZ"><option value="no">لا</option><option value="yes">نعم</option></select>
      </label>

      <hr style="border-color:rgba(255,255,255,0.04)">

      <h4 style="margin:8px 0 4px 0">Raster Engraving (داخل الشكل)</h4>

      <label>اتجاه المسارات
        <select id="scanDir"><option value="x">أفقي (X)</option><option value="y">رأسي (Y)</option></select>
      </label>

      <div style="display:flex;gap:8px;margin-top:8px">
        <label style="flex:1">خطوة المسح (مم) — Step-over<input id="stepOver" type="number" value="1.0" step="0.1" min="0.1"/></label>
        <label style="flex:1">أقصى عمق (مم)<input id="maxDepth" type="number" value="3.0" step="0.1" min="0"/></label>
      </div>

      <label style="margin-top:8px">دقة Heatmap (procRes px — أكبر بُعد)
        <input id="procRes" type="number" value="360" step="16" min="32" max="1600"/>
      </label>

      <label style="margin-top:8px">حد أدنى لمساحة الشكل (نسبة مئوية من معاينة) — لإقصاء الضجيج
        <input id="minAreaPct" type="number" value="0.5" step="0.1" min="0"/>
      </label>

      <div style="display:flex;gap:8px;margin-top:12px">
        <button id="btnGen" class="primary">توليد G-code</button>
        <button id="btnDownload" class="secondary">تحميل G-code</button>
      </div>

      <label style="margin-top:8px">G-code الناتج</label>
      <textarea id="gcodeOut" readonly placeholder="G-code سيظهر هنا..."></textarea>

      <div id="timeEst" class="small" style="margin-top:8px">تقدير الوقت: —</div>
      <div id="summary" class="small" style="margin-top:6px">حالة: جاهز</div>
    </div>
  </div>
</div>

<div id="toast"></div>

<script>
/* ======= Utilities & State ======= */
const toast = document.getElementById('toast');
function showToast(msg, ms=2200){ toast.textContent = msg; toast.style.display='block'; clearTimeout(toast._t); toast._t=setTimeout(()=>toast.style.display='none', ms); }

let cvReady = false;
function markCvReady(){ cvReady = true; document.getElementById('cvState').textContent = 'OpenCV جاهز'; showToast('OpenCV جاهز'); }
function waitForCv(){ if(window.cv && cv.getBuildInformation) markCvReady(); else if(window.cv) cv.onRuntimeInitialized = markCvReady; else setTimeout(waitForCv,200); }
waitForCv();

const previewCanvas = document.getElementById('previewCanvas');
const heatmapCanvas = document.getElementById('heatmapCanvas');
const contourCanvas = document.getElementById('contourCanvas');
const pctx = previewCanvas.getContext('2d');
const hctx = heatmapCanvas.getContext('2d');
const cctx = contourCanvas.getContext('2d');

let originalImage = null;
let procImageSize = {w:0,h:0};
let grayMat = null;           // scaled gray mat used for sampling
let chosenContourMat = null;  // contour Mat (in preview pixel coords)
let outerContours = [];       // other contours (if needed)
window._lastCutSegments = []; // segments for 3D overlay

/* Jet LUT (for heatmap preview) */
const JET_LUT = (() => {
  const lut = new Uint8ClampedArray(256*3);
  for(let i=0;i<256;i++){
    const x = i/255;
    const r = Math.round(255 * Math.max(Math.min(1.5 - Math.abs(4*x-3), 1), 0));
    const g = Math.round(255 * Math.max(Math.min(1.5 - Math.abs(4*x-2), 1), 0));
    const b = Math.round(255 * Math.max(Math.min(1.5 - Math.abs(4*x-1), 1), 0));
    lut[i*3+0]=r; lut[i*3+1]=g; lut[i*3+2]=b;
  }
  return lut;
})();

/* ======= Tabs ======= */
document.querySelectorAll('.tab').forEach(t => {
  t.addEventListener('click', ()=> {
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    const tab = t.dataset.tab;
    document.getElementById('view-original').style.display = (tab === 'original') ? 'block' : 'none';
    document.getElementById('view-heatmap').style.display = (tab === 'heatmap') ? 'block' : 'none';
    document.getElementById('view-contour').style.display = (tab === 'contour') ? 'block' : 'none';
    document.getElementById('view-3d').style.display = (tab === '3d') ? 'block' : 'none';
    if(tab === '3d' && grayMat) build3DPreview(false);
  });
});

/* ======= Load image & prepare preview ======= */
document.getElementById('fileInput').addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => {
    originalImage = img;
    // scale preview to max width/height
    const maxW = 900, maxH = 600;
    const ratio = Math.min(maxW/img.width, maxH/img.height, 1);
    previewCanvas.width = Math.round(img.width * ratio);
    previewCanvas.height = Math.round(img.height * ratio);
    procImageSize.w = previewCanvas.width;
    procImageSize.h = previewCanvas.height;
    pctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
    pctx.drawImage(img, 0, 0, previewCanvas.width, previewCanvas.height);
    document.getElementById('imgInfo').textContent = `معاينة: ${previewCanvas.width}×${previewCanvas.height}`;
    document.getElementById('summary').textContent = 'صورة محمّلة — اضغط "كشف الحواف"';
    // clear previous
    if(grayMat){ try{ grayMat.delete(); } catch(e){} grayMat = null; }
    if(chosenContourMat){ try{ chosenContourMat.delete(); } catch(e){} chosenContourMat = null; }
    outerContours.forEach(o=>{ try{o.contour.delete(); } catch(e){} });
    outerContours = [];
    window._lastCutSegments = [];
    showToast('تم تحميل الصورة');
  };
  img.src = url;
});

/* ======= Detect contours & prepare grayMat (procRes) ======= */
document.getElementById('btnDetect').addEventListener('click', ()=>{
  if(!originalImage) return showToast('حمّل صورة أولاً');
  if(!cvReady) return showToast('OpenCV لا يزال يحمل');
  showToast('جاري كشف الحواف وتهيئة Heatmap — انتظر...');

  // Read preview canvas (scaled) into OpenCV
  let src = cv.imread(previewCanvas);
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

  // Smooth then detect edges
  cv.GaussianBlur(gray, gray, new cv.Size(3,3), 0, 0, cv.BORDER_DEFAULT);
  let edges = new cv.Mat();
  cv.Canny(gray, edges, 50, 150);

  // find external contours
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  // collect contours with area
  outerContours = [];
  const totalArea = previewCanvas.width * previewCanvas.height;
  for(let i=0;i<contours.size();i++){
    const cnt = contours.get(i);
    const a = Math.abs(cv.contourArea(cnt));
    outerContours.push({contour: cnt.clone(), area: a});
    cnt.delete();
  }
  // sort desc
  outerContours.sort((A,B)=>B.area - A.area);

  // filter by min area percentage
  const minPct = Math.max(0, parseFloat(document.getElementById('minAreaPct').value || 0.5)) / 100.0;
  const kept = [];
  for(const o of outerContours){
    if(o.area >= (minPct * totalArea)) kept.push(o);
    else { try{o.contour.delete(); } catch(e){} }
  }
  outerContours = kept;

  // if none left, fallback to whole-rectangle contour
  if(outerContours.length === 0){
    const rect = new cv.Mat();
    rect.create(4,1,cv.CV_32SC2);
    rect.data32S[0]=0; rect.data32S[1]=0;
    rect.data32S[2]=previewCanvas.width; rect.data32S[3]=0;
    rect.data32S[4]=previewCanvas.width; rect.data32S[5]=previewCanvas.height;
    rect.data32S[6]=0; rect.data32S[7]=previewCanvas.height;
    outerContours.push({contour: rect, area: previewCanvas.width*previewCanvas.height});
  }

  // choose largest contour
  if(chosenContourMat){ try{ chosenContourMat.delete(); } catch(e){} chosenContourMat = null; }
  chosenContourMat = outerContours[0].contour.clone();

  // prepare scaled grayMat for sampling according to procRes
  const procRes = Math.max(32, Math.min(1600, parseInt(document.getElementById('procRes').value || 360)));
  const scale = Math.min(procRes / procImageSize.w, procRes / procImageSize.h, 1);
  const gw = Math.max(16, Math.round(procImageSize.w * scale));
  const gh = Math.max(16, Math.round(procImageSize.h * scale));
  const tmp = document.createElement('canvas'); tmp.width = gw; tmp.height = gh;
  tmp.getContext('2d').drawImage(previewCanvas, 0, 0, gw, gh);

  if(grayMat){ try{ grayMat.delete(); } catch(e){} grayMat = null; }
  let rgbaSmall = cv.imread(tmp);
  let graySmall = new cv.Mat();
  cv.cvtColor(rgbaSmall, graySmall, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(graySmall, graySmall, new cv.Size(3,3), 0,0,cv.BORDER_DEFAULT);
  rgbaSmall.delete();
  grayMat = graySmall;

  // render previews
  renderHeatmapPreview();
  renderContourPreview();

  // cleanup
  try{ src.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete(); } catch(e){ console.warn('cleanup detect', e); }

  document.getElementById('summary').textContent = `Heatmap: ${grayMat.cols}×${grayMat.rows} — contours: ${outerContours.length}`;
  showToast('اكتملت المعالجة');
  // update 3D (sample)
  build3DPreview(false);
});

/* ======= render Heatmap preview & contour preview ======= */
function renderHeatmapPreview(){
  if(!grayMat) return;
  heatmapCanvas.width = procImageSize.w;
  heatmapCanvas.height = procImageSize.h;

  const gw = grayMat.cols, gh = grayMat.rows;
  const id = new ImageData(gw, gh);
  for(let i=0;i<gw*gh;i++){
    const v = grayMat.data[i];
    const idx = 255 - v;
    id.data[i*4+0] = JET_LUT[idx*3+0];
    id.data[i*4+1] = JET_LUT[idx*3+1];
    id.data[i*4+2] = JET_LUT[idx*3+2];
    id.data[i*4+3] = 220;
  }
  const tmp = document.createElement('canvas'); tmp.width = gw; tmp.height = gh;
  tmp.getContext('2d').putImageData(id, 0, 0);
  hctx.clearRect(0,0,heatmapCanvas.width, heatmapCanvas.height);
  hctx.drawImage(tmp, 0, 0, heatmapCanvas.width, heatmapCanvas.height);
}

function renderContourPreview(){
  if(!chosenContourMat) return;
  contourCanvas.width = procImageSize.w;
  contourCanvas.height = procImageSize.h;
  cctx.clearRect(0,0,contourCanvas.width, contourCanvas.height);
  // show base image faint
  cctx.globalAlpha = 0.6; cctx.drawImage(previewCanvas, 0, 0); cctx.globalAlpha = 1.0;
  // draw contour
  cctx.strokeStyle = '#ffdd66';
  cctx.lineWidth = 2;
  cctx.beginPath();
  const pts = chosenContourMat.data32S;
  if(pts && pts.length >= 6){
    for(let k=0;k<pts.length;k+=2){
      const x = pts[k], y = pts[k+1];
      if(k===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);
    }
    cctx.closePath(); cctx.stroke();
  }
}

/* ======= Quick test (low-res) ======= */
document.getElementById('btnQuickTest').addEventListener('click', ()=>{
  if(!originalImage) return showToast('حمّل صورة أولاً');
  const prev = document.getElementById('procRes').value;
  document.getElementById('procRes').value = '160';
  document.getElementById('btnDetect').click();
  setTimeout(()=>{ document.getElementById('procRes').value = prev; showToast('اختبار سريع انتهى'); }, 900);
});

/* ======= Sampling & conversions ======= */
function sampleGrayAtPreviewXY(px, py){
  if(!grayMat) return 128;
  const gw = grayMat.cols, gh = grayMat.rows;
  const gx = Math.max(0, Math.min(gw-1, Math.round((px / procImageSize.w) * (gw - 1))));
  const gy = Math.max(0, Math.min(gh-1, Math.round((py / procImageSize.h) * (gh - 1))));
  return grayMat.data[gy * gw + gx];
}

function pxToMmX(px){
  const realW = parseFloat(document.getElementById('realWidth').value || 200);
  return (px / procImageSize.w) * realW;
}
function pxToMmY(py){
  const realW = parseFloat(document.getElementById('realWidth').value || 200);
  const realH = realW * (procImageSize.h / procImageSize.w);
  return (py / procImageSize.h) * realH;
}

/* ======= Main generator using pointPolygonTest (stable) ======= */
function generateRasterGcodeInsideShape(){
  if(!grayMat || !chosenContourMat) { showToast('نفّذ كشف الحواف أولاً'); return ''; }

  const scanDir = document.getElementById('scanDir').value; // 'x' or 'y'
  const stepOverMm = parseFloat(document.getElementById('stepOver').value || 1.0);
  const maxDepth = parseFloat(document.getElementById('maxDepth').value || 3.0);
  const feed = parseFloat(document.getElementById('feedRate').value || 800);
  const safeZ = parseFloat(document.getElementById('safeZ').value || 5.0);
  const invertZ = document.getElementById('invertZ').value === 'yes';
  const realW = parseFloat(document.getElementById('realWidth').value || 200);
  const realH = realW * (procImageSize.h / procImageSize.w);

  // px/mm
  const pxPerMmX = procImageSize.w / realW;
  const pxPerMmY = procImageSize.h / realH;

  // compute px step for scanning lines
  const pxStep = Math.max(1, Math.round( (scanDir === 'x') ? (stepOverMm * pxPerMmY) : (stepOverMm * pxPerMmX) ));

  const lines = [];
  lines.push('; --- Raster Engraving inside contour ---');
  lines.push(`; Date: ${new Date().toLocaleString()}`);
  lines.push('; Units: mm, Absolute positioning');
  lines.push('G21');
  lines.push('G90');
  lines.push('G17');
  lines.push(`G0 Z${safeZ.toFixed(3)} ; Safe height`);
  lines.push('; M3 S<rpm> ; start spindle (uncomment & set rpm)');

  const sampleStepPx = 1; // sampling resolution along segments (1 px)
  let totalCutLen = 0;
  let prevPos = null;

  if(scanDir === 'x'){
    // horizontal scan lines
    let rowIndex = 0;
    for(let py = 0; py <= procImageSize.h - 1; py += pxStep, rowIndex++){
      // find contiguous inside runs at this py
      let runs = [];
      let inside = false, startX = 0;
      for(let px = 0; px < procImageSize.w; px += 1){
        const pt = new cv.Point(px, py);
        const res = cv.pointPolygonTest(chosenContourMat, pt, false);
        if(res >= 0){
          if(!inside){ inside = true; startX = px; }
        } else {
          if(inside){ inside = false; runs.push({sx: startX, ex: px - 1}); }
        }
      }
      if(inside) runs.push({sx: startX, ex: procImageSize.w - 1});
      if(runs.length === 0) continue;

      // order runs left->right or right->left for zigzag per row
      const forward = (rowIndex % 2 === 0); // even rows left->right
      if(!forward) runs.reverse();

      for(const run of runs){
        // sample points along run
        const pts = [];
        if(forward){
          for(let px = run.sx; px <= run.ex; px += sampleStepPx){
            const pv = sampleGrayAtPreviewXY(px, py);
            let z = - ((255 - pv) / 255.0) * maxDepth;
            if(invertZ) z = -z;
            pts.push({x_px: px, y_px: py, x_mm: pxToMmX(px), y_mm: pxToMmY(py), z: z});
          }
        } else {
          for(let px = run.ex; px >= run.sx; px -= sampleStepPx){
            const pv = sampleGrayAtPreviewXY(px, py);
            let z = - ((255 - pv) / 255.0) * maxDepth;
            if(invertZ) z = -z;
            pts.push({x_px: px, y_px: py, x_mm: pxToMmX(px), y_mm: pxToMmY(py), z: z});
          }
        }

        if(pts.length < 2) continue;

        // rapid move to start (safeZ)
        lines.push(`; row ${rowIndex} run X ${run.sx}..${run.ex}`);
        lines.push(`G0 X${pts[0].x_mm.toFixed(3)} Y${pts[0].y_mm.toFixed(3)} Z${safeZ.toFixed(3)}`);
        // plunge to first Z
        lines.push(`G1 Z${pts[0].z.toFixed(3)} F${feed}`);
        // cut along points
        for(let i=0;i<pts.length;i++){
          const p = pts[i];
          lines.push(`G1 X${p.x_mm.toFixed(3)} Y${p.y_mm.toFixed(3)} Z${p.z.toFixed(3)} F${feed}`);
          if(i>0){
            const prev = pts[i-1];
            totalCutLen += Math.hypot(p.x_mm - prev.x_mm, p.y_mm - prev.y_mm);
          }
        }
        // retract
        lines.push(`G0 Z${safeZ.toFixed(3)}`);
      }
    }
  } else {
    // vertical scan lines (x moves)
    let colIndex = 0;
    for(let px = 0; px <= procImageSize.w - 1; px += pxStep, colIndex++){
      let runs = [];
      let inside = false, startY = 0;
      for(let py = 0; py < procImageSize.h; py += 1){
        const pt = new cv.Point(px, py);
        const res = cv.pointPolygonTest(chosenContourMat, pt, false);
        if(res >= 0){
          if(!inside){ inside = true; startY = py; }
        } else {
          if(inside){ inside = false; runs.push({sy: startY, ey: py - 1}); }
        }
      }
      if(inside) runs.push({sy: startY, ey: procImageSize.h - 1});
      if(runs.length === 0) continue;

      const forward = (colIndex % 2 === 0);
      if(!forward) runs.reverse();

      for(const run of runs){
        const pts = [];
        if(forward){
          for(let py = run.sy; py <= run.ey; py += sampleStepPx){
            const pv = sampleGrayAtPreviewXY(px, py);
            let z = - ((255 - pv) / 255.0) * maxDepth;
            if(invertZ) z = -z;
            pts.push({x_px: px, y_px: py, x_mm: pxToMmX(px), y_mm: pxToMmY(py), z: z});
          }
        } else {
          for(let py = run.ey; py >= run.sy; py -= sampleStepPx){
            const pv = sampleGrayAtPreviewXY(px, py);
            let z = - ((255 - pv) / 255.0) * maxDepth;
            if(invertZ) z = -z;
            pts.push({x_px: px, y_px: py, x_mm: pxToMmX(px), y_mm: pxToMmY(py), z: z});
          }
        }

        if(pts.length < 2) continue;

        lines.push(`; col ${colIndex} run Y ${run.sy}..${run.ey}`);
        lines.push(`G0 X${pts[0].x_mm.toFixed(3)} Y${pts[0].y_mm.toFixed(3)} Z${safeZ.toFixed(3)}`);
        lines.push(`G1 Z${pts[0].z.toFixed(3)} F${feed}`);
        for(let i=0;i<pts.length;i++){
          const p = pts[i];
          lines.push(`G1 X${p.x_mm.toFixed(3)} Y${p.y_mm.toFixed(3)} Z${p.z.toFixed(3)} F${feed}`);
          if(i>0){
            const prev = pts[i-1];
            totalCutLen += Math.hypot(p.x_mm - prev.x_mm, p.y_mm - prev.y_mm);
          }
        }
        lines.push(`G0 Z${safeZ.toFixed(3)}`);
      }
    }
  }

  // time estimate
  const cutTimeMin = totalCutLen / (parseFloat(document.getElementById('feedRate').value) || 1) ;
  const rapidEstimateMin = 0.1 * cutTimeMin; // rough estimate for rapids (conservative)
  const totalMin = cutTimeMin + rapidEstimateMin;
  document.getElementById('timeEst').textContent = `تقدير الوقت (دقائق): قطع ≈ ${cutTimeMin.toFixed(2)}, إجمالي ≈ ${totalMin.toFixed(2)}`;

  lines.push('');
  lines.push('M5 ; stop spindle');
  lines.push('G0 X0 Y0 ; return home');
  lines.push('M30 ; end');

  // prepare cut segments for 3D overlay (simple: extract lines from the generated code)
  // We'll store simplified segments: sequence of arrays of {x,y,z}
  window._lastCutSegments = extractSegmentsFromGcodeLines(lines);

  document.getElementById('summary').textContent = `Cut length ≈ ${totalCutLen.toFixed(1)} mm — segments ≈ ${window._lastCutSegments.length}`;

  return lines.join('\n');
}

/* ======= helper to extract segments from lines (for visualization) ======= */
function extractSegmentsFromGcodeLines(lines){
  const segments = [];
  const pts = [];
  const tokens = lines.join('\n').split('\n');
  for(const L of tokens){
    const s = L.trim();
    if(!s) continue;
    if(s.startsWith('G1') || s.startsWith('G0') || s.startsWith('g1') || s.startsWith('g0')){
      // parse X Y Z if present
      const mX = s.match(/X(-?\d+(\.\d+)?)/i);
      const mY = s.match(/Y(-?\d+(\.\d+)?)/i);
      const mZ = s.match(/Z(-?\d+(\.\d+)?)/i);
      if(mX && mY && mZ){
        const x = parseFloat(mX[1]), y = parseFloat(mY[1]), z = parseFloat(mZ[1]);
        pts.push({x,y,z});
      } else {
        // when a rapid to safeZ occurs, we can treat as segment breaker
        if(pts.length>1){ segments.push(pts.slice()); pts.length=0; }
      }
    } else {
      // comments or others -> break segments
      if(pts.length>1){ segments.push(pts.slice()); pts.length=0; }
    }
  }
  if(pts.length>1) segments.push(pts.slice());
  return segments;
}

/* ======= Buttons ======= */
document.getElementById('btnGen').addEventListener('click', ()=>{
  if(!grayMat || !chosenContourMat) return showToast('نفّذ كشف الحواف أولاً');
  const g = generateRasterGcodeInsideShape();
  if(!g) return showToast('فشل في التوليد');
  document.getElementById('gcodeOut').value = g;
  showToast('تم توليد G-code');
  // show 3D tab for quick inspection
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelector('.tab[data-tab="3d"]').classList.add('active');
  document.getElementById('view-original').style.display='none';
  document.getElementById('view-heatmap').style.display='none';
  document.getElementById('view-contour').style.display='none';
  document.getElementById('view-3d').style.display='block';
  setTimeout(()=> build3DPreview(false), 60);
});

document.getElementById('btnDownload').addEventListener('click', ()=>{
  const gcode = document.getElementById('gcodeOut').value;
  if(!gcode) return showToast('لا يوجد G-code للتحميل');
  const blob = new Blob([gcode], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'raster_inside_shape.ngc';
  document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
  showToast('تم تنزيل ملف G-code');
});

document.getElementById('btnHeat').addEventListener('click', ()=>{
  if(!grayMat) return showToast('لم يتم تهيئة Heatmap');
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.querySelector('.tab[data-tab="heatmap"]').classList.add('active');
  document.getElementById('view-original').style.display='none';
  document.getElementById('view-heatmap').style.display='block';
  document.getElementById('view-contour').style.display='none';
  document.getElementById('view-3d').style.display='none';
});

/* ======= 3D Preview (fixed) ======= */
let threeRenderer, threeScene, threeCamera, threeControls, heightMesh, segmentsGroup;
function initThree(container){
  while(container.firstChild) container.removeChild(container.firstChild);
  threeRenderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  threeRenderer.setPixelRatio(window.devicePixelRatio);
  threeRenderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(threeRenderer.domElement);
  threeScene = new THREE.Scene();
  threeCamera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 2000);
  threeCamera.position.set(0, -300, 300);
  threeControls = new THREE.OrbitControls(threeCamera, threeRenderer.domElement);
  threeScene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.8));
  const dl = new THREE.DirectionalLight(0xffffff, 0.9); dl.position.set(1,2,3); threeScene.add(dl);
  threeScene.add(new THREE.AmbientLight(0x404040, 0.6));
  (function animate(){ if(threeRenderer) threeRenderer.render(threeScene, threeCamera); requestAnimationFrame(animate); })();
}

function build3DPreview(showAll=false){
  if(!grayMat) return;
  const container = document.getElementById('threeContainer');
  initThree(container);

  // cleanup
  if(heightMesh){ try{ threeScene.remove(heightMesh); heightMesh.geometry.dispose(); heightMesh.material.dispose(); } catch(e){} heightMesh=null; }
  if(segmentsGroup){ try{ threeScene.remove(segmentsGroup); } catch(e){} segmentsGroup=null; }

  const gw = grayMat.cols, gh = grayMat.rows;
  const realW = parseFloat(document.getElementById('realWidth').value || 200);
  const realH = realW * (procImageSize.h / procImageSize.w);
  const maxDepth = parseFloat(document.getElementById('maxDepth').value || 3);

  // geometry resolution reduction for performance
  const segX = Math.min(160, Math.max(8, gw - 1));
  const segY = Math.min(160, Math.max(8, gh - 1));
  const geometry = new THREE.PlaneGeometry(realW, realH, segX, segY);
  geometry.rotateX(-Math.PI/2); // make Z up
  const pos = geometry.attributes.position;

  for(let j=0;j<=segY;j++){
    for(let i=0;i<=segX;i++){
      const idx = j*(segX+1) + i;
      const gx = Math.round((i / segX) * (gw - 1));
      const gy = Math.round((j / segY) * (gh - 1));
      const pv = grayMat.data[gy * gw + gx];
      const meshZ = ((255 - pv) / 255.0) * maxDepth;
      pos.setZ(idx, meshZ);
    }
  }
  pos.needsUpdate = true;
  geometry.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({color:0xddeeff, metalness:0.05, roughness:0.7, side:THREE.DoubleSide});
  heightMesh = new THREE.Mesh(geometry, mat);
  threeScene.add(heightMesh);

  // contour overlay (in mm, centered)
  if(chosenContourMat){
    const pts = chosenContourMat.data32S;
    const verts = [];
    for(let k=0;k<pts.length;k+=2){
      const px = pts[k], py = pts[k+1];
      const wx = pxToMmX(px) - realW/2;
      const wy = pxToMmY(py) - realH/2;
      verts.push(new THREE.Vector3(wx, 0.5, wy));
    }
    if(verts.length>1){
      const g = new THREE.BufferGeometry().setFromPoints(verts);
      const line = new THREE.Line(g, new THREE.LineBasicMaterial({color:0xffaa00}));
      threeScene.add(line);
    }
  }

  // draw cut segments overlay
  const segs = window._lastCutSegments || [];
  segmentsGroup = new THREE.Group();
  const cutMat = new THREE.LineBasicMaterial({color:0xff4444});
  const maxShow = showAll ? segs.length : Math.min(120, segs.length);
  for(let i=0;i<maxShow;i++){
    const s = segs[i];
    if(!s || s.length<2) continue;
    const pts = [];
    for(const p of s){
      const wx = p.x - realW/2;
      const wy = p.y - realH/2;
      const wz = Math.abs(p.z) + 0.5;
      pts.push(new THREE.Vector3(wx, wz, wy));
    }
    const g = new THREE.BufferGeometry().setFromPoints(pts);
    const line = new THREE.Line(g, cutMat);
    segmentsGroup.add(line);
  }
  threeScene.add(segmentsGroup);

  // center camera
  const box = new THREE.Box3().setFromObject(heightMesh);
  if(segmentsGroup) box.union(new THREE.Box3().setFromObject(segmentsGroup));
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  threeControls.target.copy(center);
  const diag = Math.max(size.x, size.y, size.z);
  const dist = diag * 1.8 + 80;
  threeCamera.position.set(center.x, center.y + dist, center.z + dist/3);
  threeCamera.lookAt(center);
  threeControls.update();
}

/* ======= cleanup on unload ======= */
window.addEventListener('beforeunload', ()=>{
  if(grayMat){ try{ grayMat.delete(); } catch(e){} grayMat=null; }
  if(chosenContourMat){ try{ chosenContourMat.delete(); } catch(e){} chosenContourMat=null; }
  if(outerContours){ outerContours.forEach(o=>{ try{o.contour.delete(); } catch(e){} }); outerContours=[]; }
});
</script>
</body>
</html>
