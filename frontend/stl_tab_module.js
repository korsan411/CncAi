/* stl_tab_module.js
   STL → G-code Tab Module (version for integration with CncAi)
   - Assumes Three.js is already loaded in the host page.
   - Adds a "STL to G-code" tab (requires a matching tab button with id "tabSTL"
     or the host can include a button to trigger showing the tab-section).
   - Provides: file input, preview in existing Three.js scene, raster sampling
     generator for approximate G-code, and download button.
   - Safe to include: uses idempotent initialization and avoids touching other DOM ids.
*/

(function(){
  // Prevent double-init if script is included twice
  if (window.stlTabModuleInitialized) return;
  window.stlTabModuleInitialized = true;

  // Helper to get element by id
  function $id(id){ return document.getElementById(id); }

  // Ensure STLLoader is available (but do NOT load Three.js itself here)
  function ensureSTLLoader(cb){
    try{
      if (window.STLLoader || (window.THREE && THREE.STLLoader)) { cb(); return; }
    }catch(e){}
    // If developer wants to lazy-load STLLoader, they can uncomment and host it.
    console.warn("STLLoader is not present. Please include THREE.STLLoader in the page for full functionality.");
    cb();
  }

  // Module state
  var currentMesh = null;

  // Dispose and remove previous mesh safely
  function clearCurrentMesh(){
    try{
      if (!currentMesh) return;
      if (currentMesh.geometry && typeof currentMesh.geometry.dispose === 'function') {
        currentMesh.geometry.dispose();
      }
      if (currentMesh.material && typeof currentMesh.material.dispose === 'function') {
        currentMesh.material.dispose();
      }
      if (currentMesh.parent && typeof currentMesh.parent.remove === 'function') {
        currentMesh.parent.remove(currentMesh);
      }
      currentMesh = null;
    }catch(e){ console.warn("clearCurrentMesh:", e); }
  }

  // Load STL from ArrayBuffer (using THREE.STLLoader.parse)
  function loadSTLFromBuffer(buffer){
    ensureSTLLoader(function(){
      try{
        var Loader = window.STLLoader || THREE.STLLoader;
        if (!Loader) { console.warn("STLLoader not found."); return; }
        var loader = new Loader();
        var geom = loader.parse(buffer);
        if (geom.computeVertexNormals) geom.computeVertexNormals();

        clearCurrentMesh();

        var mat = new THREE.MeshStandardMaterial({ color:0x999999, metalness:0.1, roughness:0.8 });
        var mesh = new THREE.Mesh(geom, mat);
        mesh.name = "stl_tab_mesh";

        // Try to add to an existing Three.js scene used by the host app.
        // Common global names used by many apps: scene, threeDScene, _scene
        var scene = window.threeDScene || window._scene || window.scene;
        if (scene && typeof scene.add === 'function') {
          scene.add(mesh);
          currentMesh = mesh;

          // center mesh at origin for nicer camera framing
          try{
            var box = new THREE.Box3().setFromObject(mesh);
            var center = new THREE.Vector3();
            box.getCenter(center);
            mesh.position.sub(center);
          }catch(e){ /* non-fatal */ }
        } else {
          // No scene found — keep the mesh in memory for sampling if needed
          currentMesh = mesh;
          console.warn("No Three.js scene found on window (scene / threeDScene). Mesh kept in memory; preview won't be visible.");
        }
      }catch(err){
        console.error("Failed to parse STL:", err);
      }
    });
  }

  // Raycast-sample mesh height at given (x,y) in mesh local coords.
  // Returns Z or null if nothing intersected.
  function sampleHeightAtMesh(x, y){
    try{
      if (!currentMesh) return null;
      var raycaster = new THREE.Raycaster();
      var origin = new THREE.Vector3(x, y, 1e4); // start far above
      var dir = new THREE.Vector3(0,0,-1);
      raycaster.set(origin, dir);
      var intersects = raycaster.intersectObject(currentMesh, true);
      if (intersects && intersects.length > 0) {
        return intersects[0].point.z;
      }
    }catch(e){
      // silent
    }
    return null;
  }

  // Generate approximate G-code by sampling the mesh across a raster grid.
  // res: samples per axis (integer). workXmm/workYmm: target physical size in mm.
  // Returns G-code string.
  function generateGcodeFromMesh(res, workXmm, workYmm){
    if (!currentMesh) { alert("No STL loaded."); return ""; }

    // compute bounding box in mesh coordinates
    var box = new THREE.Box3().setFromObject(currentMesh);
    var min = box.min, max = box.max;

    var rows = Math.max(2, Math.floor(res));
    var cols = rows;

    var lines = [];
    lines.push("; Generated by CncAi STL tab (approximate sampling)");
    lines.push("G21 ; mm");
    lines.push("G90 ; absolute");

    var spanX = (max.x - min.x) || 1;
    var spanY = (max.y - min.y) || 1;
    var stepX = spanX / Math.max(1, cols - 1);
    var stepY = spanY / Math.max(1, rows - 1);

    var scaleX = workXmm / spanX;
    var scaleY = workYmm / spanY;

    // zig-zag raster (rows)
    for (var r = 0; r < rows; r++){
      var y = min.y + r * stepY;
      if (r % 2 === 0){
        for (var c = 0; c < cols; c++){
          var x = min.x + c * stepX;
          var z = sampleHeightAtMesh(x, y);
          if (z === null) z = min.z || 0;
          var gx = ((x - min.x) * scaleX).toFixed(3);
          var gy = ((y - min.y) * scaleY).toFixed(3);
          var gz = (-z).toFixed(3); // may need inversion depending on machine
          lines.push("G1 X" + gx + " Y" + gy + " Z" + gz + " F1000");
        }
      } else {
        for (var c = cols - 1; c >= 0; c--){
          var x = min.x + c * stepX;
          var z = sampleHeightAtMesh(x, y);
          if (z === null) z = min.z || 0;
          var gx = ((x - min.x) * scaleX).toFixed(3);
          var gy = ((y - min.y) * scaleY).toFixed(3);
          var gz = (-z).toFixed(3);
          lines.push("G1 X" + gx + " Y" + gy + " Z" + gz + " F1000");
        }
      }
    }

    lines.push("M5");
    return lines.join("\n");
  }

  // UI wiring — idempotent attach
  function wireUI(){
    var tabBtn = $id("tabSTL");
    var tabSec = $id("stlTab");
    var fileIn = $id("stlFileInput");
    var resIn = $id("stlResolution");
    var wxIn = $id("stlWorkX");
    var wyIn = $id("stlWorkY");
    var prevBtn = $id("stlPreviewBtn");
    var genBtn = $id("stlGenerateBtn");
    var dlBtn = $id("stlDownloadBtn");
    var out = $id("stlGcodeOutput");

    if (tabBtn && tabSec){
      tabBtn.addEventListener("click", function(){
        // hide other tab sections (assumes .tab-section used across the app)
        var secs = document.querySelectorAll(".tab-section");
        for (var i = 0; i < secs.length; i++) secs[i].style.display = "none";
        tabSec.style.display = "block";
      });
    }

    if (fileIn){
      fileIn.addEventListener("change", function(e){
        var f = e.target.files[0];
        if (!f) return;
        var r = new FileReader();
        r.onload = function(ev){ loadSTLFromBuffer(ev.target.result); alert("STL loaded. Click Preview STL to add to scene."); };
        r.readAsArrayBuffer(f);
      });
    }

    if (prevBtn){
      prevBtn.addEventListener("click", function(){
        if (!currentMesh){ alert("No STL loaded"); return; }
        var scene = window.threeDScene || window._scene || window.scene;
        if (scene && currentMesh.parent !== scene){ scene.add(currentMesh); }
        // optional: focus camera if host exposes a fit function (not assumed)
        // hide tab after preview or keep open per preference
      });
    }

    if (genBtn){
      genBtn.addEventListener("click", function(){
        var res = parseInt(resIn.value) || 64;
        var wx = parseFloat(wxIn.value) || 100;
        var wy = parseFloat(wyIn.value) || 100;
        var g = generateGcodeFromMesh(res, wx, wy);
        if (out) out.value = g;
      });
    }

    if (dlBtn){
      dlBtn.addEventListener("click", function(){
        if (!out || !out.value) { alert("No G-code to download"); return; }
        var blob = new Blob([out.value], { type: "text/plain" });
        var a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "stl_output.gcode";
        a.click();
      });
    }
  }

  // initialize after DOM ready
  if (document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", wireUI);
  } else {
    wireUI();
  }

  // expose a small API to interact programmatically if needed
  window.stlTab = {
    loadFromArrayBuffer: loadSTLFromBuffer,
    clear: clearCurrentMesh,
    generateGcode: generateGcodeFromMesh
  };

})(); // end module
