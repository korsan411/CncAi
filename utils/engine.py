"""
utils/engine.py
MVP implementations for:
- img_to_contours(path) -> list of contours (each contour is Nx2 list)
- make_toolpaths_from_contours(contours) -> list of toolpaths (list of points)
- toolpaths_to_gcode(toolpaths) -> string with simple G-code
- heightmap_to_stl(heightmap) -> saves an STL in temp dir and returns path
"""
import numpy as np
import cv2
from shapely.geometry import Polygon, LinearRing
import tempfile
import os
from stl import mesh
from pathlib import Path

def img_to_contours(path):
    """
    Read image, convert to grayscale, threshold, find contours.
    Returns list of contours (each contour is an Nx2 numpy array).
    """
    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError("Cannot read image for contours.")
    # adaptively threshold to get binary
    th = cv2.adaptiveThreshold(img,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY_INV,11,2)
    # find contours
    contours, hierarchy = cv2.findContours(th, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    result = [cnt.reshape(-1,2) for cnt in contours]
    return result

def make_toolpaths_from_contours(contours, offset_step=1.0):
    """
    Basic toolpath generator: for each contour, return it as a path.
    For a real application, you would offset/peel/zigzag; this is a simple pass-through.
    """
    toolpaths = []
    for cnt in contours:
        # convert to list of tuples
        pts = [(float(p[0]), float(p[1])) for p in cnt]
        if len(pts) >= 2:
            toolpaths.append(pts)
    return toolpaths

def toolpaths_to_gcode(toolpaths, feedrate=1000, plunge_rate=300, safe_z=5.0, cut_z=-1.0):
    """
    Simple G-code generator:
    - Rapid to first point (G0), plunge to cut_z (G1 Z), follow path (G1 X Y), retract.
    Returns string.
    """
    lines = []
    lines.append("; Generated by cncai - simple toolpath exporter")
    lines.append("G21 ; mm units")
    lines.append("G90 ; absolute")
    lines.append("G0 Z{:.3f}".format(safe_z))
    for path in toolpaths:
        if not path:
            continue
        x0,y0 = path[0]
        lines.append("G0 X{:.4f} Y{:.4f}".format(x0, y0))
        lines.append("G1 Z{:.4f} F{}".format(cut_z, plunge_rate))
        for (x,y) in path[1:]:
            lines.append("G1 X{:.4f} Y{:.4f} F{}".format(x, y, feedrate))
        lines.append("G0 Z{:.4f}".format(safe_z))
    return "\n".join(lines)

def heightmap_to_stl(heightmap, scale_xy=1.0, scale_z=0.1):
    """
    Convert a 2D numpy array heightmap into a very simple STL by creating a grid of quads => triangles.
    Saves STL to a temp file and returns path.
    """
    import numpy as np
    h, w = heightmap.shape
    verts = []
    faces = []
    # create vertices
    for i in range(h):
        for j in range(w):
            x = j * scale_xy
            y = i * scale_xy
            z = float(heightmap[i,j]) * scale_z
            verts.append((x,y,z))
    def vid(i,j):
        return i*w + j
    # create faces (two triangles per quad)
    for i in range(h-1):
        for j in range(w-1):
            a = vid(i,j)
            b = vid(i,j+1)
            c = vid(i+1,j+1)
            d = vid(i+1,j)
            faces.append((a,b,c))
            faces.append((a,c,d))
    # make numpy arrays
    vertices = np.array(verts)
    faces_np = np.array(faces)
    # build mesh using numpy-stl
    data = np.zeros(len(faces_np), dtype=mesh.Mesh.dtype)
    new_mesh = mesh.Mesh(data, remove_empty_areas=False)
    for i, f in enumerate(faces_np):
        for j in range(3):
            new_mesh.vectors[i][j] = vertices[f[j],:]
    tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".stl")
    new_mesh.save(tmp.name)
    tmp.close()
    return tmp.name
