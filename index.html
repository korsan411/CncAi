<!doctype html>

<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>CNC AI â€” CNC Router & Laser Engraving (Ù…ØµØ­Ø­)</title>  <!-- Ù…ÙƒØªØ¨Ø§Øª -->  <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: Arial, Segoe UI, system-ui; background: #041022; color:#e6eef6; line-height:1.45 }
    .app { max-width:1400px; margin:12px auto; padding:14px }
    header { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid #1e293b }
    .grid { display:grid; grid-template-columns:1fr 520px; gap:16px }
    @media (max-width:1100px){ .grid{ grid-template-columns:1fr } }
    .panel { background:#0b1320; padding:16px; border-radius:10px; border:1px solid #1e293b }
    .tab-buttons { display:flex; gap:8px; margin-top:12px; background: rgba(14,23,33,0.6); padding:6px; border-radius:8px }
    .tab-buttons button { flex:1; border:none; padding:8px 10px; border-radius:6px; background:transparent; color:#9bb0c8; cursor:pointer }
    .tab-buttons button.active { background:#0f172a; color:#e6eef6; box-shadow: inset 0 -3px 0 #06b6d4; }
    .tab-content { display:none; margin-top:12px }
    .tab-content.active { display:block }
    canvas { max-width:100%; border-radius:6px; background:#000; display:block; margin:0 auto; border:1px solid #334155 }
    #threeContainer { width:100%; height:420px; background:#081224; border-radius:8px; overflow:hidden; position:relative }
    label { display:block; margin-top:12px; color:#cfeaf2; font-weight:bold }
    input, select, textarea, button { font-size:0.9rem }
    input, select { width:100%; padding:8px 10px; border-radius:6px; border:1px solid #1e293b; background:#0f172a; color:#e6eef6; margin-top:6px }
    .button-group { display:flex; flex-direction:column; gap:8px; margin-top:12px }
    .button-row { display:flex; gap:8px; }
    button { background:#1e293b; color:#e6eef6; border:none; padding:10px; border-radius:8px; cursor:pointer }
    button.primary { background:#06b6d4; color:#021; font-weight:bold }
    button.secondary { background:#334155; }
    #toast { position:fixed; left:16px; bottom:16px; background:rgba(2,6,23,0.9); padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.04); display:none }
    .canvas-placeholder { padding:40px 12px; text-align:center; color:#7aa7b8; }
    .laser-preview { border: 2px solid #ff4444; background: rgba(255, 68, 68, 0.03); padding: 8px; border-radius: 6px; margin-top: 8px; }
    .power-indicator { height: 4px; background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000); border-radius: 2px; margin-top: 4px; }
  </style></head>
<body>
  <div class="app">
    <header>
      <h1>CNC AI â€” CNC Router & Laser Engraving (Ù…ØµØ­Ø­)</h1>
      <div id="cvState" class="loading-indicator">
        <div class="loading-spinner"></div>
        <span id="cvStateText">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ OpenCV...</span>
      </div>
    </header><div class="grid">
  <!-- LEFT panel -->
  <div class="panel">
    <div style="display:flex;gap:8px;align-items:center;">
      <input id="fileInput" type="file" accept="image/*"/>
      <label class="file-input-label" for="fileInput" style="display:inline-block;padding:8px 12px;background:#1e293b;border-radius:6px;color:#e6eef6;cursor:pointer;border:1px dashed #334155">ğŸ“ Ø§Ø®ØªØ± ØµÙˆØ±Ø©</label>
      <div style="flex:1"></div>

      <label for="edgeMode" style="font-weight:normal;color:#9bb0c8">Edge Mode:</label>
      <select id="edgeMode" style="width:140px">
        <option value="auto">Canny (Ø¹Ø§Ø¯ÙŠ)</option>
        <option value="sobel">Sobel (Ø¯Ù‚ÙŠÙ‚)</option>
        <option value="laplace">Laplacian (Ù†Ø§Ø¹Ù€Ù…)</option>
      </select>
    </div>

    <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
      <label style="margin:0;color:#9bb0c8">Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ø­ÙˆØ§Ù:</label>
      <input id="edgeSensitivity" type="range" min="0.1" max="1.0" step="0.05" value="0.33" style="flex:1">
      <div id="edgeValue" style="min-width:44px;text-align:center;color:#cfeaf2">0.33</div>
    </div>

    <div class="tab-buttons" role="tablist">
      <button data-tab="original" class="active">ğŸ–¼ï¸ Ø§Ù„Ø£ØµÙ„ÙŠØ©</button>
      <button data-tab="heatmap">ğŸ”¥ Heatmap</button>
      <button data-tab="contour">ğŸ“ Contours</button>
      <button data-tab="topview">ğŸ” Top View</button>
      <button data-tab="simulation">ğŸ¬ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©</button>
      <button data-tab="laserpreview" id="laserPreviewTab" style="display:none">ğŸ”´ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù„ÙŠØ²Ø±</button>
    </div>

    <div id="original" class="tab-content active">
      <div class="canvas-placeholder" id="originalPlaceholder">Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
      <canvas id="canvasOriginal" width="800" height="600" style="display:block;"></canvas>
    </div>

    <div id="heatmap" class="tab-content">
      <div class="canvas-placeholder" id="heatmapPlaceholder">Heatmap Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
      <canvas id="canvasHeatmap" style="display:none;"></canvas>
    </div>

    <div id="contour" class="tab-content">
      <div class="canvas-placeholder" id="contourPlaceholder">Contours Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
      <canvas id="canvasContour" style="display:none;"></canvas>
    </div>

    <div id="topview" class="tab-content">
      <div id="topViewContainer">
        <canvas id="topView"></canvas>
        <div id="topLegend" title="Ø¹Ù…Ù‚ Ø§Ù„Ù†Ù‚Ø´ â€” Ø§Ù„Ø£Ù„ÙˆØ§Ù† ÙÙ‚Ø·"></div>
      </div>
    </div>

    <div id="simulation" class="tab-content">
      <div id="threeContainer">
        <div class="canvas-placeholder" id="simulationPlaceholder">Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªÙˆÙ„ÙŠØ¯ G-code</div>
      </div>
    </div>

    <div id="laserpreview" class="tab-content">
      <div class="laser-preview">
        <div class="canvas-placeholder" id="laserPreviewPlaceholder">Ù…Ø¹Ø§ÙŠÙ†Ø© Ù†Ù‚Ø´ Ø§Ù„Ù„ÙŠØ²Ø± Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
        <canvas id="canvasLaserPreview" style="display:none;"></canvas>
        <div class="small-meta">Ù…Ø¹Ø§ÙŠÙ†Ø© ØªØ£Ø«ÙŠØ± Ø§Ù„Ù„ÙŠØ²Ø± Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø§Ø¯Ø© - Ø§Ù„Ø£Ø­Ù…Ø± = Ù‚ÙˆØ© Ø¹Ø§Ù„ÙŠØ©ØŒ Ø§Ù„Ø£ØµÙØ± = Ù‚ÙˆØ© Ù…ØªÙˆØ³Ø·Ø©ØŒ Ø§Ù„Ø£Ø®Ø¶Ø± = Ù‚ÙˆØ© Ù…Ù†Ø®ÙØ¶Ø©</div>
        <div class="power-indicator"></div>
      </div>
    </div>

  </div>

  <!-- RIGHT panel -->
  <div class="panel">
    <h3>âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</h3>

    <label for="machineCategory">Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ</label>
    <select id="machineCategory">
      <option value="router">CNC Router (Ù†Ø­Øª Ø®Ø´Ø¨)</option>
      <option value="laser">Laser Engraver (Ù†Ù‚Ø´ Ù„ÙŠØ²Ø±)</option>
    </select>

    <div id="routerSettings" class="machine-settings">
      <h4 class="router-specific">ğŸ”„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª CNC Router</h4>
      <label for="workWidth">Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
      <input id="workWidth" type="number" value="300" step="1" min="10" max="2000"/>
      <label for="workHeight">Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
      <input id="workHeight" type="number" value="200" step="1" min="10" max="2000"/>
    </div>

    <hr style="border-color:#122433;margin:12px 0"/>

    <div class="laser-edge-settings">
      <label for="laserEdgeMode">Ù†Ù…Ø· ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ù„Ù„Ù„ÙŠØ²Ø±</label>
      <select id="laserEdgeMode">
        <option value="adaptive">Adaptive Threshold</option>
        <option value="morphological">Morphological</option>
        <option value="gradient">Gradient-Based</option>
        <option value="canny">Canny</option>
      </select>

      <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
        <label style="margin:0;color:#9bb0c8">Ø¯Ù‚Ø© Ø§Ù„Ù„ÙŠØ²Ø±:</label>
        <input id="laserDetail" type="range" min="1" max="10" value="5" step="1" style="flex:1">
        <div id="laserDetailValue" style="min-width:44px;text-align:center;color:#ff4444">5</div>
      </div>

      <div style="margin-top: 8px;">
        <button id="btnRedetectLaser" class="secondary">ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ÙƒØ´Ù Ø­ÙˆØ§Ù Ø§Ù„Ù„ÙŠØ²Ø±</button>
      </div>

      <hr style="border-color:#ff4444;margin:12px 0"/>

      <div style="display:flex;align-items:center;gap:8px;margin-top:12px">
        <label style="margin:0;color:#9bb0c8">Ù‚ÙˆØ© Ø§Ù„Ù„ÙŠØ²Ø±:</label>
        <input id="laserPower" type="range" min="0" max="100" value="80" step="1" style="flex:1">
        <div id="laserPowerValue" style="min-width:44px;text-align:center;color:#ff4444">80%</div>
      </div>

      <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
        <label style="margin:0;color:#9bb0c8">Ø³Ø±Ø¹Ø© Ø§Ù„Ù„ÙŠØ²Ø± (Ù…Ù…/Ø¯Ù‚ÙŠÙ‚Ø©):</label>
        <input id="laserSpeed" type="range" min="100" max="5000" value="2000" step="100" style="flex:1">
        <div id="laserSpeedValue" style="min-width:60px;text-align:center;color:#06b6d4">2000</div>
      </div>

      <label for="laserMode">ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠØ²Ø±</label>
      <select id="laserMode">
        <option value="grayscale">Ù†Ù‚Ø´ ØªØ¯Ø±Ø¬ Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠ</option>
        <option value="dithering">Ù†Ù‚Ø´ Ù…ØªÙ‚Ø·Ø¹ (Dithering)</option>
        <option value="contour">Ù‚Øµ ÙƒÙˆÙ†ØªÙˆØ±</option>
        <option value="combined">Ù†Ù‚Ø´ + Ù‚Øµ</option>
      </select>

      <div style="display:flex;gap:8px;margin-top:8px">
        <label><input id="laserDynamic" type="checkbox"/> Ù‚ÙˆØ© Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© (ØªØ¯Ø±Ø¬)</label>
        <label><input id="laserOptimize" type="checkbox"/> ØªØ­Ø³ÙŠÙ† Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª</label>
        <label><input id="laserAirAssist" type="checkbox"/> Air Assist</label>
      </div>

      <label for="laserPasses">Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø±ÙˆØ± (passes)</label>
      <input id="laserPasses" type="number" min="1" max="10" value="1" />

      <label for="laserWorkWidth">Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
      <input id="laserWorkWidth" type="number" value="300" step="1" />
      <label for="laserWorkHeight">Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
      <input id="laserWorkHeight" type="number" value="200" step="1" />

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
        <div>
          <label for="laserOriginX">Origin X (Ù…Ù…)</label>
          <input id="laserOriginX" type="number" value="0" />
        </div>
        <div>
          <label for="laserOriginY">Origin Y (Ù…Ù…)</label>
          <input id="laserOriginY" type="number" value="0" />
        </div>
      </div>

      <div style="margin-top:12px" class="button-row">
        <button id="btnGenerateLaser" class="primary">ğŸ› ï¸ ØªÙˆÙ„ÙŠØ¯ G-code Ø§Ù„Ù„ÙŠØ²Ø±</button>
        <button id="btnDownloadGcode" class="secondary">â¬‡ï¸ ØªØ­Ù…ÙŠÙ„ G-code</button>
      </div>

    </div>

  </div>
</div>

<div id="toast"></div>

  </div>  <script>
    // =============== Globals ===============
    let cvReady = false;
    let previewCanvas = document.getElementById('canvasOriginal');
    let grayMat = null;                // OpenCV gray matrix used for heatmap & sampling
    let contour = null;               // main detected contour (cv.Mat)
    let lastGeneratedGcode = "";

    function onOpenCvReady() {
      cv['onRuntimeInitialized']=()=>{
        cvReady = true;
        document.getElementById('cvStateText').textContent = 'OpenCV Ø¬Ø§Ù‡Ø²';
        setTimeout(()=>{ document.getElementById('cvState').style.display='none' }, 800);
      }
    }

    function showToast(msg, timeout=3000) {
      const t = document.getElementById('toast');
      t.textContent = msg;
      t.style.display = 'block';
      clearTimeout(t._hid);
      t._hid = setTimeout(()=>{ t.style.display='none' }, timeout);
    }

    function safeMatDelete(m) { try{ if(m && typeof m.delete === 'function'){ m.delete(); } }catch(e){} }

    // ======== image loader ========
    document.getElementById('fileInput').addEventListener('change', (e)=>{
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const img = new Image();
      img.onload = () => {
        const ctx = previewCanvas.getContext('2d');
        // fit image to canvas while preserving aspect
        const maxW = 1200, maxH = 900;
        let w = img.width, h = img.height;
        if (w > maxW) { const r = maxW / w; w = maxW; h = Math.round(h * r); }
        if (h > maxH) { const r = maxH / h; h = maxH; w = Math.round(w * r); }
        previewCanvas.width = w; previewCanvas.height = h;
        ctx.clearRect(0,0,w,h);
        ctx.drawImage(img,0,0,w,h);
        document.getElementById('laserPreviewTab').style.display = 'inline-block';

        // cleanup previous mats
        safeMatDelete(grayMat);
        contour && safeMatDelete(contour);
        contour = null;

        // lazy detect after load
        if (cvReady) setTimeout(()=> detectLaserContours(), 50);
      }
      img.src = URL.createObjectURL(f);
    });

    // ======= Utility: sample gray at pixel with bounds check ======
    function sampleGrayAt(x, y) {
      if (!grayMat) return 0;
      const xi = Math.min(grayMat.cols - 1, Math.max(0, Math.round(x)));
      const yi = Math.min(grayMat.rows - 1, Math.max(0, Math.round(y)));
      return grayMat.ucharPtr(yi, xi)[0];
    }

    // ======= Laser contour detection (clean, memory-safe) =======
    async function detectLaserContours() {
      if (!cvReady) { showToast('OpenCV ØºÙŠØ± Ø¬Ø§Ù‡Ø²'); return; }
      if (!previewCanvas || previewCanvas.width === 0) { showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© ØµØ§Ù„Ø­Ø©'); return; }

      showToast('Ø¬Ø§Ø±ÙŠ ÙƒØ´Ù Ø­ÙˆØ§Ù Ø§Ù„Ù„ÙŠØ²Ø±...');

      let src = null, gray = null, edges = null, hierarchy = null, contours = null;
      try {
        src = cv.imread(previewCanvas);
        if (src.empty()) { showToast('Ø§Ù„ØµÙˆØ±Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©'); src.delete(); return; }

        gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        const mode = document.getElementById('laserEdgeMode').value || 'adaptive';
        const detailLevel = parseInt(document.getElementById('laserDetail').value) || 5;

        edges = new cv.Mat();

        if (mode === 'adaptive') {
          const adaptive = new cv.Mat();
          const blockSize = Math.max(3, 2 * Math.floor(detailLevel) + 1);
          cv.adaptiveThreshold(gray, adaptive, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, blockSize, 2);
          const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
          cv.morphologyEx(adaptive, edges, cv.MORPH_CLOSE, kernel);
          safeMatDelete(adaptive); safeMatDelete(kernel);
        } else if (mode === 'morphological') {
          const blurred = new cv.Mat();
          cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0);
          const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
          const dilated = new cv.Mat(); const eroded = new cv.Mat();
          cv.dilate(blurred, dilated, kernel); cv.erode(blurred, eroded, kernel);
          cv.subtract(dilated, eroded, edges);
          cv.normalize(edges, edges, 0, 255, cv.NORM_MINMAX);
          safeMatDelete(blurred); safeMatDelete(kernel); safeMatDelete(dilated); safeMatDelete(eroded);
        } else if (mode === 'gradient') {
          const blurred = new cv.Mat(); cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
          const gradX = new cv.Mat(); const gradY = new cv.Mat(); const absGradX = new cv.Mat(); const absGradY = new cv.Mat();
          cv.Sobel(blurred, gradX, cv.CV_16S, 1, 0, 3); cv.Sobel(blurred, gradY, cv.CV_16S, 0, 1, 3);
          cv.convertScaleAbs(gradX, absGradX); cv.convertScaleAbs(gradY, absGradY);
          cv.addWeighted(absGradX, 0.5, absGradY, 0.5, 0, edges);
          const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(2, 2));
          cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);
          safeMatDelete(blurred); safeMatDelete(gradX); safeMatDelete(gradY); safeMatDelete(absGradX); safeMatDelete(absGradY); safeMatDelete(kernel);
        } else {
          const blurred = new cv.Mat(); cv.GaussianBlur(gray, blurred, new cv.Size(3, 3), 0);
          cv.Canny(blurred, edges, 50, 150);
          safeMatDelete(blurred);
        }

        // find contours
        contours = new cv.MatVector();
        hierarchy = new cv.Mat();
        cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

        // choose largest contour by area
        let maxArea = 0; let idx = -1;
        for (let i = 0; i < contours.size(); i++) {
          const c = contours.get(i);
          const a = cv.contourArea(c);
          if (a > maxArea) { maxArea = a; idx = i; }
        }

        if (idx >= 0) {
          // set global contour (clone to keep independent)
          safeMatDelete(contour);
          contour = contours.get(idx).clone();
          showToast(`ØªÙ… ÙƒØ´Ù ÙƒÙˆÙ†ØªÙˆØ± Ø±Ø¦ÙŠØ³ÙŠ (Ø§Ù„Ù…Ø³Ø§Ø­Ø©: ${Math.round(maxArea)})`);
        } else {
          showToast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙˆÙ†ØªÙˆØ± Ù…Ù†Ø§Ø³Ø¨');
          safeMatDelete(src); safeMatDelete(gray); safeMatDelete(edges); safeMatDelete(hierarchy); if (contours) contours.delete();
          return;
        }

        // keep grayMat for later sampling
        safeMatDelete(grayMat);
        grayMat = gray.clone();

        // render previews if you have these functions (safe no-op if not)
        try { renderHeatmap(); } catch(e){}
        try { renderContour(gray, contour); } catch(e){}

        // cleanup
        safeMatDelete(src); safeMatDelete(edges); safeMatDelete(hierarchy);
        if (contours) contours.delete();

      } catch (err) {
        console.error('detectLaserContours error', err);
        showToast('ÙØ´Ù„ ÙÙŠ ØªØ­Ù„ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© Ù„Ù„Ù‘ÙŠØ²Ø±');
        safeMatDelete(src); safeMatDelete(gray); safeMatDelete(edges); safeMatDelete(hierarchy);
        if (contours) contours.delete();
      }
    }

    // ======== Path optimizer (kept simple) ========
    function optimizeLaserPath(points) {
      if (!points || points.length < 2) return points;
      const optimized = [];
      const tolerance = 2; // Ù…Ù…
      optimized.push(points[0]);
      for (let i = 1; i < points.length - 1; i++) {
        const prev = optimized[optimized.length - 1];
        const current = points[i];
        const next = points[i + 1];
        const distToPrev = Math.hypot(current.x - prev.x, current.y - prev.y);
        const distToNext = Math.hypot(next.x - current.x, next.y - current.y);
        if (distToPrev > tolerance && distToNext > tolerance) optimized.push(current);
      }
      optimized.push(points[points.length - 1]);
      return optimized;
    }

    // ======= map power to S (configurable) =======
    function mapPowerToS(pct, maxS = 1000) {
      pct = Math.max(0, Math.min(100, pct));
      return Math.round((pct / 100) * maxS);
    }

    // ======= Generate Laser G-code (fixed & optimized) =======
    function generateLaserGcode() {
      if (!grayMat || !previewCanvas) { showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ø¬Ø§Ù‡Ø²Ø© Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©'); return ''; }

      try {
        showToast('Ø¬Ø§Ø±ÙŠ ØªÙˆÙ„ÙŠØ¯ G-code...');

        const laserPower = parseInt(document.getElementById('laserPower').value) || 80; // percent 0..100
        const laserSpeed = parseInt(document.getElementById('laserSpeed').value) || 2000; // mm/min
        const dynamicPower = document.getElementById('laserDynamic').checked;
        const optimizePaths = document.getElementById('laserOptimize').checked;
        const airAssist = document.getElementById('laserAirAssist').checked;
        const passes = parseInt(document.getElementById('laserPasses').value) || 1;

        const workWidth = parseFloat(document.getElementById('laserWorkWidth').value) || 300;
        const workHeight = parseFloat(document.getElementById('laserWorkHeight').value) || 200;
        const originX = parseFloat(document.getElementById('laserOriginX').value) || 0;
        const originY = parseFloat(document.getElementById('laserOriginY').value) || 0;

        const lines = [];
        lines.push('; Laser G-code - Generated by CNC AI (corrected)');
        lines.push('G21 G90 G17');
        lines.push('G0 X0 Y0');
        if (airAssist) lines.push('M8');

        const scaleX = workWidth / previewCanvas.width; // mm per pixel
        const scaleY = workHeight / previewCanvas.height;

        let totalPoints = 0;
        let totalLength = 0;
        const allPoints = [];

        // user/tunable params (in mm)
        const stepOverMm = 2.0; // mm between raster lines
        const pointSpacingMm = 2.0; // mm between points along a line

        // convert to pixel steps (integers) to avoid fractional loops
        const yStepPx = Math.max(1, Math.round(stepOverMm / scaleY));
        const xStepPx = Math.max(1, Math.round(pointSpacingMm / scaleX));

        // build mask from the detected contour to speed up inside-tests
        let mask = null;
        try {
          if (contour) {
            mask = new cv.Mat.zeros(grayMat.rows, grayMat.cols, cv.CV_8UC1);
            const vec = new cv.MatVector();
            vec.push_back(contour);
            cv.drawContours(mask, vec, 0, new cv.Scalar(255), cv.FILLED);
            vec.delete();
          }
        } catch (err) {
          console.warn('failed to build mask from contour', err);
          safeMatDelete(mask);
          mask = null;
        }

        for (let pass = 0; pass < passes; pass++) {
          for (let y = 0; y < previewCanvas.height; y += yStepPx) {
            let inSegment = false;
            let segStartX = -1;
            // accumulate a row's points in pixels and later convert to mm
            const rowPointsPx = [];

            for (let x = 0; x < previewCanvas.width; x += xStepPx) {
              // fast inside check using mask if available else assume inside
              let inside = true;
              if (mask) {
                const yi = Math.min(mask.rows - 1, Math.max(0, Math.round(y)));
                const xi = Math.min(mask.cols - 1, Math.max(0, Math.round(x)));
                inside = mask.ucharPtr(yi, xi)[0] > 0;
              }

              if (inside && !inSegment) {
                inSegment = true; segStartX = x;
              } else if (!inside && inSegment) {
                // finalize segment from segStartX .. x-1
                for (let sx = segStartX; sx < x; sx += xStepPx) {
                  const grayValue = sampleGrayAt(sx, y);
                  const powerPct = dynamicPower ? Math.round((grayValue / 255) * laserPower) : laserPower;
                  const px = (sx * scaleX) + originX;
                  const py = (y * scaleY) + originY;
                  rowPointsPx.push({ x: px, y: py, power: powerPct, gray: grayValue });
                  totalPoints++;
                }
                inSegment = false;
              }
            }

            // if still inside at line end
            if (inSegment && segStartX >= 0) {
              for (let sx = segStartX; sx < previewCanvas.width; sx += xStepPx) {
                const grayValue = sampleGrayAt(sx, y);
                const powerPct = dynamicPower ? Math.round((grayValue / 255) * laserPower) : laserPower;
                const px = (sx * scaleX) + originX;
                const py = (y * scaleY) + originY;
                rowPointsPx.push({ x: px, y: py, power: powerPct, gray: grayValue });
                totalPoints++;
              }
            }

            if (rowPointsPx.length > 0) {
              allPoints.push(...rowPointsPx); // correct use of spread operator
            }
          }
        }

        // cleanup mask
        safeMatDelete(mask);

        if (allPoints.length === 0) {
          showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ù‚Ø§Ø· Ù„ÙŠØ²Ø± Ø¨Ø¹Ø¯ Ø§Ù„Ù…Ø³Ø­ â€” ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù Ø£Ùˆ Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„Ø¯Ù‚Ø©.');
          return '';
        }

        // optional optimization pass
        let pathPoints = allPoints;
        if (optimizePaths) pathPoints = optimizeLaserPath(allPoints);

        // build gcode lines from pathPoints
        let prev = null;
        const maxS = 1000; // default; change if your firmware expects different range
        let currentS = -1;

        for (let i = 0; i < pathPoints.length; i++) {
          const p = pathPoints[i];
          if (!prev) {
            lines.push(`G0 X${p.x.toFixed(3)} Y${p.y.toFixed(3)}`);
            const sVal = mapPowerToS(p.power, maxS);
            lines.push(`M3 S${sVal}`);
            currentS = sVal;
          } else {
            const dist = Math.hypot(p.x - prev.x, p.y - prev.y);
            totalLength += dist;
            // if power changed, emit new M3 S
            const sVal = mapPowerToS(p.power, maxS);
            if (sVal !== currentS) {
              lines.push(`M3 S${sVal}`);
              currentS = sVal;
            }
            lines.push(`G1 X${p.x.toFixed(3)} Y${p.y.toFixed(3)} F${laserSpeed}`);
          }
          prev = p;
        }

        lines.push('M5'); // turn off laser
        if (airAssist) lines.push('M9');
        lines.push('G0 X0 Y0');

        // time estimate (mm/min assumed)
        const timeMinutes = (totalLength / (laserSpeed || 1));
        const mins = Math.floor(timeMinutes);
        const secs = Math.round((timeMinutes - mins) * 60);
        lines.push(`; Estimated time: ${mins}m ${secs}s`);

        lastGeneratedGcode = lines.join('\n');
        showToast('ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code Ø¨Ù†Ø¬Ø§Ø­');
        return lastGeneratedGcode;

      } catch (err) {
        console.error('generateLaserGcode error', err);
        showToast('Ø®Ø·Ø£ Ø¹Ù†Ø¯ ØªÙˆÙ„ÙŠØ¯ G-code');
        return '';
      }
    }

    // ======== Download helper ========
    document.getElementById('btnGenerateLaser').addEventListener('click', ()=>{
      const g = generateLaserGcode();
      if (g && g.length > 0) {
        lastGeneratedGcode = g;
      }
    });

    document.getElementById('btnDownloadGcode').addEventListener('click', ()=>{
      if (!lastGeneratedGcode) { showToast('Ù„Ù… ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code Ø¨Ø¹Ø¯'); return; }
      const blob = new Blob([lastGeneratedGcode], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'laser_gcode.ngc'; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    });

    document.getElementById('btnRedetectLaser').addEventListener('click', ()=> detectLaserContours());

    // keep UI values visible
    document.getElementById('laserPower').addEventListener('input', e=> document.getElementById('laserPowerValue').textContent = e.target.value + '%');
    document.getElementById('laserSpeed').addEventListener('input', e=> document.getElementById('laserSpeedValue').textContent = e.target.value);
    document.getElementById('laserDetail').addEventListener('input', e=> document.getElementById('laserDetailValue').textContent = e.target.value);

    // simple tab switching
    document.querySelectorAll('.tab-buttons button').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('.tab-buttons button').forEach(b=>b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c=>c.classList.remove('active'));
        btn.classList.add('active');
        const t = btn.getAttribute('data-tab');
        document.getElementById(t).classList.add('active');
      });
    });

    // keep a minimal renderHeatmap/renderContour to avoid exceptions if referenced
    function renderHeatmap() { try { const canvas = document.getElementById('canvasHeatmap'); const ctx = canvas.getContext('2d'); canvas.width = grayMat.cols; canvas.height = grayMat.rows; const img = ctx.createImageData(canvas.width, canvas.height); const d = img.data; for (let i=0;i<grayMat.data.length;i++){ const v = grayMat.data[i]; d[i*4]=v; d[i*4+1]=v; d[i*4+2]=v; d[i*4+3]=255; } ctx.putImageData(img,0,0); document.getElementById('canvasHeatmap').style.display='block'; } catch(e){} }
    function renderContour(g, c) { try { const canvas = document.getElementById('canvasContour'); const ctx = canvas.getContext('2d'); canvas.width = g.cols; canvas.height = g.rows; ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(previewCanvas,0,0); if (!c) return; ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 1.5; ctx.beginPath(); const pts = c.data32S || null; // fallback: we will draw using findNonZero for visibility
      try { const temp = new cv.Mat(); cv.drawContours(temp, (()=>{ const mv = new cv.MatVector(); mv.push_back(c); return mv; })(), 0, new cv.Scalar(255,0,0,255), 1); temp.delete(); } catch(e){} } catch(e){} }

  </script></body>
</html>
