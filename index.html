<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CNC AI - Ø«Ø§Ø¨Øª ÙˆÙ…ØµØ­Ø­</title>
  <style>
    /* === Ù„Ù… Ø£Ø­Ø°Ù Ø£ÙŠ Ø¬Ø²Ø¡ Ù…Ù† Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ â€” Ø§Ù„Ø£Ù†Ù…Ø§Ø· Ø§Ù„Ø£ØµÙ„ÙŠØ© Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª Ø·ÙÙŠÙØ© === */
    :root{
      --primary:#4a90e2; --accent:#67b0f5; --bg:#f8f8f8; --card:#fff; --text:#222;
    }
    body{font-family:Arial, sans-serif;background:var(--bg);color:var(--text);margin:0;padding:0;}
    header{background:linear-gradient(90deg,var(--primary),var(--accent));color:#fff;padding:12px;border-radius:0 0 8px 8px;display:flex;align-items:center;justify-content:space-between}
    header h1{font-size:18px;margin:0;margin-inline-start:12px}
    .container{max-width:1180px;margin:18px auto;padding:12px}
    .tabs{display:flex;gap:8px;background:var(--card);padding:6px;border-radius:8px;border:1px solid #e6e6e6;overflow:hidden}
    .tab{padding:10px 14px;cursor:pointer;background:transparent;border-radius:6px;font-weight:600}
    .tab.active{background:var(--primary);color:#fff}
    .grid{display:grid;grid-template-columns:1fr;gap:12px;margin-top:12px}
    @media(min-width:980px){ .grid{grid-template-columns:1fr 420px} }

    .card{background:var(--card);padding:12px;border-radius:10px;border:1px solid #e6e6e6;box-shadow:0 6px 18px rgba(0,0,0,0.03)}
    .flex{display:flex;gap:8px;align-items:center}
    label{font-size:13px}
    input[type=file]{display:none}
    .file-label{display:inline-block;padding:8px 10px;border-radius:8px;background:#f0f4f9;border:1px dashed #dfe9fb;cursor:pointer}
    canvas{max-width:100%;border-radius:8px;background:white}
    #preview3d{width:100%;height:360px;border-radius:8px;overflow:hidden;border:1px solid #e6e6e6;position:relative;background:#fafafa;}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
    .btn{padding:8px 12px;border-radius:8px;border:none;cursor:pointer;background:var(--primary);color:#fff}
    .btn.secondary{background:#eef3fb;color:var(--primary);border:1px solid #d7e9ff}
    .small{font-size:13px;padding:6px 8px}
    textarea{width:100%;height:220px;font-family:monospace;padding:10px;border-radius:8px;border:1px solid #e6e6e6}
    .info{font-size:13px;color:#555;margin-top:6px}
    .row{display:flex;gap:8px;align-items:center}
    input[type=range]{width:160px}
    .notification{position:fixed;top:18px;left:18px;background:#111;color:#fff;padding:10px 14px;border-radius:8px;opacity:0;transform:translateY(-8px);transition:all .28s}
    .notification.show{opacity:1;transform:none}
  </style>
</head>
<body>
  <header>
    <h1>ğŸ› ï¸ CNC AI â€” Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…ØµØ­Ø­Ø© (Ø§Ù„ØªØµÙ…ÙŠÙ… Ù…Ø­ÙÙˆØ¸)</h1>
    <div style="display:flex;gap:10px;align-items:center">
      <button id="themeToggle" class="btn small">ğŸŒ™</button>
    </div>
  </header>

  <div class="container">
    <div class="tabs">
      <div class="tab active" data-tab="preview">Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„ØµÙˆØ±Ø©</div>
      <div class="tab" data-tab="edges">Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­ÙˆØ§Ù</div>
      <div class="tab" data-tab="gcode">ØªÙˆÙ„ÙŠØ¯ G-code</div>
      <div class="tab" data-tab="simulation">Ù…Ø¹Ø§ÙŠÙ†Ø© 3D Ù„Ù„ÙƒÙˆØ¯</div>
    </div>

    <div class="grid" style="margin-top:14px">
      <!-- Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø£ÙŠØ³Ø±: Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©ØŒ preview2dØŒ heatmap -->
      <div>
        <div class="card">
          <h3>ğŸ“¤ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©</h3>
          <div class="row" style="margin-top:8px">
            <label class="file-label" for="fileInput">ğŸ“ Ø§Ø®ØªØ± ØµÙˆØ±Ø©</label>
            <input id="fileInput" type="file" accept="image/*" />
            <div id="fileName" class="info">Ù„Ù… ÙŠØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø£ÙŠ ØµÙˆØ±Ø©</div>
          </div>

          <div style="margin-top:12px">
            <h4>ğŸ“· Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</h4>
            <div style="overflow:auto">
              <canvas id="preview2d"></canvas>
            </div>
          </div>

          <div style="margin-top:12px">
            <h4>ğŸŒˆ Heatmap</h4>
            <canvas id="heatmap" style="width:100%;height:auto"></canvas>
            <div class="controls" style="margin-top:8px">
              <div class="row">
                <label>Ù…Ù‚ÙŠØ§Ø³ Z</label>
                <input id="heightIntensity" type="range" min="5" max="400" value="80" />
                <span id="heightValue">80</span>
              </div>
              <div class="row">
                <label>Ø¯Ù‚Ø© G-code</label>
                <select id="gcodePrecision">
                  <option value="low">Ù…Ù†Ø®ÙØ¶Ø© (Ø£Ø³Ø±Ø¹)</option>
                  <option value="medium" selected>Ù…ØªÙˆØ³Ø·Ø©</option>
                  <option value="high">Ø¹Ø§Ù„ÙŠØ© (Ø£Ø¨Ø·Ø£)</option>
                </select>
              </div>
            </div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>âš™ï¸ Ø£Ø¯ÙˆØ§Øª Ø§Ù„ØµÙˆØ±Ø©</h3>
          <div class="controls">
            <button class="btn secondary small" id="grayscaleBtn">ØªØ¯Ø±Ø¬ Ø±Ù…Ø§Ø¯ÙŠ</button>
            <button class="btn secondary small" id="sharpenBtn">Ø­Ø¯Ø©</button>
            <button class="btn secondary small" id="smoothBtn">Ù†Ø¹ÙˆÙ…Ø©</button>
            <button class="btn small" id="resetBtn">ğŸ” Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</button>
          </div>
          <p class="info">Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ ÙŠÙØ·Ø¨Ù‘Ù‚ Ø¹Ù„Ù‰ Ù†Ø³Ø®Ø© Ø§Ù„Ø¹Ù…Ù„ ÙˆÙ„ÙŠØ³ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø£ØµÙ„ÙŠ.</p>
        </div>
      </div>

      <!-- Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø£ÙŠÙ…Ù†: 3D previewØŒ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª G-codeØŒ Ù…Ø®Ø±Ø¬Ø§Øª -->
      <div>
        <div class="card">
          <h3>ğŸŒ€ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</h3>
          <div id="preview3d"></div>
          <div class="controls" style="margin-top:8px">
            <label class="small">Ø¯ÙˆØ±Ø§Ù†
              <input id="rotationSpeed" type="range" min="0" max="0.05" step="0.001" value="0.01">
            </label>
            <label class="small">Ø²ÙˆÙ…
              <input id="zoomControl" type="range" min="50" max="800" step="10" value="200">
            </label>
            <button class="btn small" id="toggleToolpathBtn">Ø¹Ø±Ø¶/Ø¥Ø®ÙØ§Ø¡ ToolPath</button>
            <button class="btn secondary small" id="rebuild3DBtn">Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆÙ„ÙŠØ¯ 3D</button>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>ğŸ”§ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­ÙˆØ§Ù & ØªÙˆÙ„ÙŠØ¯ G-code</h3>

          <div class="controls" style="margin-top:8px">
            <label class="small">Ø¹ØªØ¨Ø© Ø§Ù„Ø­ÙˆØ§Ù
              <input id="edgeThreshold" type="range" min="0" max="255" value="128" />
            </label>
            <select id="edgeAlgorithm" class="small">
              <option value="sobel">Sobel</option>
              <option value="laplacian">Laplacian</option>
            </select>
          </div>

          <div class="controls" style="margin-top:8px">
            <button class="btn small" id="extractEdgesBtn">ğŸ” Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­ÙˆØ§Ù</button>
            <button class="btn small" id="generateGcodeBtn">âš¡ ØªÙˆÙ„ÙŠØ¯ G-code</button>
            <button class="btn secondary small" id="downloadGcodeBtn">ğŸ’¾ Ø­ÙØ¸</button>
          </div>

          <div style="margin-top:10px">
            <div class="info">Ù†Ù‚Ø§Ø· Ø§Ù„Ø­ÙˆØ§Ù: <b id="edgePoints">0</b> â€” Ù…Ø³Ø§Ø±Ø§Øª: <b id="edgeCount">0</b> â€” Ø·ÙˆÙ„ Ø¥Ø¬Ù…Ø§Ù„ÙŠ (Ø¨ÙƒØ³Ù„): <b id="edgeLength">0</b></div>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <h3>ğŸ“œ Ù…Ø®Ø±Ø¬Ø§Øª G-code</h3>
          <textarea id="gcodeOutput" readonly>// Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ ØªÙˆÙ„ÙŠØ¯ G-code Ù„Ø¨Ø¯Ø¡</textarea>
        </div>
      </div>
    </div>

    <!-- ØªØ¨ÙˆÙŠØ¨ Ù…Ø¹Ø§ÙŠÙ†Ø© 3D Ù„Ù„ÙƒÙˆØ¯ ÙŠÙ…ÙƒÙ† Ø¥Ø¹Ø§Ø¯Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù†ÙØ³ preview3d (Ù…Ø¨Ø³Ø·) -->
    <div style="margin-top:12px" id="extra-space"></div>
  </div>

  <div id="notif" class="notification"></div>

  <!-- three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
  /* ============================================================
     Ù…ØªØºÙŠØ±Ø§Øª DOM ÙˆØ¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµÙˆØ±Ø© ÙˆØ§Ù„Ø®Ø±ÙŠØ·Ø© ÙˆØ§Ù„Ø­ÙˆØ§Ù (Ø§Ø­ØªÙØ¸Ù†Ø§ Ø¨Ø§Ù„ØªØµÙ…ÙŠÙ…)
     ============================================================ */
  const fileInput = document.getElementById('fileInput');
  const fileName = document.getElementById('fileName');
  const preview2d = document.getElementById('preview2d');
  const ctx2d = preview2d.getContext('2d');
  const heatmap = document.getElementById('heatmap');
  const ctxHeat = heatmap.getContext('2d');

  const heightIntensity = document.getElementById('heightIntensity');
  const heightValue = document.getElementById('heightValue');
  const rotationSpeedInput = document.getElementById('rotationSpeed');
  const zoomControl = document.getElementById('zoomControl');
  const edgeThreshold = document.getElementById('edgeThreshold');
  const edgeAlgorithm = document.getElementById('edgeAlgorithm');
  const gcodeOutput = document.getElementById('gcodeOutput');
  const notif = document.getElementById('notif');

  // Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ…
  const grayscaleBtn = document.getElementById('grayscaleBtn');
  const sharpenBtn = document.getElementById('sharpenBtn');
  const smoothBtn = document.getElementById('smoothBtn');
  const resetBtn = document.getElementById('resetBtn');
  const toggleToolpathBtn = document.getElementById('toggleToolpathBtn');
  const rebuild3DBtn = document.getElementById('rebuild3DBtn');
  const extractEdgesBtn = document.getElementById('extractEdgesBtn');
  const generateGcodeBtn = document.getElementById('generateGcodeBtn');
  const downloadGcodeBtn = document.getElementById('downloadGcodeBtn');

  let baseImageData = null;     // original (work) image data
  let currentImageData = null;  // after enhancements
  let heightMapData = null;     // Float32Array [0..1]
  let originalWidth = 0, originalHeight = 0;

  let edgePaths = [];   // array of paths: each path is [{x,y}, ...] OR when simple: single array of points
  let edgePointsFlat = []; // flat points array when simpler
  let lastGcode = '';

  /* ----------------------------
     Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ØµØºÙŠØ±Ø©
  ---------------------------- */
  function showNotification(msg, timeout=2200){
    notif.textContent = msg;
    notif.classList.add('show');
    setTimeout(()=> notif.classList.remove('show'), timeout);
  }

  /* ============================
     ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© (Ù†Ø­Ø§ÙØ¸ Ø¹Ù„Ù‰ Ù†ÙØ³ Ø§Ù„ØªØ¬Ø±Ø¨Ø©)
     - Ù†Ù‚ÙˆÙ… Ø¨Ø¹Ù…Ù„ downsample Ø­ÙƒÙŠÙ… Ø¥Ø°Ø§ Ø§Ù„ØµÙˆØ±Ø© ÙƒØ¨ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹
     ============================ */
  fileInput.addEventListener('change', (e)=>{
    const f = e.target.files[0];
    if (!f) return;
    fileName.textContent = f.name;
    const reader = new FileReader();
    reader.onload = (ev)=>{
      const img = new Image();
      img.onload = ()=>{
        // Downsample if width > 1200 to avoid heavy memory
        const maxDisplayW = 900; // Ù„Ø§ Ù†ØºÙŠØ± Ø§Ù„ØªØµÙ…ÙŠÙ…ØŒ Ù„ÙƒÙ† Ù†Ø®Ø²Ù† Ù†Ø³Ø®Ø© Ø£ØµØºØ± Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
        const scale = Math.min(1, maxDisplayW / img.width);
        originalWidth = Math.max(1, Math.round(img.width * scale));
        originalHeight = Math.max(1, Math.round(img.height * scale));
        preview2d.width = originalWidth;
        preview2d.height = originalHeight;
        ctx2d.clearRect(0,0,preview2d.width, preview2d.height);
        ctx2d.drawImage(img, 0, 0, preview2d.width, preview2d.height);

        baseImageData = ctx2d.getImageData(0,0,preview2d.width, preview2d.height);
        currentImageData = ctx2d.getImageData(0,0,preview2d.width, preview2d.height);

        computeHeightMapFromCurrent();
        showNotification('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©');
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(f);
  });

  /* ============================
     ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¨Ø³ÙŠØ·Ø© Ù„Ù„ØµÙˆØ±Ø© (ØªØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ù†Ø³Ø®Ø© Ø§Ù„Ø¹Ù…Ù„ currentImageData)
     - ØªÙØ­Ø§ÙÙØ¸ Ø¹Ù„Ù‰ Ø§Ù„ØªØµÙ…ÙŠÙ… Ø§Ù„Ø£ØµÙ„ÙŠ (Ø²Ø± Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† ÙŠØ¹ÙŠØ¯ baseImageData)
     ============================ */
  function applyEnhancement(type){
    if (!baseImageData) { showNotification('Ø­Ù…Ù‘Ù„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹',1800); return; }
    // clone base image to temp canvas
    const tmp = document.createElement('canvas');
    tmp.width = baseImageData.width; tmp.height = baseImageData.height;
    const tctx = tmp.getContext('2d');
    tctx.putImageData(baseImageData,0,0);
    let img = tctx.getImageData(0,0,tmp.width,tmp.height);
    const data = img.data;

    if (type === 'grayscale'){
      for (let i=0;i<data.length;i+=4){
        const g = Math.round(0.299*data[i]+0.587*data[i+1]+0.114*data[i+2]);
        data[i]=data[i+1]=data[i+2]=g;
      }
    } else if (type === 'sharpen'){
      // simple 3x3 unsharp mask-ish (careful, heavier)
      const copy = new Uint8ClampedArray(data);
      const w = tmp.width, h = tmp.height;
      const weights = [0,-1,0,-1,5,-1,0,-1,0];
      for (let y=1;y<h-1;y++){
        for (let x=1;x<w-1;x++){
          for (let c=0;c<3;c++){
            let sum=0;
            for (let ky=-1;ky<=1;ky++){
              for (let kx=-1;kx<=1;kx++){
                const wt = weights[(ky+1)*3 + (kx+1)];
                const idx = ((y+ky)*w + (x+kx))*4 + c;
                sum += copy[idx]*wt;
              }
            }
            const idx0 = (y*w + x)*4 + c;
            data[idx0] = Math.max(0, Math.min(255, sum));
          }
        }
      }
    } else if (type === 'smooth'){
      // lightweight blur
      const copy = new Uint8ClampedArray(data);
      const w = tmp.width, h = tmp.height;
      for (let y=1;y<h-1;y++){
        for (let x=1;x<w-1;x++){
          for (let c=0;c<3;c++){
            let sum=0;
            for (let ky=-1;ky<=1;ky++){
              for (let kx=-1;kx<=1;kx++){
                const idx = ((y+ky)*w + (x+kx))*4 + c;
                sum += copy[idx];
              }
            }
            const idx0 = (y*w + x)*4 + c;
            data[idx0] = Math.round(sum/9);
          }
        }
      }
    }

    tctx.putImageData(img,0,0);
    // draw scaled image to preview2d to keep display size identical
    ctx2d.clearRect(0,0,preview2d.width, preview2d.height);
    ctx2d.drawImage(tmp,0,0,preview2d.width, preview2d.height);
    currentImageData = ctx2d.getImageData(0,0,preview2d.width, preview2d.height);
    computeHeightMapFromCurrent();
    showNotification('ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„');
  }

  function resetImage(){
    if (!baseImageData) return;
    ctx2d.putImageData(baseImageData,0,0);
    currentImageData = ctx2d.getImageData(0,0,preview2d.width, preview2d.height);
    computeHeightMapFromCurrent();
    showNotification('Ø§Ø³ØªØ¹ÙŠØ¯Øª Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©');
  }

  /* ============================
     Ø­Ø³Ø§Ø¨ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª (heightMapData)
     - Ù†ØªÙŠØ­ downsampling Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¹Ù†Ø¯Ù…Ø§ ØªÙƒÙˆÙ† Ø§Ù„Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©
     - heightMapData: Float32Array Ø¨Ø¹Ø±Ø¶*Ø§Ø±ØªÙØ§Ø¹
     ============================ */
  function computeHeightMapFromCurrent(){
    if (!currentImageData) return;
    const w = currentImageData.width, h = currentImageData.height;
    originalWidth = w; originalHeight = h;
    heightMapData = new Float32Array(w*h);
    const d = currentImageData.data;
    for (let i=0,j=0;i<d.length;i+=4,j++){
      const g = 0.299 * d[i] + 0.587*d[i+1] + 0.114*d[i+2];
      heightMapData[j] = Math.max(0, Math.min(1, g/255));
    }
    // render heatmap (simple colormap jet-like)
    heatmap.width = w; heatmap.height = h;
    const out = ctxHeat.createImageData(w,h);
    for (let i=0;i<heightMapData.length;i++){
      const v = heightMapData[i];
      const c = colorFromJet(v);
      out.data[i*4] = c.r; out.data[i*4+1] = c.g; out.data[i*4+2] = c.b; out.data[i*4+3] = 255;
    }
    ctxHeat.putImageData(out,0,0);
    // ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© ØµØºÙŠØ±Ø©
    document.getElementById('edgePoints').textContent = 0;
    document.getElementById('edgeCount').textContent = 0;
    document.getElementById('edgeLength').textContent = 0;
    
    // Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¹Ø±Ø¶ 3D
    rebuild3D();
    
    showNotification('ØªÙ… ØªØ­Ø¯ÙŠØ« Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª');
  }

  function colorFromJet(v){
    // simple jet palette
    v = Math.max(0,Math.min(1,v));
    const four = 4 * v;
    const r = Math.round(255 * Math.max(0, Math.min(1, Math.min(four - 1.5, -four + 4.5))));
    const g = Math.round(255 * Math.max(0, Math.min(1, Math.min(four - 0.5, -four + 3.5))));
    const b = Math.round(255 * Math.max(0, Math.min(1, Math.min(four + 0.5, -four + 2.5))));
    return {r,g,b};
  }

  /* ============================
     Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­ÙˆØ§Ù (Sobel Ø£Ùˆ Laplacian)
     - Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†Ù‚ÙˆÙ… Ø¨ØªØ¬Ù…ÙŠØ¹ Ù†Ù‚Ø§Ø· Ù…ØªØ¬Ø§ÙˆØ±Ø© ÙÙŠ Ù…Ø³Ø§Ø±Ø§Øª
     - Ø«Ù… Ù†Ø¨Ø³Ø· Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ÙƒØ¨ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹
     ============================ */
  function extractEdges(){
    if (!currentImageData) { showNotification('Ø­Ù…Ù‘Ù„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹',1600); return; }
    const w = currentImageData.width, h = currentImageData.height;
    const gray = new Uint8ClampedArray(w*h);
    const d = currentImageData.data;
    for (let i=0,j=0;i<d.length;i+=4,j++){
      gray[j] = Math.round(0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2]);
    }

    const algo = edgeAlgorithm.value;
    let edgeImg = new Uint8ClampedArray(w*h);
    if (algo === 'sobel'){
      const kx = [-1,0,1,-2,0,2,-1,0,1];
      const ky = [-1,-2,-1,0,0,0,1,2,1];
      for (let y=1;y<h-1;y++){
        for (let x=1;x<w-1;x++){
          let gx=0,gy=0;
          for (let ky0=-1;ky0<=1;ky0++){
            for (let kx0=-1;kx0<=1;kx0++){
              const v = gray[(y+ky0)*w + (x+kx0)];
              gx += v * kx[(ky0+1)*3 + (kx0+1)];
              gy += v * ky[(ky0+1)*3 + (kx0+1)];
            }
          }
          const mag = Math.hypot(gx,gy);
          edgeImg[y*w + x] = (mag > Number(edgeThreshold.value)) ? 255 : 0;
        }
      }
    } else {
      // laplacian
      const lap = [0,-1,0,-1,4,-1,0,-1,0];
      for (let y=1;y<h-1;y++){
        for (let x=1;x<w-1;x++){
          let sum=0;
          for (let ky0=-1;ky0<=1;ky0++){
            for (let kx0=-1;kx0<=1;kx0++){
              const v = gray[(y+ky0)*w + (x+kx0)];
              sum += v * lap[(ky0+1)*3 + (kx0+1)];
            }
          }
          edgeImg[y*w + x] = (Math.abs(sum) > Number(edgeThreshold.value))? 255 : 0;
        }
      }
    }

    // Ø§Ø±Ø³Ù… Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© (Ø®ÙÙŠÙØ©)
    const out = ctx2d.createImageData(w,h);
    for (let i=0;i<edgeImg.length;i++){
      const val = edgeImg[i];
      out.data[i*4] = out.data[i*4+1] = out.data[i*4+2] = val;
      out.data[i*4+3] = 255;
    }
    // Ù„Ø§ Ù†ØºÙŠÙ‘Ø± Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© â€” Ù†Ø¹Ø±Ø¶ Ø¹Ù„Ù‰ ÙƒØ§Ù†ÙØ³ Ø§Ù„Ø­Ø¯
    const edgeCanvas = document.createElement('canvas');
    edgeCanvas.width = w; edgeCanvas.height = h;
    edgeCanvas.getContext('2d').putImageData(out,0,0);

    // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø¨ÙŠÙƒØ³Ù„Ø§Øª Ø¥Ù„Ù‰ Ù…Ø³Ø§Ø±Ø§Øª Ù…ØªØµÙ„Ø© (Ø¨Ø¨Ø³Ø§Ø·Ø©: ØªØ¬Ù…ÙŠØ¹ Ù…ÙƒÙˆÙ† Ù…ØªÙ‘ØµÙ„)
    const visited = new Uint8Array(w*h);
    edgePaths = [];
    edgePointsFlat = [];
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const idx = y*w + x;
        if (edgeImg[idx] === 255 && !visited[idx]) {
          // flood fill to build component
          const stack = [{x,y}];
          const path = [];
          visited[idx] = 1;
          while (stack.length){
            const p = stack.pop();
            path.push(p);
            for (let dy=-1;dy<=1;dy++) for (let dx=-1;dx<=1;dx++){
              if (dx===0 && dy===0) continue;
              const nx = p.x + dx, ny = p.y + dy;
              if (nx<0||ny<0||nx>=w||ny>=h) continue;
              const ni = ny*w + nx;
              if (!visited[ni] && edgeImg[ni]===255){
                visited[ni]=1; stack.push({x:nx,y:ny});
              }
            }
          }
          if (path.length>4) {
            // simplify path if too large
            const precision = (document.getElementById('gcodePrecision').value === 'low') ? 4 :
                              (document.getElementById('gcodePrecision').value === 'medium') ? 2 : 1;
            const simplified = simplifyPath(orderPathByChain(path), precision);
            edgePaths.push(simplified);
            edgePointsFlat = edgePointsFlat.concat(simplified);
          }
        }
      }
    }

    document.getElementById('edgePoints').textContent = edgePointsFlat.length;
    document.getElementById('edgeCount').textContent = edgePaths.length;
    document.getElementById('edgeLength').textContent = Math.round(calculateEdgeLength(edgePaths));

    showNotification('ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­ÙˆØ§Ù');
    drawToolpathOn3D(); // Ù†Ø¹Ø±Ø¶ ToolPath Ø¹Ù„Ù‰ 3D Ø¨Ø¹Ø¯ Ø§Ù„Ø§Ø³ØªØ®Ø±Ø§Ø¬
  }

  /* ============================
     Ù…Ø³Ø§Ø¹Ø¯Ø©: Ù†Ø¬Ù…Ø¹ Ù†Ù‚Ø§Ø· Ø§Ù„Ù…Ø³Ø§Ø± ÙÙŠ ØªØ±ØªÙŠØ¨ Ù…ØªØªØ§Ù„ÙŠ ØªÙ‚Ø±ÙŠØ¨ÙŠ
     - path Ù‡Ùˆ Ù…Ø¬Ù…ÙˆØ¹Ø© Ù†Ù‚Ø§Ø· ØºÙŠØ± Ù…Ø±ØªØ¨Ø© Ù†ØªÙŠØ¬Ø© Ø§Ù„-flood fill
     - Ù†Ø±ØªØ¨Ù‡Ø§ Ø¹Ø¨Ø± Ø¨Ù†Ø§Ø¡ Ø³Ù„Ø³Ù„Ø© Ø¬Ø±ÙŠÙØ¯Ø© Ø¨Ø³ÙŠØ·Ø© (Nearest neighbour greedy)
     ============================ */
  function orderPathByChain(points){
    if (points.length <= 2) return points;
    const pts = points.slice();
    const ordered = [pts.pop()];
    while (pts.length){
      const last = ordered[ordered.length-1];
      // find nearest
      let minI = 0; let minD = Infinity;
      for (let i=0;i<pts.length;i++){
        const dx = pts[i].x - last.x, dy = pts[i].y - last.y;
        const d = dx*dx + dy*dy;
        if (d < minD) { minD = d; minI = i; }
      }
      ordered.push(pts.splice(minI,1)[0]);
    }
    return ordered;
  }

  /* ============================
     ØªØ¨Ø³ÙŠØ· Ù…Ø³Ø§Ø±: Ramerâ€“Douglasâ€“Peucker
     - ÙŠÙÙ‚Ù„Ù‘Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ù…Ø¹ Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¹Ø§Ù…
     ============================ */
  function simplifyPath(points, epsilon){
    if (points.length < 3) return points;
    const sqr = (a)=>a*a;
    function perpendicularDistance(pt, lineStart, lineEnd){
      const x0 = pt.x, y0 = pt.y;
      const x1 = lineStart.x, y1 = lineStart.y;
      const x2 = lineEnd.x, y2 = lineEnd.y;
      const num = Math.abs((y2-y1)*x0 - (x2-x1)*y0 + x2*y1 - y2*x1);
      const den = Math.hypot(y2-y1, x2-x1);
      return den === 0 ? Math.hypot(x0-x1,y0-y1) : num/den;
    }
    function rdp(pts, eps){
      let dmax = 0, index = 0;
      for (let i=1;i<pts.length-1;i++){
        const d = perpendicularDistance(pts[i], pts[0], pts[pts.length-1]);
        if (d > dmax){ index = i; dmax = d; }
      }
      if (dmax > eps){
        const rec1 = rdp(pts.slice(0,index+1), eps);
        const rec2 = rdp(pts.slice(index), eps);
        return rec1.slice(0,-1).concat(rec2);
      } else {
        return [pts[0], pts[pts.length-1]];
      }
    }
    return rdp(points, epsilon);
  }

  /* ============================
     Ø­Ø³Ø§Ø¨ Ø·ÙˆÙ„ Ø§Ù„Ø­ÙˆØ§Ù (Ø¨ÙƒØ³Ù„)
     ============================ */
  function calculateEdgeLength(paths){
    let total=0;
    for (const p of paths){
      for (let i=1;i<p.length;i++){
        const dx = p[i].x - p[i-1].x, dy = p[i].y - p[i-1].y;
        total += Math.hypot(dx,dy);
      }
    }
    return total;
  }

  /* ============================
     Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªÙˆÙ„ÙŠØ¯ G-code
     - Ù†Ø­Ø³Ø¨ bounding box Ù…Ù† Ù†Ù‚Ø§Ø· Ø§Ù„Ø­ÙˆØ§Ù Ø­ØªÙ‰ Ù„Ø§ Ù†ØºØ§Ø¯Ø± Ø­Ø¯ÙˆØ¯ Ø§Ù„ØªØµÙ…ÙŠÙ…
     - Ù†Ø­Ø³Ø¨ Z Ù…Ù† heightMapData Ù…Ù‚ÙŠÙ‘Ù…Ø© Ø¥Ù„Ù‰ mm Ø¹Ø¨Ø± heightIntensity
     - Ù†Ø³ØªØ®Ø¯Ù… ØªØ¨Ø³ÙŠØ· Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª Ù„ØªÙ‚Ù„ÙŠÙ„ Ù†Ù‚Ø§Ø· G-code Ø§Ù„Ø²Ø§Ø¦Ø¯Ø©
     - Ù†ÙˆÙ„Ù‘Ø¯ G-code Ø¹Ù…Ù„ÙŠ Ù…Ø¹ feed/spindle ÙˆÙ‚ÙŠÙ… Ø¢Ù…Ù†Ø©
     ============================ */
  function generateGcode(){
    if (!edgePaths.length || !heightMapData){ showNotification('Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­ÙˆØ§Ù Ø£ÙˆÙ„Ø§Ù‹',2200); return; }

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¢Ù„Ø© â€” ÙŠÙ…ÙƒÙ† Ø¬Ø¹Ù„Ù‡Ø§ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„ Ù„Ø§Ø­Ù‚Ø§Ù‹
    const unitsPerPixel = 1.0; // mm per pixel â€” Ø§Ø¹ØªÙ…Ø¯Øª 1mm = 1px (ÙŠÙ…ÙƒÙ† ØªØºÙŠÙŠØ± Ø­Ø³Ø¨ Ø§Ù„Ù…Ù‚ÙŠØ§Ø³ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ)
    const feedRate = 1200;   // mm/min
    const plungeFeed = Math.max(100, Math.floor(feedRate/3));
    const spindle = 10000;
    const safeZ = 5; // mm
    const maxCutDepth = 3; // Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ Ù‚Ø·Ø¹ Ø¹Ù…Ù„ÙŠ Ø¨Ø§Ù„Ù€ mm (Ù„Ø§ ØªØºÙŠØ±Ù‡ Ø¯ÙˆÙ† ÙØ­Øµ)
    const zScale = Number(heightIntensity.value || 80); // Ù…Ù‚ÙŠØ§Ø³ Z Ù…Ù† Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©

    // bounding box (Ù†Ø¶Ù…Ù† Ø£Ù„Ø§ Ù†ØªØ­Ø±Ùƒ Ø®Ø§Ø±Ø¬ Ø­Ø¯ÙˆØ¯ Ø§Ù„ØµÙˆØ±Ø©)
    let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
    edgePaths.forEach(path => {
      for (const p of path){
        if (p.x < minX) minX = p.x;
        if (p.x > maxX) maxX = p.x;
        if (p.y < minY) minY = p.y;
        if (p.y > maxY) maxY = p.y;
      }
    });
    // ØªØ­ÙˆÙŠÙ„ Ù„Ù€Ù€ mm
    minX = minX * unitsPerPixel; maxX = maxX * unitsPerPixel;
    minY = minY * unitsPerPixel; maxY = maxY * unitsPerPixel;

    // ØªÙˆÙ„ÙŠØ¯ G-code
    let lines = [];
    lines.push(`; Generated by CNC AI`);
    lines.push(`; Date: ${new Date().toLocaleString()}`);
    lines.push(`G21 ; units mm`);
    lines.push(`G90 ; absolute`);
    lines.push(`G17`);
    lines.push(`F${feedRate}`);
    lines.push(`S${spindle}`);
    lines.push(`M3`);
    lines.push(`G0 Z${safeZ.toFixed(3)}`);

    // Ù†Ø­ÙˆÙ„ ÙƒÙ„ Ù…Ø³Ø§Ø± Path Ø¥Ù„Ù‰ Ø³Ù„Ø³Ù„Ø© Ø£ÙˆØ§Ù…Ø±
    for (let pi=0; pi<edgePaths.length; pi++){
      const path = edgePaths[pi];
      if (!path || path.length < 2) continue;

      // ØªØ¨Ø³ÙŠØ· Ø¥Ø¶Ø§ÙÙŠ Ù„Ù…Ø³Ø§Ø±Ø§Øª Ø·ÙˆÙŠÙ„Ø©
      const precision = (document.getElementById('gcodePrecision').value === 'low') ? 6 :
                        (document.getElementById('gcodePrecision').value === 'medium') ? 3 : 1;
      const simple = simplifyPath(path, precision);

      // Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
      const sx = simple[0].x * unitsPerPixel;
      const sy = simple[0].y * unitsPerPixel;
      // Ø§Ø­Ø±Øµ Ø£Ù† ØªÙƒÙˆÙ† Ø§Ù„Ø­Ø±ÙƒØ© Ø¯Ø§Ø®Ù„ Ø§Ù„Ù€ bounding box
      lines.push(`; Path ${pi+1} points:${simple.length}`);
      lines.push(`G0 X${sx.toFixed(3)} Y${sy.toFixed(3)} Z${safeZ.toFixed(3)}`);

      // Ù†Ø²ÙˆÙ„ ØªØ¯Ø±ÙŠØ¬ÙŠ (Ù†Ø³ØªØ®Ø¯Ù… Ø£Ø¹Ù„Ù‰ Ø§Ø±ØªÙØ§Ø¹ Ù…Ù† Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø¹Ù†Ø¯ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©)
      const startZ_raw = sampleHeightAtPixel(Math.round(simple[0].x), Math.round(simple[0].y));
      const startZ_mm = Math.min(maxCutDepth, (startZ_raw * zScale));
      lines.push(`G1 Z${(-startZ_mm).toFixed(3)} F${plungeFeed}`);

      // Ø§Ù„Ø­Ø±ÙƒØ© Ø¹Ù„Ù‰ Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø§Ø± Ù…Ø¹ Z Ù…Ù† heightmap (interpolate)
      for (let k=1;k<simple.length;k++){
        const pt = simple[k];
        const xmm = pt.x * unitsPerPixel;
        const ymm = pt.y * unitsPerPixel;
        const rawZ = sampleHeightAtPixel(Math.round(pt.x), Math.round(pt.y));
        const zmm = Math.min(maxCutDepth, rawZ * zScale);
        lines.push(`G1 X${xmm.toFixed(3)} Y${ymm.toFixed(3)} Z${(-zmm).toFixed(3)} F${feedRate}`);
      }

      // Ø¥Ø®Ø±Ø§Ø¬ Ù„Ù„Ø£Ø¹Ù„Ù‰ Ø¨Ø¹Ø¯ ÙƒÙ„ Ù…Ø³Ø§Ø±
      lines.push(`G0 Z${safeZ.toFixed(3)}`);
    }

    lines.push(`M5`);
    lines.push(`G0 X0 Y0`);
    lines.push(`M30`);

    lastGcode = lines.join('\n');
    gcodeOutput.value = lastGcode;
    showNotification('ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code Ø¨Ù†Ø¬Ø§Ø­',2500);

    // Ø¹Ø±Ø¶ ToolPath Ø¹Ù„Ù‰ 3D
    drawToolpathOn3D();
  }

  /* ============================
     Ø¹ÙŠÙ‘Ù† Ø¹ÙŠÙ‘ÙÙ†Ø© Z Ù…Ù† heightMapData (Ø¨ØªØ­ÙˆÙŠÙ„ Ù…Ù† Ø¨ÙƒØ³Ù„)
     ============================ */
  function sampleHeightAtPixel(x, y){
    if (!heightMapData) return 0;
    x = Math.max(0, Math.min(originalWidth-1, x));
    y = Math.max(0, Math.min(originalHeight-1, y));
    return heightMapData[y * originalWidth + x] || 0;
  }

  /* ============================
     Ø­ÙØ¸ G-code ÙƒÙ…Ù„Ù
     ============================ */
  function downloadGcode(){
    if (!lastGcode || lastGcode.trim()==='') { showNotification('Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„Ù„Ø­ÙØ¸',1600); return; }
    const blob = new Blob([lastGcode], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'cnc_output.gcode';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
    showNotification('ØªÙ… Ø­ÙØ¸ Ù…Ù„Ù G-code');
  }

  /* ==================================================
     Three.js â€” Ù…Ø¹Ø§ÙŠÙ†Ø© 3D Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
     ================================================== */
  let scene, camera, renderer, mesh, toolpath = null;
  let rotationSpeed = 0.01;
  let zoomLevel = 200;
  let showToolpath = true;

  function initThree(){
    const container = document.getElementById('preview3d');
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0xf0f0f0);
    container.innerHTML = '';
    container.appendChild(renderer.domElement);

    // Ø¥Ø¶Ø§Ø¡Ø©
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(1,1,1);
    scene.add(dirLight);

    // Ø´Ø¨ÙƒØ© Ù…Ø³Ø§Ø¹Ø¯Ø©
    const grid = new THREE.GridHelper(100, 10, 0x888888, 0xcccccc);
    scene.add(grid);

    // ÙƒØ§Ù…ÙŠØ±Ø§
    camera.position.set(0, -zoomLevel/2, zoomLevel/2);
    camera.lookAt(0,0,0);

    // Ø¯ÙˆØ±Ø§Ù† ØªÙ„Ù‚Ø§Ø¦ÙŠ
    function animate(){
      requestAnimationFrame(animate);
      if (mesh) mesh.rotation.y += rotationSpeed;
      renderer.render(scene, camera);
    }
    animate();

    // ØªØ­Ø¬ÙŠÙ… Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
    window.addEventListener('resize', ()=>{
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
  }

  /* ============================
     Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ 3D Ù…Ù† heightMapData
     - Ù†Ø³ØªØ®Ø¯Ù… PlaneGeometry Ù…Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ù‚ÙŠÙ… vertices Z
     - Ù†Ø¶ÙŠÙ Ù„ÙˆÙ†Ø§Ù‹ Ø­Ø³Ø¨ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹
     ============================ */
  function rebuild3D(){
    if (!heightMapData || !scene) return;
    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù€ mesh Ø§Ù„Ù‚Ø¯ÙŠÙ…
    if (mesh) scene.remove(mesh);
    if (toolpath) scene.remove(toolpath);

    const w = originalWidth, h = originalHeight;
    const geometry = new THREE.PlaneGeometry(w, h, w-1, h-1);
    const vertices = geometry.attributes.position.array;
    const zScale = Number(heightIntensity.value || 80);

    // ØªØ¹Ø¯ÙŠÙ„ Z Ù„ÙƒÙ„ vertex
    for (let i=0;i<vertices.length/3;i++){
      const x = Math.round(vertices[i*3] + w/2);
      const y = Math.round(vertices[i*3+1] + h/2);
      if (x>=0 && x<w && y>=0 && y<h){
        const z = heightMapData[y*w + x] * zScale;
        vertices[i*3+2] = z;
      }
    }
    geometry.computeVertexNormals();

    // Ù…Ø§Ø¯Ø© Ù…Ø¹ ØªØ¯Ø±Ø¬ Ù„ÙˆÙ†ÙŠ
    const material = new THREE.MeshLambertMaterial({
      color: 0x4a90e2,
      vertexColors: true,
      wireframe: false,
      side: THREE.DoubleSide
    });

    // vertex colors Ø­Ø³Ø¨ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹
    const colors = [];
    for (let i=0;i<vertices.length/3;i++){
      const z = vertices[i*3+2] / zScale; // normalize
      const c = colorFromJet(z);
      colors.push(c.r/255, c.g/255, c.b/255);
    }
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

    mesh = new THREE.Mesh(geometry, material);
    mesh.rotation.x = -Math.PI/2;
    scene.add(mesh);

    // Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… ToolPath Ø¥Ø°Ø§ ÙƒØ§Ù† Ù…ÙØ¹Ù‘Ù„Ø§Ù‹
    if (showToolpath) drawToolpathOn3D();
  }

  /* ============================
     Ø±Ø³Ù… ToolPath (Ù…Ø³Ø§Ø± Ø§Ù„Ø­ÙˆØ§Ù) Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø´Ù‡Ø¯ 3D
     ============================ */
  function drawToolpathOn3D(){
    if (!scene || !edgePaths.length) return;
    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…
    if (toolpath) scene.remove(toolpath);

    const points = [];
    const colors = [];
    const zScale = Number(heightIntensity.value || 80);

    for (const path of edgePaths){
      for (let i=1;i<path.length;i++){
        const p0 = path[i-1], p1 = path[i];
        const x0 = p0.x - originalWidth/2, y0 = p0.y - originalHeight/2;
        const x1 = p1.x - originalWidth/2, y1 = p1.y - originalHeight/2;
        const z0 = sampleHeightAtPixel(Math.round(p0.x), Math.round(p0.y)) * zScale;
        const z1 = sampleHeightAtPixel(Math.round(p1.x), Math.round(p1.y)) * zScale;

        points.push(x0, z0, y0);
        points.push(x1, z1, y1);
        colors.push(1,0,0, 1,0,0); // Ø£Ø­Ù…Ø±
      }
    }

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    const material = new THREE.LineBasicMaterial({vertexColors: true, linewidth: 2});
    toolpath = new THREE.LineSegments(geometry, material);
    scene.add(toolpath);
  }

  /* ============================
     ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø«
     ============================ */
  function initEvents(){
    // Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª
    grayscaleBtn.addEventListener('click', ()=> applyEnhancement('grayscale'));
    sharpenBtn.addEventListener('click', ()=> applyEnhancement('sharpen'));
    smoothBtn.addEventListener('click', ()=> applyEnhancement('smooth'));
    resetBtn.addEventListener('click', resetImage);

    // Ø´Ø±ÙŠØ· Z
    heightIntensity.addEventListener('input', ()=>{
      heightValue.textContent = heightIntensity.value;
      rebuild3D();
    });

    // Ø´Ø±ÙŠØ· Ø§Ù„Ø³Ø±Ø¹Ø© ÙˆØ§Ù„Ø²ÙˆÙ…
    rotationSpeedInput.addEventListener('input', ()=> rotationSpeed = parseFloat(rotationSpeedInput.value));
    zoomControl.addEventListener('input', ()=>{
      zoomLevel = parseFloat(zoomControl.value);
      camera.position.set(0, -zoomLevel/2, zoomLevel/2);
      camera.lookAt(0,0,0);
    });

    // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø­ÙˆØ§Ù ÙˆG-code
    extractEdgesBtn.addEventListener('click', extractEdges);
    generateGcodeBtn.addEventListener('click', generateGcode);
    downloadGcodeBtn.addEventListener('click', downloadGcode);

    // 3D controls
    toggleToolpathBtn.addEventListener('click', ()=>{
      showToolpath = !showToolpath;
      if (toolpath) toolpath.visible = showToolpath;
      showNotification(showToolpath ? 'ØªÙ… Ø¥Ø¸Ù‡Ø§Ø± Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ø¯Ø§Ø©' : 'ØªÙ… Ø¥Ø®ÙØ§Ø¡ Ù…Ø³Ø§Ø± Ø§Ù„Ø£Ø¯Ø§Ø©');
    });
    rebuild3DBtn.addEventListener('click', rebuild3D);

    // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø«ÙŠÙ… (Ø®ÙÙŠÙ)
    document.getElementById('themeToggle').addEventListener('click', ()=>{
      document.body.classList.toggle('dark');
      showNotification(document.body.classList.contains('dark') ? 'Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ' : 'Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù†Ù‡Ø§Ø±ÙŠ');
    });
  }

  /* ============================
     ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚
     ============================ */
  window.addEventListener('load', ()=>{
    initThree();
    initEvents();
    showNotification('ØªÙ… ØªØ­Ù…ÙŠÙ„ CNC AI Ø¨Ù†Ø¬Ø§Ø­');
  });
  </script>
</body>
</html>
