<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CncAi — 2D → 3D Heightmap (with progress)</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;margin:12px;background:#f4f6fb;color:#111}
    h1{margin:4px 0 10px}
    .layout{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start}
    .panel{background:#fff;padding:10px;border-radius:8px;box-shadow:0 1px 6px rgba(0,0,0,.06)}
    label{display:block;margin-bottom:6px;font-size:14px}
    #origCanvas, #depthCanvas{background:#222;display:block;border:1px solid #ccc}
    #viewer3d{width:640px;height:480px;background:#e9eef6;border:1px solid #cfd8e6}
    #controls{margin-bottom:10px}
    #progressWrap{width:420px;height:14px;background:#eee;border:1px solid #d0d0d0;border-radius:6px;overflow:hidden}
    #progressBar{height:100%;width:0;background:#4caf50}
    button{padding:8px 12px;margin-right:8px;cursor:pointer}
    .muted{font-size:12px;color:#666;margin-top:6px}
    pre#log{max-width:980px;white-space:pre-wrap;font-family:monospace;font-size:12px;color:#333}
  </style>
</head>
<body>
  <h1>CncAi — تحويل صورة إلى ارتفاعات (2D → 3D)</h1>

  <div class="panel" id="controls">
    <label>1) ارفع صورة (يفضل ≤ 512×512 أو أصغر للسرعة)</label>
    <input id="fileInput" type="file" accept="image/*">
    <div style="margin-top:8px">
      <button id="runBtn">ابدأ التحويل</button>
      <button id="resetBtn">إعادة ضبط</button>
    </div>
    <div class="muted">التحويل سيأخذ صورة، يرسم 2D ثم يبني surface 3D. شريط التقدم يوضح سير المعالجة.</div>
    <div style="margin-top:8px" id="progressWrap"><div id="progressBar"></div></div>
  </div>

  <div class="layout" style="margin-top:12px">
    <div class="panel">
      <label>الصورة الأصلية (2D)</label>
      <canvas id="origCanvas" width="420" height="315"></canvas>
    </div>

    <div class="panel">
      <label>خريطة العمق (grayscale)</label>
      <canvas id="depthCanvas" width="420" height="315"></canvas>
    </div>

    <div class="panel" style="flex:1">
      <label>معاينة 3D (heightmap)</label>
      <div id="viewer3d"></div>
    </div>
  </div>

  <pre id="log" class="panel"></pre>

  <!-- three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

  <script>
  // عناصر الواجهة
  const fileInput = document.getElementById('fileInput');
  const runBtn = document.getElementById('runBtn');
  const resetBtn = document.getElementById('resetBtn');
  const origCanvas = document.getElementById('origCanvas');
  const depthCanvas = document.getElementById('depthCanvas');
  const progressBar = document.getElementById('progressBar');
  const logEl = document.getElementById('log');
  const viewer3d = document.getElementById('viewer3d');

  const origCtx = origCanvas.getContext('2d');
  const depthCtx = depthCanvas.getContext('2d');

  function log(...args){ console.log(...args); logEl.textContent += args.join(' ') + '\\n'; }

  // three.js setup
  let scene, camera, renderer, controls, surfaceMesh;
  function initThree(){
    viewer3d.innerHTML = '';
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf2f6fb);

    const W = viewer3d.clientWidth || 640;
    const H = viewer3d.clientHeight || 480;
    camera = new THREE.PerspectiveCamera(45, W/H, 0.1, 5000);
    camera.position.set(0, -Math.max(W,H)*0.8, Math.max(W,H)*0.45);

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(W,H);
    viewer3d.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0,0,0);

    const amb = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(amb);
    const dl = new THREE.DirectionalLight(0xffffff, 0.9);
    dl.position.set(60,80,100);
    scene.add(dl);

    animate();
  }
  function animate(){
    requestAnimationFrame(animate);
    if (controls) controls.update();
    if (renderer && scene && camera) renderer.render(scene, camera);
  }
  initThree();

  // حالة مخزنة
  let loadedImage = null; // original Image object
  let drawnRect = null;   // where image was drawn & size on origCanvas

  fileInput.addEventListener('change', (e)=>{
    logEl.textContent = '';
    const f = e.target.files[0];
    if(!f){ log('لم يتم اختيار ملف'); return; }
    const url = URL.createObjectURL(f);
    const img = new Image();
    img.onload = ()=>{
      loadedImage = img;
      // رسم الصورة داخل origCanvas مع fit
      const W = origCanvas.width, H = origCanvas.height;
      origCtx.clearRect(0,0,W,H);
      const scale = Math.min(W/img.width, H/img.height);
      const dw = Math.round(img.width * scale), dh = Math.round(img.height * scale);
      const dx = Math.round((W-dw)/2), dy = Math.round((H-dh)/2);
      origCtx.drawImage(img, 0,0, img.width, img.height, dx, dy, dw, dh);
      drawnRect = {dx,dy,dw,dh};
      log('Loaded image', img.width+'x'+img.height, 'drawn', dw+'x'+dh);
      // clear depth and 3D
      depthCtx.clearRect(0,0,depthCanvas.width,depthCanvas.height);
      clearSurface();
    };
    img.onerror = ()=> { log('فشل تحميل الصورة'); };
    img.src = url;
  });

  function clearSurface(){
    if(surfaceMesh){
      scene.remove(surfaceMesh);
      surfaceMesh.geometry.dispose();
      surfaceMesh.material.dispose();
      surfaceMesh = null;
    }
  }

  // عملية التحويل: chunked processing لتحديث شريط التقدم وعدم تجميد الواجهة
  async function convertToHeightmap(options = {res:128, scale:40}){
    if(!loadedImage){ log('لا توجد صورة لتحويل'); return; }
    const res = options.res || 128; // resolution for heightmap (square)
    const scale = options.scale || 40;

    // ناجع: نقسم لفحص أسرع بالنسبة للـ 3D، نرسم الصورة في temp canvas بمقاس res x res
    const tmp = document.createElement('canvas');
    tmp.width = res; tmp.height = res;
    const tctx = tmp.getContext('2d');

    // Draw the image centered & fitted into tmp
    const s = Math.min(res/loadedImage.width, res/loadedImage.height);
    const dw = Math.round(loadedImage.width * s), dh = Math.round(loadedImage.height * s);
    const dx = Math.round((res-dw)/2), dy = Math.round((res-dh)/2);
    tctx.fillStyle = '#000'; tctx.fillRect(0,0,res,res);
    tctx.drawImage(loadedImage, 0,0, loadedImage.width, loadedImage.height, dx, dy, dw, dh);

    // get pixel data
    const imgData = tctx.getImageData(0,0,res,res).data;
    const depthArr = new Float32Array(res*res);

    // chunk parameters
    const rows = res;
    const chunkSize = Math.max(1, Math.floor(rows / 40)); // ~40 updates
    let processedRows = 0;

    log('بدء حساب الارتفاعات عند دقة', res, 'x', res);
    // process rows in chunks using setTimeout to keep UI responsive
    await new Promise((resolve)=>{
      function processChunk(){
        const start = processedRows;
        const end = Math.min(rows, start + chunkSize);
        for(let y=start; y<end; y++){
          for(let x=0; x<res; x++){
            const idx = (y*res + x)*4;
            const r = imgData[idx], g = imgData[idx+1], b = imgData[idx+2];
            // luminance
            const lum = 0.2126*r + 0.7152*g + 0.0722*b;
            depthArr[y*res + x] = lum / 255.0; // normalized 0..1
          }
        }
        processedRows = end;
        // update progress bar (percentage)
        progressBar.style.width = Math.round((processedRows / rows) * 100) + '%';

        if(processedRows < rows){
          // schedule next chunk
          setTimeout(processChunk, 0);
        } else {
          resolve();
        }
      }
      setTimeout(processChunk, 0);
    });

    log('اكتملت عملية الحساب — تجهيز نتيجة الخريطة وعرضها');

    // رسم خريطة العمق على depthCanvas (scale up to canvas size)
    const depthImage = depthCtx.createImageData(res, res);
    for(let i=0;i<res*res;i++){
      const v = Math.round(depthArr[i] * 255);
      depthImage.data[i*4 + 0] = v;
      depthImage.data[i*4 + 1] = v;
      depthImage.data[i*4 + 2] = v;
      depthImage.data[i*4 + 3] = 255;
    }
    // draw scaled into visible depthCanvas
    const tmpOut = document.createElement('canvas');
    tmpOut.width = res; tmpOut.height = res;
    tmpOut.getContext('2d').putImageData(depthImage, 0, 0);
    depthCtx.clearRect(0,0,depthCanvas.width, depthCanvas.height);
    depthCtx.drawImage(tmpOut, 0, 0, depthCanvas.width, depthCanvas.height);

    // build 3D surface
    buildSurface(depthArr, res, res, scale);
  }

  // Build Three.js Plane from depth array (w x h)
  function buildSurface(depthArr, w, h, heightScale=40){
    clearSurface();

    // geometry: plane with subdivisions matching depth grid
    const geo = new THREE.PlaneGeometry(w, h, w-1, h-1);
    const pos = geo.attributes.position;
    // set Z for each vertex; note: PlaneGeometry positions laid out row-major
    for(let i=0;i<pos.count;i++){
      const z = depthArr[i] * heightScale;
      pos.setZ(i, z);
    }
    pos.needsUpdate = true;
    geo.computeVertexNormals();

    const mat = new THREE.MeshStandardMaterial({ color:0xdfefff, metalness:0, roughness:0.8, side:THREE.DoubleSide });
    surfaceMesh = new THREE.Mesh(geo, mat);
    // rotate to make Z up and center
    surfaceMesh.rotation.x = -Math.PI/2;
    surfaceMesh.position.set(0,0,0);
    scene.add(surfaceMesh);

    // reposition camera to fit surface nicely
    const larger = Math.max(w,h);
    camera.position.set(0, -larger*0.9, larger*0.6);
    controls.target.set(0,0,0);
    controls.update();
    progressBar.style.width = '100%';
    log('تم إنشاء السطح ثلاثي الأبعاد.');
  }

  // أحداث الأزرار
  runBtn.addEventListener('click', async ()=>{
    logEl.textContent = '';
    if(!loadedImage){ log('رفع صورة أولاً'); return; }
    // use small res by default for speed; you can increase (e.g., 256 or 512) if performance OK
    progressBar.style.width = '0%';
    await convertToHeightmap({res:128, scale:50});
  });

  resetBtn.addEventListener('click', ()=>{
    origCtx.clearRect(0,0,origCanvas.width,origCanvas.height);
    depthCtx.clearRect(0,0,depthCanvas.width,depthCanvas.height);
    fileInput.value = '';
    clearSurface();
    logEl.textContent = 'تم الإعادة';
    progressBar.style.width = '0%';
    loadedImage = null;
  });

  // window resize handling for 3D viewport
  window.addEventListener('resize', ()=>{
    if(!renderer || !camera) return;
    const W = viewer3d.clientWidth, H = viewer3d.clientHeight;
    renderer.setSize(W,H);
    camera.aspect = W/H;
    camera.updateProjectionMatrix();
  });

  </script>
</body>
</html>
