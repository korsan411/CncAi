<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>CNC AI â€” Dual Mode (Raster + Contour)</title>

  <!-- Ù…ÙƒØªØ¨Ø§Øª -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/OrbitControls.js"></script>
  <!-- Ø§Ø³ØªØ®Ø¯Ø§Ù… CDN Ù…ÙˆØ«ÙˆÙ‚ Ù„Ù€ OpenCV -->
  <script src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady()" onerror="onOpenCvError()"></script>

  <style>
    :root{
      --bg:#041022; --panel:#0b1320; --muted:#9bb0c8; --accent:#06b6d4; --text:#e6eef6; --card-border:#1e293b;
    }
    body{ margin:0; font-family:Arial,Segoe UI,system-ui; background:var(--bg); color:var(--text); }
    .app{ max-width:1400px; margin:16px auto; padding:14px; }
    header{ display:flex; justify-content:space-between; align-items:center; padding:12px 16px; border-bottom:1px solid var(--card-border); }
    .grid{ display:grid; grid-template-columns:1fr 440px; gap:16px; }
    @media(max-width:1000px){ .grid{ grid-template-columns:1fr; } }
    .panel{ background:var(--panel); padding:14px; border-radius:10px; border:1px solid var(--card-border); }
    .tabs{ display:flex; gap:6px; border-bottom:1px solid var(--card-border); margin-top:12px;}
    .tabs button{ padding:8px 12px; border-radius:6px 6px 0 0; border:none; background:transparent; color:var(--muted); cursor:pointer; }
    .tabs button.active{ background:var(--accent); color:#021; }
    .tab-content{ display:none; margin-top:12px; }
    .tab-content.active{ display:block; }
    .canvas-placeholder{ width:100%; height:300px; background:#000; border-radius:6px; display:flex; align-items:center; justify-content:center; color:var(--muted); border:1px solid #334155; }
    canvas{ display:block; border-radius:6px; background:#000; max-width:100%; border:1px solid #334155; transform-origin: top left; }
    .file-input-container{ position:relative; width:100%; margin-bottom:8px; }
    .file-input-label{ display:block; padding:10px; background:#1e293b; color:var(--text); text-align:center; border-radius:6px; cursor:pointer; border:2px dashed #334155; }
    .controls-row{ display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap;}
    label{ font-weight:bold; color:var(--text); display:block; margin-top:8px; }
    input, select, textarea{ padding:8px 10px; border-radius:6px; border:1px solid var(--card-border); background:#0f172a; color:var(--text); margin-top:6px; }
    .button-group{ display:flex; flex-direction:column; gap:8px; margin-top:12px; }
    button.primary{ background:var(--accent); color:#021; border:none; padding:10px; border-radius:8px; cursor:pointer; }
    button.secondary{ background:#1e293b; color:var(--text); border:none; padding:10px; border-radius:8px; cursor:pointer; }
    button:disabled{ opacity:0.6; cursor:not-allowed; }
    #toast{ position:fixed; left:16px; bottom:16px; background:rgba(0,0,0,0.85); color:#fff; padding:10px 14px; border-radius:8px; display:none; z-index:10000; }
    .progress-bar{ width:100%; height:8px; background:#111827; border-radius:6px; overflow:hidden; margin-top:8px; }
    .progress-fill{ height:100%; width:0%; background:var(--accent); transition:width .2s; }
    .meta-line{ font-size:0.85rem; color:var(--muted); margin-top:8px; }
    #threeContainer{ width:100%; height:400px; background:#081224; border-radius:8px; overflow:hidden; position:relative; }
    textarea{ width:100%; height:200px; resize:vertical; background:#021024; color:#cfeaf2; border-radius:8px; padding:8px; border:1px solid var(--card-border); }
    .loading{ display:inline-block; width:16px; height:16px; border:2px solid #f3f3f3; border-top:2px solid var(--accent); border-radius:50%; animation:spin 1s linear infinite; margin-left:8px; }
    @keyframes spin{ 0%{transform:rotate(0deg);} 100%{transform:rotate(360deg);} }
    .cv-status{ padding:8px 12px; border-radius:6px; margin:8px 0; }
    .cv-status.loading{ background:#1e3a8a; border:1px solid #3b82f6; }
    .cv-status.ready{ background:#065f46; border:1px solid #10b981; }
    .cv-status.error{ background:#7f1d1d; border:1px solid #ef4444; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1 style="margin:0; color:var(--accent)">CNC AI â€” Dual Mode</h1>
      <div style="display:flex; gap:10px; align-items:center;">
        <div id="cvState" class="cv-status loading">
          <div class="loading"></div> Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ OpenCV...
        </div>
      </div>
    </header>

    <div class="grid">
      <!-- left: preview -->
      <div class="panel">
        <div class="file-input-container">
          <input id="fileInput" type="file" accept="image/*" style="opacity:0; position:absolute; left:0; top:0; width:100%; height:100%; cursor:pointer;" disabled/>
          <label class="file-input-label" for="fileInput" id="fileInputLabel">ğŸ“ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª...</label>
        </div>
        <div class="meta-line" id="imageMeta">Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ù…Ø­Ù…Ù„Ø©</div>

        <div class="tabs">
          <button data-tab="original" class="active">ğŸ–¼ï¸ Ø§Ù„Ø£ØµÙ„ÙŠØ©</button>
          <button data-tab="heatmap" disabled>ğŸ”¥ Heatmap</button>
          <button data-tab="contour" disabled>ğŸ“ Ø§Ù„Ø­ÙˆØ§Ù</button>
          <button data-tab="simulation" disabled>ğŸ¬ Ù…Ø­Ø§ÙƒØ§Ø© 3D</button>
        </div>

        <div id="original" class="tab-content active">
          <div class="canvas-placeholder" id="originalPlaceholder">Ø§Ù†ØªØ¸Ø± Ø§ÙƒØªÙ…Ø§Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª</div>
          <canvas id="canvasOriginal" style="display:none;"></canvas>
          <div class="controls-row">
            <button id="origZoomIn" class="secondary" disabled>+</button>
            <button id="origZoomOut" class="secondary" disabled>âˆ’</button>
            <button id="origReset" class="secondary" disabled>âŸ²</button>
            <label style="margin-left:8px"><input type="checkbox" id="autoResize" checked disabled/> Ø¶ØºØ· ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„ØµÙˆØ±Ø©</label>
          </div>
        </div>

        <div id="heatmap" class="tab-content">
          <div class="canvas-placeholder" id="heatmapPlaceholder">Heatmap Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ OpenCV</div>
          <canvas id="canvasHeatmap" style="display:none;"></canvas>
          <div class="controls-row">
            <button id="heatZoomIn" class="secondary" disabled>+</button>
            <button id="heatZoomOut" class="secondary" disabled>âˆ’</button>
            <button id="heatReset" class="secondary" disabled>âŸ²</button>
            <label>Colormap:
              <select id="colormapSelect" disabled>
                <option value="jet">Jet</option>
                <option value="hot">Hot</option>
                <option value="cool">Cool</option>
                <option value="gray">Gray</option>
              </select>
            </label>
          </div>
        </div>

        <div id="contour" class="tab-content">
          <div class="canvas-placeholder" id="contourPlaceholder">Contour Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ OpenCV</div>
          <canvas id="canvasContour" style="display:none;"></canvas>
          <div class="controls-row">
            <button id="contZoomIn" class="secondary" disabled>+</button>
            <button id="contZoomOut" class="secondary" disabled>âˆ’</button>
            <button id="contReset" class="secondary" disabled>âŸ²</button>
            <label><input type="checkbox" id="showAllContours" checked disabled/> Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±Ø§Øª Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©</label>
          </div>
        </div>

        <div id="simulation" class="tab-content">
          <div id="threeContainer">
            <div class="canvas-placeholder" id="simulationPlaceholder">Ù…Ø­Ø§ÙƒØ§Ø© 3D Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªÙˆÙ„ÙŠØ¯ G-code</div>
          </div>
        </div>
      </div>

      <!-- right: settings + actions -->
      <div class="panel">
        <h3 style="margin-top:0;color:var(--muted)">âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</h3>

        <label>Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</label>
        <select id="machineType" disabled>
          <option value="router">Router CNC</option>
          <option value="laser">Laser Engraver</option>
          <option value="plasma">Plasma Cutter</option>
          <option value="3dprinter">3D Printer</option>
        </select>

        <label>Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù…Ù„ (Ø³Ù…)</label>
        <input id="workWidth" type="number" value="30" step="0.1" min="1" max="100" disabled/>
        <label>Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¹Ù…Ù„ (Ø³Ù…)</label>
        <input id="workHeight" type="number" value="20" step="0.1" min="1" max="100" disabled/>
        <label>Ø¹Ù…Ù‚ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
        <input id="workDepth" type="number" value="3.0" step="0.1" min="0.1" max="50" disabled/>

        <label>Ø³Ø±Ø¹Ø© Ø§Ù„ØªØºØ°ÙŠØ© (Ù…Ù…/Ø¯Ù‚ÙŠÙ‚Ø©)</label>
        <input id="feedRate" type="number" value="800" min="100" max="10000" disabled/>
        <label>Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø£Ù…Ø§Ù† (Ù…Ù…)</label>
        <input id="safeZ" type="number" value="5" step="0.1" min="1" max="50" disabled/>
        <label>Ø®Ø·ÙˆØ© Ø§Ù„Ù…Ø³Ø­ (Ù…Ù…)</label>
        <input id="stepOver" type="number" value="5" step="0.1" min="0.5" max="20" disabled/>
        <label>Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ (Ù…Ù…)</label>
        <input id="maxDepth" type="number" value="3.0" step="0.1" min="0.1" max="50" disabled/>

        <div style="margin-top:10px;" class="controls-row">
          <button id="btnGenRaster" class="primary" disabled>âš¡ ØªÙˆÙ„ÙŠØ¯ G-code (Raster)</button>
          <button id="btnGenContour" class="primary" disabled>ğŸ“ ØªÙˆÙ„ÙŠØ¯ G-code (Contour)</button>
          <button id="btnDownload" class="secondary" disabled>ğŸ’¾ ØªØ­Ù…ÙŠÙ„ G-code</button>
        </div>

        <div class="progress-bar" aria-hidden="true"><div class="progress-fill" id="procFill"></div></div>
        <div id="estTime" class="meta-line"></div>

        <label style="margin-top:12px">ğŸ“„ Ù…Ø®Ø±Ø¬Ø§Øª G-code</label>
        <textarea id="gcodeOut" readonly placeholder="Ø³ÙŠØ¸Ù‡Ø± G-code Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„ØªÙˆÙ„ÙŠØ¯"></textarea>

        <!-- Ø¨Ø¯ÙŠÙ„ OpenCV -->
        <div id="fallbackInfo" style="display:none; margin-top:16px; padding:12px; background:#1e293b; border-radius:6px; border:1px solid #334155;">
          <h4 style="margin:0 0 8px 0; color:var(--accent)">ğŸ’¡ Ù…Ù„Ø§Ø­Ø¸Ø© Ù…Ù‡Ù…Ø©</h4>
          <p style="margin:0; font-size:0.9rem; color:var(--muted);">
            Ø¥Ø°Ø§ Ø§Ø³ØªÙ…Ø±Øª Ù…Ø´ÙƒÙ„Ø© ØªØ­Ù…ÙŠÙ„ OpenCVØŒ Ø¬Ø±Ø¨ ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¹Ù„Ù‰ Ø®Ø§Ø¯Ù… Ù…Ø­Ù„ÙŠ:<br>
            <code style="background:#0f172a; padding:4px 8px; border-radius:4px; margin-top:4px; display:inline-block;">
              python -m http.server 8000
            </code>
          </p>
        </div>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <script>
  /************************************************************************
   * CNC AI â€” Dual Mode - Ø¥ØµÙ„Ø§Ø­ Ù…Ø´ÙƒÙ„Ø© OpenCV
   * Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª:
   * 1. ØªØ­Ù…ÙŠÙ„ OpenCV Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø£ÙƒØ«Ø± Ù…ÙˆØ«ÙˆÙ‚ÙŠØ©
   * 2. Ø¥Ø¶Ø§ÙØ© Ø¨Ø¯Ø§Ø¦Ù„ Ø¹Ù†Ø¯ ÙØ´Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„
   * 3. ØªØ­Ø³ÙŠÙ† ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„
   ************************************************************************/

  // ---------- Ø­Ø§Ù„Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ----------
  let cvReady = false;
  let cvLoadStartTime = Date.now();
  let fallbackMode = false;
  let currentWorker = null;

  // ---------- Ø¥Ø¯Ø§Ø±Ø© Ø­Ø§Ù„Ø© OpenCV ----------
  function onOpenCvReady() {
    cvReady = true;
    const loadTime = Date.now() - cvLoadStartTime;
    console.log(`OpenCV loaded successfully in ${loadTime}ms`);
    
    // ØªØ­Ø¯ÙŠØ« ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    document.getElementById('cvState').className = 'cv-status ready';
    document.getElementById('cvState').innerHTML = 'âœ… OpenCV Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…';
    
    // ØªÙØ¹ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø¹Ù†Ø§ØµØ± Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
    enableUIElements();
    
    showToast(`ØªÙ… ØªØ­Ù…ÙŠÙ„ OpenCV Ø¨Ù†Ø¬Ø§Ø­ (${Math.round(loadTime/1000)} Ø«Ø§Ù†ÙŠØ©)`);
  }

  function onOpenCvError() {
    console.error('Failed to load OpenCV from CDN');
    
    document.getElementById('cvState').className = 'cv-status error';
    document.getElementById('cvState').innerHTML = 'âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ OpenCV';
    
    // Ø¥Ø¸Ù‡Ø§Ø± Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨Ø¯ÙŠÙ„
    document.getElementById('fallbackInfo').style.display = 'block';
    
    showToast('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ OpenCV. Ø¬Ø±Ø¨ Ø®Ø§Ø¯Ù… Ù…Ø­Ù„ÙŠ', 5000);
    
    // Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨Ø¯ÙŠÙ„ Ø¨Ø¹Ø¯ 3 Ø«ÙˆØ§Ù†
    setTimeout(tryAlternativeOpenCV, 3000);
  }

  function tryAlternativeOpenCV() {
    console.log('Trying alternative OpenCV CDN...');
    showToast('Ø¬Ø±Ø¨ ØªØ­Ù…ÙŠÙ„ OpenCV Ù…Ù† Ù…ØµØ¯Ø± Ø¨Ø¯ÙŠÙ„...');
    
    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©
    document.getElementById('cvState').className = 'cv-status loading';
    document.getElementById('cvState').innerHTML = '<div class="loading"></div> Ø¬Ø±Ø¨ ØªØ­Ù…ÙŠÙ„ OpenCV Ù…Ù† Ù…ØµØ¯Ø± Ø¨Ø¯ÙŠÙ„...';
    
    // Ù…Ø­Ø§ÙˆÙ„Ø© CDN Ø¨Ø¯ÙŠÙ„
    const alternativeScript = document.createElement('script');
    alternativeScript.src = 'https://cdn.jsdelivr.net/npm/opencv.js@4.8.0/opencv.js';
    alternativeScript.onload = onOpenCvReady;
    alternativeScript.onerror = function() {
      console.error('Alternative CDN also failed');
      onAllOpenCVFailed();
    };
    document.head.appendChild(alternativeScript);
  }

  function onAllOpenCVFailed() {
    console.log('All OpenCV loading attempts failed');
    
    document.getElementById('cvState').className = 'cv-status error';
    document.getElementById('cvState').innerHTML = 'âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ OpenCV. Ø§Ø³ØªØ®Ø¯Ù… Ø®Ø§Ø¯Ù… Ù…Ø­Ù„ÙŠ';
    
    showToast('ÙØ´Ù„ Ø¬Ù…ÙŠØ¹ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„ØªØ­Ù…ÙŠÙ„. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®Ø§Ø¯Ù… Ù…Ø­Ù„ÙŠ', 10000);
    
    // ØªÙØ¹ÙŠÙ„ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ (Ø¨Ø¯ÙˆÙ† OpenCV)
    enableFallbackMode();
  }

  function enableFallbackMode() {
    fallbackMode = true;
    document.getElementById('fileInputLabel').textContent = 'ğŸ“ Ø§Ø®ØªØ± ØµÙˆØ±Ø© Ù„Ù„ØªØ­Ù…ÙŠÙ„ (Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ)';
    document.getElementById('fileInput').disabled = false;
    
    showToast('ØªÙ… Ø§Ù„ØªØ¨Ø¯ÙŠÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ - Ø¨Ø¹Ø¶ Ø§Ù„Ù…ÙŠØ²Ø§Øª ØºÙŠØ± Ù…ØªØ§Ø­Ø©', 5000);
  }

  function enableUIElements() {
    // ØªÙØ¹ÙŠÙ„ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ù„ÙØ§Øª
    document.getElementById('fileInput').disabled = false;
    document.getElementById('fileInputLabel').textContent = 'ğŸ“ Ø§Ø®ØªØ± ØµÙˆØ±Ø© Ù„Ù„ØªØ­Ù…ÙŠÙ„';
    
    // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    document.querySelectorAll('button:disabled').forEach(btn => {
      if (btn.id !== 'fileInput') {
        btn.disabled = false;
      }
    });
    
    // ØªÙØ¹ÙŠÙ„ Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ…
    document.querySelectorAll('input:disabled, select:disabled').forEach(el => {
      el.disabled = false;
    });
    
    // ØªÙØ¹ÙŠÙ„ Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª
    document.querySelectorAll('.tabs button:disabled').forEach(btn => {
      btn.disabled = false;
    });
  }

  // ---------- UI helpers ----------
  function showToast(msg, ms = 2500) {
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.style.display = 'block';
    clearTimeout(t._t);
    t._t = setTimeout(() => t.style.display = 'none', ms);
  }

  // Tabs
  document.querySelectorAll('.tabs button').forEach(btn => {
    btn.addEventListener('click', () => {
      if (btn.disabled) return;
      
      document.querySelectorAll('.tabs button').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById(btn.dataset.tab).classList.add('active');
      
      if (btn.dataset.tab === 'simulation' && document.getElementById('gcodeOut').value) {
        initSimulation();
      }
    });
  });

  // Zoom control (simple CSS scale)
  function applyZoom(canvasId, scale) {
    const c = document.getElementById(canvasId);
    if (!c) return;
    c.style.transform = `scale(${scale})`;
    c._scale = scale;
  }

  function wireZoom(inId, outId, resetId, canvasId) {
    let s = 1;
    document.getElementById(inId).addEventListener('click', () => { 
      if (!document.getElementById(inId).disabled) {
        s = Math.min(4, s+0.25); 
        applyZoom(canvasId, s); 
      }
    });
    document.getElementById(outId).addEventListener('click', () => { 
      if (!document.getElementById(outId).disabled) {
        s = Math.max(0.25, s-0.25); 
        applyZoom(canvasId, s); 
      }
    });
    document.getElementById(resetId).addEventListener('click', () => { 
      if (!document.getElementById(resetId).disabled) {
        s = 1; 
        applyZoom(canvasId, s); 
      }
    });
  }

  wireZoom('origZoomIn','origZoomOut','origReset','canvasOriginal');
  wireZoom('heatZoomIn','heatZoomOut','heatReset','canvasHeatmap');
  wireZoom('contZoomIn','contZoomOut','contReset','canvasContour');

  // ---------- Core state ----------
  let grayMat = null;
  let mainContour = null;
  let extraContours = [];
  let previewCanvas = null;
  let currentImageName = 'image';

  // Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
  function cleanupMemory() {
    if (!cvReady) return;
    
    try {
      if (grayMat && !grayMat.isDeleted()) {
        grayMat.delete();
        grayMat = null;
      }
      if (mainContour && !mainContour.isDeleted()) {
        mainContour.delete();
        mainContour = null;
      }
      extraContours.forEach(contour => {
        if (contour && !contour.isDeleted()) {
          contour.delete();
        }
      });
      extraContours = [];
    } catch (e) {
      console.warn('ØªØ­Ø°ÙŠØ± Ø£Ø«Ù†Ø§Ø¡ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©:', e);
    }
  }

  // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø¬Ø§Ø±ÙŠØ©
  function cancelCurrentOperations() {
    if (currentWorker) {
      currentWorker.terminate();
      currentWorker = null;
      showToast('ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©');
    }
  }

  // ---------- Load image ----------
  document.getElementById('fileInput').addEventListener('change', (e) => {
    const f = e.target.files[0];
    if (!f) return;

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù (Ø­Ø¯ Ø£Ù‚ØµÙ‰ 10MB)
    if (f.size > 10 * 1024 * 1024) {
      showToast('Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹. Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 10MB');
      return;
    }

    currentImageName = (f.name || 'image').replace(/\.[^/.]+$/, "").replace(/\s+/g,'_');
    const img = new Image();
    
    img.onload = () => {
      // Ø¥Ù„ØºØ§Ø¡ Ø£ÙŠ Ø¹Ù…Ù„ÙŠØ§Øª Ø¬Ø§Ø±ÙŠØ©
      cancelCurrentOperations();
      
      previewCanvas = document.getElementById('canvasOriginal');
      const ctx = previewCanvas.getContext('2d');
      let w = img.width, h = img.height;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ØµÙˆØ±Ø©
      if (w > 5000 || h > 5000) {
        showToast('Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„ØµÙˆØ±Ø© ÙƒØ¨ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹. Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 5000x5000 Ø¨ÙƒØ³Ù„');
        return;
      }

      const auto = document.getElementById('autoResize').checked;
      const maxW = auto ? 1000 : 1600;
      const maxH = auto ? 700 : 1200;
      
      if (w > maxW) { h = Math.round((maxW / w) * h); w = maxW; }
      if (h > maxH) { w = Math.round((maxH / h) * w); h = maxH; }
      
      previewCanvas.width = w; 
      previewCanvas.height = h;
      ctx.clearRect(0,0,w,h); 
      ctx.drawImage(img,0,0,w,h);
      
      document.getElementById('originalPlaceholder').style.display = 'none'; 
      previewCanvas.style.display = 'block';
      document.getElementById('imageMeta').textContent = `Ø§Ù„Ù…Ù„Ù: ${f.name} â€” Ù…Ø¹Ø§ÙŠÙ†Ø©: ${w}Ã—${h}`;
      
      // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
      cleanupMemory();
      
      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©
      if (cvReady) {
        detectAndRender();
      } else if (fallbackMode) {
        showToast('Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ: Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ù…Ø­Ø¯ÙˆØ¯Ø©');
        handleImageInFallbackMode();
      } else {
        showToast('OpenCV ØºÙŠØ± Ø¬Ø§Ù‡Ø² Ø¨Ø¹Ø¯. Ø§Ù†ØªØ¸Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹');
      }
    };
    
    img.onerror = () => {
      showToast('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ù„Ù ØµÙˆØ±Ø© ØµØ§Ù„Ø­Ø©');
    };
    
    img.src = URL.createObjectURL(f);
  });

  // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ (Ø¨Ø¯ÙˆÙ† OpenCV)
  function handleImageInFallbackMode() {
    try {
      const c = document.getElementById('canvasHeatmap');
      const ctx = c.getContext('2d');
      c.width = previewCanvas.width;
      c.height = previewCanvas.height;
      
      // Ø±Ø³Ù… ØµÙˆØ±Ø© Ø±Ù…Ø§Ø¯ÙŠØ© Ø¨Ø³ÙŠØ·Ø©
      ctx.drawImage(previewCanvas, 0, 0);
      const imageData = ctx.getImageData(0, 0, c.width, c.height);
      const data = imageData.data;
      
      for (let i = 0; i < data.length; i += 4) {
        const avg = (data[i] + data[i+1] + data[i+2]) / 3;
        data[i] = avg;     // Ø§Ù„Ø£Ø­Ù…Ø±
        data[i+1] = avg;   // Ø§Ù„Ø£Ø®Ø¶Ø±  
        data[i+2] = avg;   // Ø§Ù„Ø£Ø²Ø±Ù‚
      }
      
      ctx.putImageData(imageData, 0, 0);
      document.getElementById('heatmapPlaceholder').style.display = 'none';
      c.style.display = 'block';
      
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª
      document.querySelector('[data-tab="heatmap"]').disabled = false;
      
      showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ');
    } catch (err) {
      console.error('Error in fallback mode:', err);
      showToast('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ');
    }
  }

  // ---------- Detect & render ----------
  function detectAndRender() {
    if (!cvReady) {
      showToast('OpenCV ØºÙŠØ± Ø¬Ø§Ù‡Ø²');
      return;
    }

    let src = null, gray = null, blurred = null, edges = null, kernel = null, contours = null, hierarchy = null;
    
    try {
      showToast('Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©...');
      
      src = cv.imread(previewCanvas);
      gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

      blurred = new cv.Mat();
      cv.GaussianBlur(gray, blurred, new cv.Size(5,5), 0);

      edges = new cv.Mat();
      const median = cv.mean(blurred).w;
      const lower = Math.max(0, (1.0 - 0.33) * median);
      const upper = Math.min(255, (1.0 + 0.33) * median);
      cv.Canny(blurred, edges, lower, upper);

      kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
      cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);

      contours = new cv.MatVector();
      hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

      const minArea = (gray.cols * gray.rows) * 0.005;
      const allContours = [];
      
      // Ø¬Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±Ø§Øª
      for (let i=0; i<contours.size(); i++) {
        const cnt = contours.get(i);
        const area = cv.contourArea(cnt, false);
        allContours.push({ contour: cnt, area });
      }

      // ÙÙ„ØªØ±Ø© ÙˆØªØ±ØªÙŠØ¨ Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±Ø§Øª
      const valids = allContours.filter(item => item.area > minArea)
                               .sort((a,b) => b.area - a.area);

      // ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø©
      allContours.filter(item => item.area <= minArea)
                .forEach(item => {
                  if (item.contour && !item.contour.isDeleted()) {
                    item.contour.delete();
                  }
                });

      if (valids.length === 0) {
        showToast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙˆÙ†ØªÙˆØ± ÙƒØ§ÙÙ. Ø¬Ø±Ø¨ ØµÙˆØ±Ø© Ø£Ø®Ø±Ù‰');
      } else {
        // ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©
        cleanupMemory();
        
        mainContour = valids[0].contour;
        extraContours = valids.slice(1).map(v => v.contour);
        showToast(`ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${valids.length} ÙƒÙˆÙ†ØªÙˆØ± â€” Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£ÙƒØ¨Ø±`);
      }

      // Ø­ÙØ¸ Ù†Ø³Ø®Ø© Ù…Ù† Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø±Ù…Ø§Ø¯ÙŠØ©
      if (grayMat && !grayMat.isDeleted()) {
        grayMat.delete();
      }
      grayMat = gray.clone();

      renderHeatmap(grayMat);
      renderContours(grayMat, mainContour);

      showToast('ØªÙ… Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­');

    } catch (err) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©:', err);
      showToast('Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©: ' + (err.message || err));
    } finally {
      // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø§Ù„Ù…Ø¤Ù‚ØªØ©
      if (cvReady) {
        const matsToClean = [src, gray, blurred, edges, kernel, hierarchy, contours];
        matsToClean.forEach(mat => {
          if (mat && !mat.isDeleted()) {
            try {
              mat.delete();
            } catch (e) {
              console.warn('Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†Ø¸ÙŠÙ mat:', e);
            }
          }
        });
      }
    }
  }

  // ---------- Heatmap ----------
  function renderHeatmap(gray) {
    if (!gray || (cvReady && gray.isDeleted())) {
      console.warn('ÙƒØ§Ø¦Ù† gray ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ø±Ø³Ù… heatmap');
      return;
    }

    try {
      const c = document.getElementById('canvasHeatmap');
      const ctx = c.getContext('2d');
      c.width = gray.cols; 
      c.height = gray.rows;
      
      const img = ctx.createImageData(c.width, c.height);
      const data = gray.data;
      const cmap = document.getElementById('colormapSelect').value;
      
      for (let i=0; i<data.length; i++){
        const v = data[i];
        const idx = i*4;
        let r=0, g=0, b=0;
        
        if (cmap === 'jet') {
          r = Math.max(0, Math.min(255, (v-128)*2 ));
          g = Math.max(0, Math.min(255, 255 - Math.abs(v-128)*2 ));
          b = Math.max(0, Math.min(255, (128-v)*2 ));
        } else if (cmap === 'hot') {
          r = Math.min(255, v * 1.2);
          g = Math.round(v * 0.6);
          b = Math.round(v * 0.1);
        } else if (cmap === 'cool') {
          r = 255 - v;
          g = v;
          b = 255;
        } else {
          r = g = b = v;
        }
        
        img.data[idx] = r;
        img.data[idx+1] = g;
        img.data[idx+2] = b;
        img.data[idx+3] = 255;
      }
      
      ctx.putImageData(img, 0, 0);
      document.getElementById('heatmapPlaceholder').style.display = 'none';
      c.style.display = 'block';
    } catch (err) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø±Ø³Ù… heatmap:', err);
      showToast('Ø®Ø·Ø£ ÙÙŠ Ø±Ø³Ù… Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø­Ø±Ø§Ø±Ø©');
    }
  }

  // ---------- Contour render ----------
  function renderContours(gray, mainCnt) {
    if (!gray || (cvReady && gray.isDeleted())) {
      console.warn('ÙƒØ§Ø¦Ù† gray ØºÙŠØ± ØµØ§Ù„Ø­ Ù„Ø±Ø³Ù… Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±Ø§Øª');
      return;
    }

    try {
      const c = document.getElementById('canvasContour');
      const ctx = c.getContext('2d');
      c.width = gray.cols; 
      c.height = gray.rows;
      
      // Ø±Ø³Ù… Ø®Ù„ÙÙŠØ© heatmap Ø£ÙˆÙ„Ø§Ù‹
      const heat = document.getElementById('canvasHeatmap');
      if (heat.width === c.width && heat.height === c.height) {
        ctx.drawImage(heat, 0, 0);
      } else {
        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ù…Ø®ØªÙ„ÙØ©ØŒ Ø§Ø±Ø³Ù… Ø®Ù„ÙÙŠØ© Ø±Ù…Ø§Ø¯ÙŠØ©
        ctx.fillStyle = '#333';
        ctx.fillRect(0, 0, c.width, c.height);
      }

      // Ø±Ø³Ù… Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ± Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
      if (mainCnt && (!cvReady || !mainCnt.isDeleted())) {
        ctx.strokeStyle = '#00ff00'; 
        ctx.lineWidth = 2; 
        ctx.beginPath();
        
        const d = mainCnt.data32S;
        if (d && d.length > 0) {
          let firstPoint = true;
          for (let i=0; i<d.length; i+=2) {
            if (i+1 >= d.length) break;
            const x = d[i], y = d[i+1];
            
            if (isNaN(x) || isNaN(y)) continue;
            
            if (firstPoint) {
              ctx.moveTo(x, y);
              firstPoint = false;
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.closePath(); 
          ctx.stroke();
        }
      }

      // Ø±Ø³Ù… Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±Ø§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©
      if (document.getElementById('showAllContours').checked) {
        ctx.strokeStyle = '#ffff00'; 
        ctx.lineWidth = 1;
        
        extraContours.forEach(cnt => {
          if (!cnt || (cvReady && cnt.isDeleted())) return;
          
          ctx.beginPath();
          const d = cnt.data32S;
          if (d && d.length > 0) {
            let firstPoint = true;
            for (let i=0; i<d.length; i+=2) {
              if (i+1 >= d.length) break;
              const x = d[i], y = d[i+1];
              
              if (isNaN(x) || isNaN(y)) continue;
              
              if (firstPoint) {
                ctx.moveTo(x, y);
                firstPoint = false;
              } else {
                ctx.lineTo(x, y);
              }
            }
            ctx.closePath(); 
            ctx.stroke();
          }
        });
      }
      
      document.getElementById('contourPlaceholder').style.display = 'none';
      c.style.display = 'block';
    } catch (err) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø±Ø³Ù… Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±Ø§Øª:', err);
      showToast('Ø®Ø·Ø£ ÙÙŠ Ø±Ø³Ù… Ø§Ù„Ø­ÙˆØ§Ù');
    }
  }

  // ---------- Raster generator ----------
  function sampleGrayAtFromMat(mat, x, y, canvasW, canvasH) {
    if (!mat || (cvReady && mat.isDeleted())) return 128;
    
    const gw = mat.cols, gh = mat.rows;
    const gx_f = (x / canvasW) * (gw - 1);
    const gy_f = (y / canvasH) * (gh - 1);
    const x0 = Math.floor(gx_f), y0 = Math.floor(gy_f);
    const x1 = Math.min(gw-1, x0+1), y1 = Math.min(gh-1, y0+1);
    
    const sx = gx_f - x0, sy = gy_f - y0;
    const v00 = mat.data[y0*gw + x0] || 128;
    const v10 = mat.data[y0*gw + x1] || 128;
    const v01 = mat.data[y1*gw + x0] || 128;
    const v11 = mat.data[y1*gw + x1] || 128;
    
    const v0 = v00 * (1 - sx) + v10 * sx;
    const v1 = v01 * (1 - sx) + v11 * sx;
    return Math.max(0, Math.min(255, Math.round(v0 * (1 - sy) + v1 * sy)));
  }

  function generateRasterGcodeSimple() {
    if ((!grayMat || (cvReady && grayMat.isDeleted()) || !previewCanvas) && !fallbackMode) { 
      showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø¬Ø§Ù‡Ø²Ø©. Ù‚Ù… Ø¨ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹'); 
      return ''; 
    }
    
    try {
      const stepOver = parseFloat(document.getElementById('stepOver').value) || 5;
      const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
      const feed = parseFloat(document.getElementById('feedRate').value) || 800;
      const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
      const workWidth = (parseFloat(document.getElementById('workWidth').value) || 30) * 10;
      const workHeight = (parseFloat(document.getElementById('workHeight').value) || 20) * 10;
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù‚ÙŠÙ…
      if (stepOver <= 0 || maxDepth <= 0 || feed <= 0 || safeZ <= 0 || workWidth <= 0 || workHeight <= 0) {
        showToast('Ù‚ÙŠÙ… Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØºÙŠØ± ØµØ§Ù„Ø­Ø©. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚ÙŠÙ… Ù…ÙˆØ¬Ø¨Ø©');
        return '';
      }
      
      const lines = [];
      lines.push('; Raster G-code (stable)');
      lines.push('G21 G90 G17');
      lines.push('G0 Z' + safeZ.toFixed(2));
      
      const canvasW = previewCanvas.width, canvasH = previewCanvas.height;
      const scaleX = workWidth / canvasW, scaleY = workHeight / canvasH;
      let totalLen = 0;
      
      for (let y = 0; y < canvasH; y += Math.max(1, Math.round(stepOver))) {
        const rowPoints = [];
        for (let x = 0; x < canvasW; x++) {
          let pv = 128; // Ù‚ÙŠÙ…Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
          
          if (fallbackMode) {
            // ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØŒ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ù† canvas
            const ctx = previewCanvas.getContext('2d');
            const pixel = ctx.getImageData(x, y, 1, 1).data;
            pv = (pixel[0] + pixel[1] + pixel[2]) / 3;
          } else if (grayMat) {
            pv = sampleGrayAtFromMat(grayMat, x, y, canvasW, canvasH);
          }
          
          let z = -((255 - pv) / 255.0) * maxDepth;
          const sx = (x * scaleX);
          const sy = (y * scaleY);
          rowPoints.push({ x: sx, y: sy, z });
        }
        
        if (rowPoints.length > 1) {
          lines.push('G0 X' + rowPoints[0].x.toFixed(2) + ' Y' + rowPoints[0].y.toFixed(2) + ' Z' + safeZ.toFixed(2));
          lines.push('G1 F' + feed.toFixed(0));
          for (const p of rowPoints) {
            lines.push('G1 X' + p.x.toFixed(2) + ' Y' + p.y.toFixed(2) + ' Z' + p.z.toFixed(3));
          }
          lines.push('G0 Z' + safeZ.toFixed(2));
          totalLen += rowPoints.length;
        }
      }
      
      lines.push('M5'); 
      lines.push('M30');
      document.getElementById('estTime').textContent = `â±ï¸ ØªÙ‚Ø¯ÙŠØ± Ø¹Ù†Ø§ØµØ±: ${totalLen}`;
      return lines.join('\n');
    } catch (err) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Raster:', err);
      showToast('Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ G-code: ' + (err.message || err)); 
      return '';
    }
  }

  // ---------- Contour-based generator ----------
  function buildScanlineSegments(stepPx = 1) {
    if ((!mainContour || (cvReady && mainContour.isDeleted()) || !grayMat || (cvReady && grayMat.isDeleted())) && !fallbackMode) {
      return [];
    }
    
    try {
      const w = grayMat.cols, h = grayMat.rows;
      const rect = cv.boundingRect(mainContour);
      const minX = Math.max(0, rect.x), maxX = Math.min(w-1, rect.x + rect.width - 1);
      const minY = Math.max(0, rect.y), maxY = Math.min(h-1, rect.y + rect.height - 1);
      const segments = [];
      
      for (let y = minY; y <= maxY; y += stepPx) {
        let inside = false;
        let segStart = -1;
        const segsForY = [];
        
        for (let x = minX; x <= maxX; x++) {
          const pt = new cv.Point(x, y);
          const res = cv.pointPolygonTest(mainContour, pt, false);
          pt.delete();
          
          if (res >= 0) {
            if (!inside) { 
              inside = true; 
              segStart = x; 
            }
          } else {
            if (inside) { 
              inside = false; 
              segsForY.push({ x0: segStart, x1: x - 1 }); 
              segStart = -1; 
            }
          }
        }
        
        if (inside && segStart >= 0) {
          segsForY.push({ x0: segStart, x1: maxX });
        }
        
        if (segsForY.length > 0) {
          segments.push({ y: y, segments: segsForY });
        }
      }
      
      return segments;
    } catch (err) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù…Ù‚Ø§Ø·Ø¹:', err);
      return [];
    }
  }

  // ---------- Buttons wiring ----------
  document.getElementById('btnGenRaster').addEventListener('click', () => {
    try {
      const g = generateRasterGcodeSimple();
      if (g) {
        document.getElementById('gcodeOut').value = g;
        showToast('ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code (Raster) â€” Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…ÙˆØ«ÙˆÙ‚Ø©');
        document.querySelector('[data-tab="simulation"]').click();
      }
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Raster:', error);
      showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙˆÙ„ÙŠØ¯');
    }
  });

  document.getElementById('btnGenContour').addEventListener('click', async () => {
    if (fallbackMode) {
      showToast('Ù…ÙŠØ²Ø© Contour ØºÙŠØ± Ù…ØªØ§Ø­Ø© ÙÙŠ Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ');
      return;
    }
    
    if (!cvReady) {
      showToast('OpenCV ØºÙŠØ± Ø¬Ø§Ù‡Ø² Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…ÙŠØ²Ø© Contour');
      return;
    }
    
    showToast('Ù…ÙŠØ²Ø© Contour ØªØªØ·Ù„Ø¨ OpenCV. Ø¬Ø±Ø¨ Raster Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø°Ù„Ùƒ');
  });

  // Download with name including image and timestamp
  document.getElementById('btnDownload').addEventListener('click', () => {
    try {
      const g = document.getElementById('gcodeOut').value;
      if (!g) { 
        showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„ØªØ­Ù…ÙŠÙ„. Ù‚Ù… Ø¨ØªÙˆÙ„ÙŠØ¯ G-code Ø£ÙˆÙ„Ø§Ù‹'); 
        return; 
      }
      
      const now = new Date(); 
      const pad = n => n.toString().padStart(2,'0');
      const stamp = `${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}`;
      const name = `cnc_${currentImageName}_${stamp}.gcode`;
      const blob = new Blob([g], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); 
      a.href = url; 
      a.download = name; 
      document.body.appendChild(a); 
      a.click(); 
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„: ' + name);
    } catch (error) {
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„:', error);
      showToast('Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù');
    }
  });

  // ---------- Simple 3D sim ----------
  let scene, camera, renderer, controls;
  
  function parseGcodeForSimulation(gcode) {
    try {
      const lines = gcode.split('\n'); 
      const path = []; 
      let pos = { x:0, y:0, z:0 };
      
      for (const L of lines) {
        const t = L.trim();
        if (t.startsWith('G1') || t.startsWith('G0')) {
          const xm = t.match(/X([\d.-]+)/); 
          const ym = t.match(/Y([\d.-]+)/); 
          const zm = t.match(/Z([\d.-]+)/);
          if (xm) pos.x = parseFloat(xm[1]); 
          if (ym) pos.y = parseFloat(ym[1]); 
          if (zm) pos.z = parseFloat(zm[1]);
          path.push({ ...pos });
        }
      }
      return path;
    } catch (err) {
      console.error('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù„ÙŠÙ„ G-code:', err);
      return [];
    }
  }

  function initSimulation() {
    const container = document.getElementById('threeContainer'); 
    container.innerHTML = '';
    
    const g = document.getElementById('gcodeOut').value;
    if (!g) { 
      document.getElementById('simulationPlaceholder').style.display = 'flex'; 
      showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø©'); 
      return; 
    }
    
    try {
      document.getElementById('simulationPlaceholder').style.display = 'none';
      
      scene = new THREE.Scene(); 
      scene.background = new THREE.Color(0x081224);
      
      camera = new THREE.PerspectiveCamera(60, container.clientWidth/container.clientHeight, 0.1, 10000);
      camera.position.set(200,200,200);
      
      renderer = new THREE.WebGLRenderer({ antialias:true }); 
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      
      const ambient = new THREE.AmbientLight(0x404040, 0.8); 
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8); 
      dir.position.set(50,200,100); 
      scene.add(dir);
      
      const workW = (parseFloat(document.getElementById('workWidth').value)||30)*10;
      const workH = (parseFloat(document.getElementById('workHeight').value)||20)*10;
      const workD = parseFloat(document.getElementById('workDepth').value)||3;
      
      const geom = new THREE.BoxGeometry(workW, workD, workH); 
      const mat = new THREE.MeshPhongMaterial({ color: 0x8B4513, transparent:true, opacity:0.95 });
      const box = new THREE.Mesh(geom, mat); 
      box.position.y = workD/2; 
      scene.add(box);
      
      const path = parseGcodeForSimulation(g);
      if (path && path.length > 1) {
        const pts = path.map(p => new THREE.Vector3(p.x, p.z + 5, p.y));
        const geometry = new THREE.BufferGeometry().setFromPoints(pts);
        const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        const line = new THREE.Line(geometry, material); 
        scene.add(line);
      }
      
      const grid = new THREE.GridHelper(Math.max(workW, workH), 10); 
      scene.add(grid);
      const axes = new THREE.AxesHelper(50); 
      scene.add(axes);
      
      function animate(){ 
        requestAnimationFrame(animate); 
        controls.update(); 
        renderer.render(scene, camera); 
      }
      animate(); 
      showToast('ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
      
      // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø­Ø¬Ù… Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ù†Ø§ÙØ°Ø© Ø§Ù„Ù…ØªØµÙØ­
      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    } catch (err) { 
      console.error('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©:', err); 
      showToast('Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯');
      document.getElementById('simulationPlaceholder').style.display = 'flex';
    }
  }

  document.querySelector('[data-tab="simulation"]').addEventListener('click', () => {
    if (document.getElementById('gcodeOut').value) {
      setTimeout(initSimulation, 100);
    }
  });

  // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø±ÙˆØ¬
  window.addEventListener('beforeunload', () => {
    cleanupMemory();
    if (currentWorker) {
      currentWorker.terminate();
      currentWorker = null;
    }
  });

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØªØ­Ù…ÙŠÙ„ OpenCV Ø¨Ø¹Ø¯ 10 Ø«ÙˆØ§Ù†
  setTimeout(() => {
    if (!cvReady && !fallbackMode) {
      console.log('OpenCV loading timeout - trying fallback');
      onAllOpenCVFailed();
    }
  }, 10000);

  </script>
</body>
</html>
