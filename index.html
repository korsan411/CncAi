<!DOCTYPE html><html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CNC AI - Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Ù…Ø­Ø³Ù‘Ù†)</title>
  <style>
    :root{--bg:#f6f7fb;--panel:#fff;--accent:#1f6feb}
    body{font-family:Arial, Helvetica, sans-serif;background:var(--bg);color:#222;margin:0;padding:0}
    header{background:#222;color:#fff;padding:14px 18px;font-size:1.15rem;text-align:center}
    .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center;padding:12px;background:var(--panel);border-bottom:1px solid #e3e6ee}
    .controls > *{margin:4px}
    button,input[type=range],select{padding:8px 12px;border-radius:6px;border:1px solid #ccc;background:var(--accent);color:#fff;cursor:pointer}
    input[type=checkbox]{width:18px;height:18px}
    label{margin-inline:6px}
    .flex-row{display:flex;gap:12px;align-items:center}
    .container{display:grid;grid-template-columns:1fr 1fr;gap:16px;padding:16px;max-width:1200px;margin:12px auto}
    .panel{background:var(--panel);padding:12px;border-radius:8px;box-shadow:0 1px 4px rgba(0,0,0,.06)}
    canvas{width:100%;height:auto;border:1px solid #ddd;display:block}
    #threeContainer{width:100%;height:500px}
    .small{font-size:0.9rem}
    footer{font-size:0.85rem;color:#555;text-align:center;padding:14px}
    @media(max-width:900px){.container{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <header>ğŸ› ï¸ CNC AI - Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Ù…Ø­Ø³Ù‘Ù† - ØªØµØ­ÙŠØ­ Ø§Ù„Ø­ÙˆØ§Ù ÙˆØ§Ù„Ø§ØªØ¬Ø§Ù‡)</header>  <div class="controls">
    <input type="file" id="fileInput" accept="image/*" /><div class="flex-row small">
  <label for="maxDepth">Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ (Ù…Ù…)</label>
  <input type="range" id="maxDepth" min="0.5" max="20" step="0.1" value="5" />
  <span id="maxDepthValue">5</span>
</div>

<div class="flex-row small">
  <label for="meshRes">Ø¯Ù‚Ø© Ø§Ù„Ù€ 3D (Ù…Ø±Ø¨Ø¹Ø§Øª)</label>
  <input type="range" id="meshRes" min="16" max="512" step="1" value="200" />
  <span id="meshResValue">200</span>
</div>

<div class="flex-row small">
  <label for="edgeThreshold">Ø¹ØªØ¨Ø© Ø§Ù„Ø­ÙˆØ§Ù</label>
  <input type="range" id="edgeThreshold" min="0" max="255" step="1" value="40" />
  <span id="edgeThresholdValue">40</span>
</div>

<div class="flex-row small">
  <label for="mmPerPixel">Ù…Ù…/Ø¨ÙƒØ³Ù„</label>
  <input type="number" id="mmPerPixel" step="0.1" value="0.5" style="width:80px;padding:6px;border-radius:6px;border:1px solid #ccc" />
</div>

<div class="flex-row small">
  <label><input type="checkbox" id="invertZ" /> Ø§Ù†Ø¹ÙƒØ§Ø³ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ (Ø¥Ø°Ø§ Ø¸Ù‡Ø± Ù…Ù‚Ù„ÙˆØ¨)</label>
  <label><input type="checkbox" id="flipY" /> Ù‚Ù„Ø¨ Ù…Ø­ÙˆØ± Y (Ù„Ù€ G-code)</label>
</div>

<button id="btnProcess">Ù…Ø¹Ø§Ù„Ø¬Ø© ÙˆØ¥Ø¸Ù‡Ø§Ø± Heatmap & Ø§Ù„Ø­ÙˆØ§Ù</button>
<button id="btnPreview3D">Ù…Ø¹Ø§ÙŠÙ†Ø© 3D</button>
<button id="btnGcode">ØªÙˆÙ„ÙŠØ¯ G-code</button>

  </div>  <div class="container">
    <div class="panel">
      <h3>Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</h3>
      <canvas id="canvasOriginal"></canvas>
    </div><div class="panel">
  <h3>Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª (Heatmap)</h3>
  <canvas id="canvasHeightmap"></canvas>
</div>

<div class="panel">
  <h3>Ø§Ù„Ø­ÙˆØ§Ù (Edges)</h3>
  <canvas id="canvasEdges"></canvas>
</div>

<div class="panel">
  <h3>Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</h3>
  <div id="threeContainer"></div>
</div>

  </div>  <footer class="small">Ù…Ù„Ø§Ø­Ø¸Ø©: Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„ØµÙˆØ±Ø© ÙƒØ¨ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹ Ø³ÙŠØ¬Ø±ÙŠ Ø¶ØºØ·Ù‡Ø§ Ù…Ø¤Ù‚ØªØ§Ù‹ Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ù„ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ø£Ø¯Ø§Ø¡ (ÙŠÙ…ÙƒÙ† ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¯Ù‚Ø© Ù…Ù† Ø´Ø±ÙŠØ· Ø¯Ù‚Ø© 3D).</footer>  <!-- three.js Ùˆ OrbitControls -->  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>  <script>
    // Ø¹Ù†Ø§ØµØ± DOM
    const fileInput = document.getElementById('fileInput');
    const canvasOriginal = document.getElementById('canvasOriginal');
    const ctxOriginal = canvasOriginal.getContext('2d');
    const canvasHeightmap = document.getElementById('canvasHeightmap');
    const ctxHeightmap = canvasHeightmap.getContext('2d');
    const canvasEdges = document.getElementById('canvasEdges');
    const ctxEdges = canvasEdges.getContext('2d');

    const maxDepthSlider = document.getElementById('maxDepth');
    const maxDepthValue = document.getElementById('maxDepthValue');
    const meshResSlider = document.getElementById('meshRes');
    const meshResValue = document.getElementById('meshResValue');
    const edgeThreshold = document.getElementById('edgeThreshold');
    const edgeThresholdValue = document.getElementById('edgeThresholdValue');

    const mmPerPixelInput = document.getElementById('mmPerPixel');
    const invertZChk = document.getElementById('invertZ');
    const flipYChk = document.getElementById('flipY');

    const btnProcess = document.getElementById('btnProcess');
    const btnPreview3D = document.getElementById('btnPreview3D');
    const btnGcode = document.getElementById('btnGcode');

    // Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØµÙˆØ±Ø© ÙˆØ§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©
    let imgWidth = 0, imgHeight = 0;
    let procWidth = 0, procHeight = 0; // Ø­Ø¬Ù… Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (Ù…Ù…ÙƒÙ† Ù…ØµØºØ±)
    let rawImageData = null; // ImageData Ù…Ù† Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ Ø§Ù„Ø£ØµÙ„ÙŠ
    let grayData = null; // Float32Array
    let blurred = null; // Float32Array
    let edges = null; // Float32Array
    let heightMap = null; // Float32Array (0..1)

    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    const MAX_PROC_SIZE = 1200; // Ø£Ù‚ØµÙ‰ Ø¨Ø¹Ø¯ Ù„Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (Ù„ØªØ¬Ù†Ø¨ Ø¨Ø·Ø¡ Ø§Ù„Ù…ØªØµÙØ­)

    // ØªØ­Ø¯ÙŠØ«Ø§Øª ÙˆØ§Ø¬Ù‡Ø©
    maxDepthSlider.addEventListener('input', () => { maxDepthValue.textContent = maxDepthSlider.value; });
    meshResSlider.addEventListener('input', () => { meshResValue.textContent = meshResSlider.value; });
    edgeThreshold.addEventListener('input', () => { edgeThresholdValue.textContent = edgeThreshold.value; });

    // ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const img = new Image();
        img.onload = () => {
          imgWidth = img.width;
          imgHeight = img.height;

          // Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ø¨Ø­Ø¬Ù…Ù‡Ø§ (Ø£Ùˆ Ù…ØµØºØ±Ø© Ù„ÙŠØªÙ†Ø§Ø³Ø¨ Ù…Ø¹ Ø§Ù„Ø´Ø§Ø´Ø©)
          canvasOriginal.width = imgWidth;
          canvasOriginal.height = imgHeight;
          ctxOriginal.clearRect(0,0,canvasOriginal.width, canvasOriginal.height);
          ctxOriginal.drawImage(img, 0, 0, imgWidth, imgHeight);

          rawImageData = ctxOriginal.getImageData(0,0, imgWidth, imgHeight);

          // Ù…Ø³Ø­ Ù†ØªØ§Ø¦Ø¬ Ø³Ø§Ø¨Ù‚Ø©
          ctxHeightmap.clearRect(0,0,canvasHeightmap.width, canvasHeightmap.height);
          ctxEdges.clearRect(0,0,canvasEdges.width, canvasEdges.height);

          // Ø§ÙØªØ±Ø§Ø¶ÙŠ: process Ø¹Ù†Ø¯ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø®ÙÙŠÙ Ø£Ùˆ Ø¨Ø§Ù„Ø²Ø±
          // Ù„Ø§ Ù†Ø¹Ø§Ù„Ø¬ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ù„ØªÙØ§Ø¯ÙŠ Ø«Ù‚Ù„
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    });

    // ---------- Ù…Ø¹Ø§Ù„Ø¬Ø©: grayscale, blur, sobel, combine ----------
    function prepareProcessing() {
      if (!rawImageData) { alert('âš ï¸ Ø§Ø±ÙØ¹ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹'); return false; }

      // ØªØ­Ø¯ÙŠØ¯ Ø­Ø¬Ù… Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© (Ù…ØµØºØ± Ø¥Ù† ÙƒØ§Ù†Øª Ø§Ù„ØµÙˆØ±Ø© ÙƒØ¨ÙŠØ±Ø©)
      const scale = Math.min(1, MAX_PROC_SIZE / Math.max(imgWidth, imgHeight));
      procWidth = Math.max(1, Math.floor(imgWidth * scale));
      procHeight = Math.max(1, Math.floor(imgHeight * scale));

      // Ø±Ø³Ù… Ø¹Ù„Ù‰ ÙƒØ§Ù†ÙØ§Ø³ Ù…Ø¤Ù‚Øª
      const off = document.createElement('canvas');
      off.width = procWidth; off.height = procHeight;
      const octx = off.getContext('2d');
      octx.drawImage(canvasOriginal, 0, 0, imgWidth, imgHeight, 0,0, procWidth, procHeight);
      const id = octx.getImageData(0,0, procWidth, procHeight);

      // grayscale
      grayData = new Float32Array(procWidth * procHeight);
      for (let i=0, j=0; i<id.data.length; i+=4, j++){
        const r=id.data[i], g=id.data[i+1], b=id.data[i+2];
        grayData[j] = 0.299*r + 0.587*g + 0.114*b;
      }

      // Gaussian blur (5x5 separable would be faster; simple 5x5 conv used)
      blurred = gaussianBlur(grayData, procWidth, procHeight);

      // Sobel edges
      edges = sobel(blurred, procWidth, procHeight);

      // Build heightMap: combine blurred + edgesBoost
      const edgeBoost = 1.5; // Ù…Ø¹Ø§Ù…Ù„ Ø¥Ø¨Ø±Ø§Ø² Ø§Ù„Ø­ÙˆØ§Ù
      heightMap = new Float32Array(procWidth * procHeight);
      let min=Infinity, max=-Infinity;
      for (let i=0; i<heightMap.length; i++){
        const val = blurred[i] + edges[i]*edgeBoost;
        heightMap[i] = val;
        if (val<min) min=val;
        if (val>max) max=val;
      }
      // normalize 0..1
      const denom = (max - min) || 1;
      for (let i=0; i<heightMap.length; i++) heightMap[i] = (heightMap[i] - min)/denom;

      // Ø±Ø³Ù… heatmap ÙˆØ§Ù„Ø­ÙˆØ§Ù Ø¹Ù„Ù‰ ÙƒØ§Ù†ÙØ§Ø³Ø§Øª Ø§Ù„Ø¹Ø±Ø¶
      drawHeatmap();
      drawEdges();

      return true;
    }

    // Gaussian blur (5x5)
    function gaussianBlur(src, w, h){
      const kernel = [
        [1,4,7,4,1],
        [4,16,26,16,4],
        [7,26,41,26,7],
        [4,16,26,16,4],
        [1,4,7,4,1]
      ];
      const weight = 273;
      const out = new Float32Array(w*h);
      for (let y=2; y<h-2; y++){
        for (let x=2; x<w-2; x++){
          let sum=0;
          for (let ky=-2; ky<=2; ky++){
            for (let kx=-2; kx<=2; kx++){
              sum += src[(y+ky)*w + (x+kx)] * kernel[ky+2][kx+2];
            }
          }
          out[y*w + x] = sum/weight;
        }
      }
      // edges fill border by copying
      for (let x=0;x<w;x++){ out[x]=src[x]; out[(h-1)*w + x]=src[(h-1)*w + x]; }
      for (let y=0;y<h;y++){ out[y*w]=src[y*w]; out[y*w + (w-1)] = src[y*w + (w-1)]; }
      return out;
    }

    // Sobel edge detector
    function sobel(src, w, h){
      const out = new Float32Array(w*h);
      for (let y=1; y<h-1; y++){
        for (let x=1; x<w-1; x++){
          const a = src[(y-1)*w + (x-1)];
          const b = src[(y-1)*w + x];
          const c = src[(y-1)*w + (x+1)];
          const d = src[y*w + (x-1)];
          const e = src[y*w + x];
          const f = src[y*w + (x+1)];
          const g = src[(y+1)*w + (x-1)];
          const h2 = src[(y+1)*w + x];
          const i = src[(y+1)*w + (x+1)];

          const gx = (c + 2*f + i) - (a + 2*d + g);
          const gy = (g + 2*h2 + i) - (a + 2*b + c);
          out[y*w + x] = Math.sqrt(gx*gx + gy*gy);
        }
      }
      return out;
    }

    // Heatmap renderer (uses simple color ramp)
    function drawHeatmap(){
      canvasHeightmap.width = procWidth;
      canvasHeightmap.height = procHeight;
      const img = ctxHeightmap.createImageData(procWidth, procHeight);
      for (let i=0; i<heightMap.length; i++){
        const v = heightMap[i];
        const col = heatColor(v);
        img.data[i*4] = col.r;
        img.data[i*4+1] = col.g;
        img.data[i*4+2] = col.b;
        img.data[i*4+3] = 255;
      }
      // scale up to display original image size while keeping aspect
      const display = document.createElement('canvas');
      display.width = imgWidth; display.height = imgHeight;
      const dctx = display.getContext('2d');
      dctx.putImageData(img, 0, 0);
      // draw scaled to full size so user sees it
      ctxHeightmap.clearRect(0,0,canvasHeightmap.width, canvasHeightmap.height);
      canvasHeightmap.width = imgWidth; canvasHeightmap.height = imgHeight;
      ctxHeightmap.drawImage(display, 0, 0, imgWidth, imgHeight);
    }

    function heatColor(t){
      // jet-like ramp: blue->cyan->yellow->red
      const r = Math.floor(255 * Math.max(0, Math.min(1, 1.5*(t-0.66))));
      const g = Math.floor(255 * Math.max(0, Math.min(1, 1.5*(1 - Math.abs(t-0.5)))));
      const b = Math.floor(255 * Math.max(0, Math.min(1, 1.5*(0.66 - t))));
      return {r,g,b};
    }

    function drawEdges(){
      canvasEdges.width = procWidth; canvasEdges.height = procHeight;
      const img = ctxEdges.createImageData(procWidth, procHeight);
      const thr = parseInt(edgeThreshold.value,10);
      for (let i=0;i<edges.length;i++){
        const v = edges[i];
        const bw = v>thr ? 255 : 0;
        img.data[i*4] = bw; img.data[i*4+1] = bw; img.data[i*4+2] = bw; img.data[i*4+3] = 255;
      }
      // scale up for display
      const display = document.createElement('canvas'); display.width = procWidth; display.height = procHeight;
      display.getContext('2d').putImageData(img,0,0);
      canvasEdges.width = imgWidth; canvasEdges.height = imgHeight;
      ctxEdges.clearRect(0,0,canvasEdges.width, canvasEdges.height);
      ctxEdges.drawImage(display, 0,0, imgWidth, imgHeight);
    }

    // ---------- 3D Preview ----------
    let threeScene, threeCamera, threeRenderer, threeControls, threeMesh, threeLight;
    function preview3D(){
      if (!heightMap) { alert('âœ… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "Ù…Ø¹Ø§Ù„Ø¬Ø©" Ø£ÙˆÙ„Ø§Ù‹ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª'); return; }

      // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø´Ù‡Ø¯ sekali
      if (!threeRenderer){
        threeScene = new THREE.Scene();
        threeRenderer = new THREE.WebGLRenderer({antialias:true});
        threeRenderer.setPixelRatio(window.devicePixelRatio || 1);
        threeRenderer.setSize(document.getElementById('threeContainer').clientWidth, document.getElementById('threeContainer').clientHeight);
        document.getElementById('threeContainer').innerHTML='';
        document.getElementById('threeContainer').appendChild(threeRenderer.domElement);
        threeCamera = new THREE.PerspectiveCamera(45, document.getElementById('threeContainer').clientWidth / document.getElementById('threeContainer').clientHeight, 0.1, 10000);
        threeControls = new THREE.OrbitControls(threeCamera, threeRenderer.domElement);
        threeControls.enableDamping = true;

        threeLight = new THREE.DirectionalLight(0xffffff, 1);
        threeLight.position.set(100,100,200);
        threeScene.add(threeLight);
        threeScene.add(new THREE.AmbientLight(0x888888));
      }

      // Ø­Ø¯Ø¯ Ø¯Ù‚Ø© Ø§Ù„Ø´Ø¨ÙƒØ© Ù„Ù…Ø´Ø§Ù‡Ø¯ 3D
      const res = parseInt(meshResSlider.value,10);
      const cols = res; const rows = Math.round(res * (procHeight/procWidth));

      // plane size Ù†Ø¹Ø·ÙŠÙ‡ Ù†Ø³Ø¨Ø© Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ù†Ø³Ø¨Ø©
      const planeW = procWidth; const planeH = procHeight;

      // Ø¥Ù†Ø´Ø§Ø¡ Ù‡Ù†Ø¯Ø³Ø© Ø¨Ù…Ø³ØªÙˆÙ‰ (centered)
      const geometry = new THREE.PlaneGeometry(planeW, planeH, cols-1, rows-1);

      // ØªÙˆÙ„ÙŠØ¯ texture Ù…Ù† heatmap Ù„Ø¥Ø³Ù‚Ø§Ø· Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙŠØ´
      const texCanvas = document.createElement('canvas');
      texCanvas.width = procWidth; texCanvas.height = procHeight;
      texCanvas.getContext('2d').putImageData(ctxHeightmap.getImageData ? ctxHeightmap.getImageData(0,0, canvasHeightmap.width, canvasHeightmap.height) : ctxHeightmap.getImageData(0,0,procWidth,procHeight), 0,0);
      // Safety: if previous fails, fallback to heightmap raw drawing
      try{
        // create from scaled heatmap on canvasHeightmap
        const tmp = document.createElement('canvas'); tmp.width = procWidth; tmp.height = procHeight;
        tmp.getContext('2d').drawImage(canvasHeightmap, 0,0, procWidth, procHeight);
        const texture = new THREE.CanvasTexture(tmp);
        texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.flipY = true;
        var material = new THREE.MeshStandardMaterial({ map: texture, side: THREE.DoubleSide, displacementScale: 0 });
      }catch(e){
        var material = new THREE.MeshStandardMaterial({ color:0xdddddd, side: THREE.DoubleSide});
      }

      // ØªØ¹Ø¨Ø¦Ø© z-values
      const pos = geometry.attributes.position;
      const maxDepth = parseFloat(maxDepthSlider.value);
      const invertZ = invertZChk.checked ? -1 : 1;
      for (let r=0; r<rows; r++){
        for (let c=0; c<cols; c++){
          const vi = r*cols + c;
          // sample from heightMap (procWidth x procHeight)
          const sx = Math.floor(c/(cols-1) * (procWidth-1));
          const sy = Math.floor(r/(rows-1) * (procHeight-1));
          const hv = heightMap[sy*procWidth + sx] || 0;
          const z = hv * maxDepth * invertZ;
          pos.setZ(vi, z);
        }
      }
      pos.needsUpdate = true;
      geometry.computeVertexNormals();

      if (threeMesh) { threeScene.remove(threeMesh); threeMesh.geometry.dispose(); }
      threeMesh = new THREE.Mesh(geometry, material);
      // Ù…Ø¶Ø¨ÙˆØ·Ø© Ù„ÙƒÙŠ ÙŠÙƒÙˆÙ† Ù…Ø±ÙƒØ² Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ ÙÙŠ (0,0,0)
      threeMesh.rotation.x = 0; // plane in XY with Z up
      threeScene.add(threeMesh);

      // ÙˆØ¶Ø¹ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
      threeCamera.position.set(0, 0, Math.max(planeW, planeH) * 1.2);
      threeCamera.up.set(0,1,0);
      threeCamera.lookAt(0,0,0);

      // loop
      function animate(){
        requestAnimationFrame(animate);
        threeControls.update();
        threeRenderer.render(threeScene, threeCamera);
      }
      animate();
    }

    // ---------- G-code generation ----------
    function generateGcode(){
      if (!heightMap) { alert('Ø§Ø¶ØºØ· "Ù…Ø¹Ø§Ù„Ø¬Ø©" Ø£ÙˆÙ„Ø§Ù‹'); return; }

      const mmPerPixel = parseFloat(mmPerPixelInput.value) || 0.5;
      const maxDepth = parseFloat(maxDepthSlider.value) || 5;
      const step = Math.max(1, Math.round(procWidth / 300)); // ØªØ®ÙÙŠÙ Ø§Ù„Ù†Ù‚Ø§Ø· Ø¥Ù† ÙƒØ§Ù†Øª ÙƒØ¨ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹
      const thr = parseInt(edgeThreshold.value,10);
      const flipY = flipYChk.checked;

      const lines = [];
      lines.push('G21 ; mm');
      lines.push('G90 ; absolute');
      lines.push('G0 Z5.00 ; safe');

      // Generate simple raster following edges: for each pixel where edge > thr, probe height
      for (let y=0; y<procHeight; y+=step){
        // snake pattern to reduce moves
        const dir = (Math.floor(y/step)%2===0);
        const xs = dir ? [0, procWidth-1, 1] : [procWidth-1, 0, -1];
        let x = xs[0];
        while ((dir && x<=xs[1]) || (!dir && x>=xs[1])){
          const edgeVal = edges[y*procWidth + x] || 0;
          if (edgeVal > thr){
            const hv = heightMap[y*procWidth + x] || 0; // 0..1
            const z = -hv * maxDepth;
            // map x,y to mm. origin at bottom-left unless flipY
            const xm = x * mmPerPixel;
            const ym = (flipY ? y : (procHeight-1 - y)) * mmPerPixel;
            lines.push(`G0 X${xm.toFixed(3)} Y${ym.toFixed(3)} Z5.000`);
            lines.push(`G1 Z${z.toFixed(3)} F300`);
            lines.push('G0 Z5.000');
          }
          x += xs[2];
        }
      }

      lines.push('M30 ; end');

      const blob = new Blob([lines.join('\n')], {type:'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'cnc_output.gcode'; a.click();
      URL.revokeObjectURL(url);
    }

    // ---------- Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… ----------
    btnProcess.addEventListener('click', () => { const ok = prepareProcessing(); if (ok) alert('ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Heatmap ÙˆØ§Ù„Ø­ÙˆØ§Ù â€” Ø§Ø¶ØºØ· Ù…Ø¹Ø§ÙŠÙ†Ø© 3D Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬'); });
    btnPreview3D.addEventListener('click', preview3D);
    btnGcode.addEventListener('click', generateGcode);

    // Helpers: read pixel data from canvasHeightmap when creating texture
    // (no-op here; texture created from drawImage)

  </script></body>
</html>
