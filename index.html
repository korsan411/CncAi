<!doctype html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>CNC AI ‚Äî Multi Machine Raster Engraving</title>

    <!-- ŸÖŸÉÿ™ÿ®ÿßÿ™ -->
    <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        * { box-sizing: border-box; }
        body { margin: 0; font-family: Arial, Segoe UI, system-ui; background: #041022; color: #e6eef6; line-height: 1.5; }
        .app { max-width: 1400px; margin: 16px auto; padding: 14px; }
        header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #1e293b; }
        .grid { display: grid; grid-template-columns: 1fr 480px; gap: 16px; }
        @media (max-width: 1000px) { .grid { grid-template-columns: 1fr; } }
        .panel { background: #0b1320; padding: 16px; border-radius: 10px; border: 1px solid #1e293b; }
        .panel-section { margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid #1e293b; }
        .panel-section:last-child { border-bottom: none; margin-bottom: 0; }
        .tabs { display: flex; margin-top: 12px; border-bottom: 1px solid #1e293b; }
        .tabs button { margin-left: 6px; padding: 8px 14px; border: none; border-radius: 6px 6px 0 0; cursor: pointer; background: transparent; color: #9bb0c8; transition: all 0.2s; font-size: 0.9rem; }
        .tabs button:hover { background: #1e293b; }
        .tabs button.active { background: #06b6d4; color: #021; }
        .tab-content { display: none; margin-top: 12px; }
        .tab-content.active { display: block; }
        canvas { max-width: 100%; border-radius: 6px; background: #000; display: block; margin: 0 auto; }
        textarea { width: 100%; height: 200px; background: #021024; color: #cfeaf2; font-family: monospace; border-radius: 8px; padding: 10px; border: 1px solid #1e293b; resize: vertical; }
        #threeContainer { width: 100%; height: 360px; background: #081224; border-radius: 8px; overflow: hidden; }
        label { display: block; margin-top: 12px; color: #cfeaf2; font-weight: bold; font-size: 0.9rem; }
        .input-group { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        input, select { width: 100%; padding: 8px 10px; border-radius: 6px; border: 1px solid #1e293b; background: #0f172a; color: #e6eef6; margin-top: 6px; font-size: 0.9rem; }
        input:focus, select:focus { outline: none; border-color: #06b6d4; }
        .button-group { display: flex; flex-direction: column; gap: 8px; margin-top: 16px; }
        button.primary { background: #06b6d4; color: #021; font-weight: bold; border: none; padding: 10px; border-radius: 8px; cursor: pointer; transition: background 0.2s; }
        button.primary:hover { background: #0ea5e9; }
        button.secondary { background: #1e293b; color: #e6eef6; border: none; padding: 10px; border-radius: 8px; cursor: pointer; transition: background 0.2s; }
        button.secondary:hover { background: #334155; }
        #toast { position: fixed; left: 16px; bottom: 16px; background: rgba(0, 0, 0, 0.85); color: #fff; padding: 10px 14px; border-radius: 8px; display: none; z-index: 10000; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3); }
        h1 { margin: 0; color: #06b6d4; font-size: 1.5rem; }
        h3 { margin-top: 0; color: #9bb0c8; font-size: 1.1rem; padding-bottom: 8px; border-bottom: 1px solid #1e293b; }
        h4 { margin: 0 0 10px 0; color: #cfeaf2; font-size: 1rem; }
        #cvState { color: #9bb0c8; font-size: 0.9em; padding: 6px 10px; background: #0f172a; border-radius: 6px; }
        #estTime { margin-top: 12px; color: #9bb0c8; text-align: center; padding: 8px; background: #0f172a; border-radius: 6px; }
        .file-input-container { position: relative; overflow: hidden; display: inline-block; width: 100%; }
        .file-input-container input[type=file] { position: absolute; left: 0; top: 0; opacity: 0; width: 100%; height: 100%; cursor: pointer; }
        .file-input-label { display: block; padding: 10px; background: #1e293b; color: #e6eef6; text-align: center; border-radius: 6px; cursor: pointer; transition: background 0.2s; }
        .file-input-label:hover { background: #334155; }
        .info-text { font-size: 0.8rem; color: #9bb0c8; margin-top: 4px; }
        .settings-row { display: flex; gap: 10px; align-items: end; }
        .settings-row .input-group { flex: 1; }
        .material-preset { background: #1e293b; border: 1px solid #334155; border-radius: 6px; padding: 8px; margin-top: 8px; cursor: pointer; transition: all 0.2s; }
        .material-preset:hover { background: #334155; }
        .material-preset.active { background: #06b6d4; color: #021; border-color: #06b6d4; }
        .material-name { font-weight: bold; margin-bottom: 4px; }
        .material-details { font-size: 0.8rem; color: #9bb0c8; }
        .active-material .material-details { color: #021; }
        .dimension-info { font-size: 0.8rem; color: #06b6d4; margin-top: 4px; }
    </style>
</head>
<body>
    <!-- ŸáŸÜÿß ÿ®ÿßŸÇŸä Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿ®ÿßŸÑÿ∏ÿ®ÿ∑ (ÿ±ŸÅÿπ ÿµŸàÿ±ÿ©ÿå ÿßŸÑÿ™ÿ®ŸàŸäÿ®ÿßÿ™ÿå ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ÿå ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ±ÿå ÿßŸÑŸÜÿµŸàÿµ) -->
    <!-- ŸÑŸÖ Ÿäÿ™ŸÖ ÿ™ÿ∫ŸäŸäÿ± ÿ£Ÿä ÿ¥Ÿäÿ° ŸÅŸä HTML ÿπŸÜ ÿßŸÑŸÖŸÑŸÅ ÿßŸÑÿ£ÿµŸÑŸä -->

    <script>
        // üîπ ÿßŸÑÿ™ÿπÿØŸäŸÑ 1: ÿ™ÿ≠ÿ≥ŸäŸÜ Colormap
        function renderHeatmap(gray) {
            let heat = document.getElementById('canvasHeatmap');
            heat.width = gray.cols;
            heat.height = gray.rows;
            let hctx = heat.getContext('2d');
            let imgData = hctx.createImageData(heat.width, heat.height);

            for (let y = 0; y < gray.rows; y++) {
                for (let x = 0; x < gray.cols; x++) {
                    let v = gray.ucharPtr(y, x)[0];
                    let idx = (y * gray.cols + x) * 4;
                    let r = Math.min(255, Math.max(0, 255 * (v / 128 - 1)));
                    let g = Math.min(255, Math.max(0, 255 * (1 - Math.abs(v - 128) / 128)));
                    let b = Math.min(255, Math.max(0, 255 * (1 - v / 128)));
                    imgData.data[idx] = r;
                    imgData.data[idx + 1] = g;
                    imgData.data[idx + 2] = b;
                    imgData.data[idx + 3] = 255;
                }
            }
            hctx.putImageData(imgData, 0, 0);
        }

        // üîπ ÿßŸÑÿ™ÿπÿØŸäŸÑ 2: ÿØÿπŸÖ ÿßÿ™ÿ¨ÿßŸá Y ŸÅŸä G-code
        function generateRasterGcode(scaleDown = false) {
            if (!grayMat || !contour) return "";
            const dir = document.getElementById('scanDir').value;
            const stepOver = parseFloat(document.getElementById('stepOver').value) || 5;
            const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
            const feed = parseFloat(document.getElementById('feedRate').value) || 800;
            const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
            const invertZ = document.getElementById('invertZ').value === 'yes';
            const workWidth = cmToMm(parseFloat(document.getElementById('workWidth').value) || 30);
            const workHeight = cmToMm(parseFloat(document.getElementById('workHeight').value) || 20);
            const originX = cmToMm(parseFloat(document.getElementById('originX').value) || 0);
            const originY = cmToMm(parseFloat(document.getElementById('originY').value) || 0);

            const lines = [];
            lines.push('G21 G90 G17');
            lines.push('G0 Z' + safeZ.toFixed(2));
            let totalLen = 0;
            let step = scaleDown ? stepOver * 4 : stepOver;
            const scaleX = workWidth / previewCanvas.width;
            const scaleY = workHeight / previewCanvas.height;

            if (dir === 'x') {
                for (let y = 0; y < previewCanvas.height; y += step) {
                    let row = [];
                    for (let x = 0; x < previewCanvas.width; x++) {
                        let inside = cv.pointPolygonTest(contour, new cv.Point(x, y), false);
                        if (inside >= 0) {
                            let pv = sampleGrayAt(x, y);
                            let z = -((255 - pv) / 255.0) * maxDepth;
                            if (invertZ) z = -z;
                            const scaledX = (x * scaleX) + originX;
                            const scaledY = (y * scaleY) + originY;
                            row.push({ x: scaledX, y: scaledY, z });
                        }
                    }
                    if (row.length > 1) {
                        if ((y / step) % 2 !== 0) row.reverse();
                        lines.push('G0 X' + row[0].x.toFixed(2) + ' Y' + row[0].y.toFixed(2) + ' Z' + safeZ);
                        lines.push('G1 F' + feed);
                        for (let i = 0; i < row.length; i++) {
                            let p = row[i];
                            lines.push('G1 X' + p.x.toFixed(2) + ' Y' + p.y.toFixed(2) + ' Z' + p.z.toFixed(3));
                            if (i > 0) totalLen += Math.hypot(p.x - row[i - 1].x, p.y - row[i - 1].y);
                        }
                        lines.push('G0 Z' + safeZ);
                    }
                }
            } else if (dir === 'y') {
                for (let x = 0; x < previewCanvas.width; x += step) {
                    let col = [];
                    for (let y = 0; y < previewCanvas.height; y++) {
                        let inside = cv.pointPolygonTest(contour, new cv.Point(x, y), false);
                        if (inside >= 0) {
                            let pv = sampleGrayAt(x, y);
                            let z = -((255 - pv) / 255.0) * maxDepth;
                            if (invertZ) z = -z;
                            const scaledX = (x * scaleX) + originX;
                            const scaledY = (y * scaleY) + originY;
                            col.push({ x: scaledX, y: scaledY, z });
                        }
                    }
                    if (col.length > 1) {
                        if ((x / step) % 2 !== 0) col.reverse();
                        lines.push('G0 X' + col[0].x.toFixed(2) + ' Y' + col[0].y.toFixed(2) + ' Z' + safeZ);
                        lines.push('G1 F' + feed);
                        for (let i = 0; i < col.length; i++) {
                            let p = col[i];
                            lines.push('G1 X' + p.x.toFixed(2) + ' Y' + p.y.toFixed(2) + ' Z' + p.z.toFixed(3));
                            if (i > 0) totalLen += Math.hypot(p.x - col[i - 1].x, p.y - col[i - 1].y);
                        }
                        lines.push('G0 Z' + safeZ);
                    }
                }
            }

            lines.push('M5');
            lines.push('M30');
            let timeMin = (totalLen / feed);
            document.getElementById('estTime').textContent = "‚è±Ô∏è ÿ™ŸÇÿØŸäÿ± ÿßŸÑŸàŸÇÿ™: " + timeMin.toFixed(1) + " ÿØŸÇŸäŸÇÿ©";
            return lines.join('\n');
        }

        // üîπ ÿßŸÑÿ™ÿπÿØŸäŸÑ 3: ÿ±ÿ®ÿ∑ 3D ÿ®ŸÄ maxDepth
        function show3D() {
            if (!grayMat) return;
            const cont = document.getElementById('threeContainer');
            cont.innerHTML = "";
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, cont.clientWidth / cont.clientHeight, 0.1, 5000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(cont.clientWidth, cont.clientHeight);
            cont.appendChild(renderer.domElement);
            const geom = new THREE.PlaneGeometry(grayMat.cols, grayMat.rows, grayMat.cols - 1, grayMat.rows - 1);
            const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
            for (let y = 0; y < grayMat.rows; y++) {
                for (let x = 0; x < grayMat.cols; x++) {
                    let v = grayMat.ucharPtr(y, x)[0];
                    let z = (v / 255.0) * maxDepth;
                    let idx = y * grayMat.cols + x;
                    geom.attributes.position.setZ(idx, z);
                }
            }
            geom.attributes.position.needsUpdate = true;
            geom.computeVertexNormals();
            geom.rotateX(-Math.PI / 2);
            const mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({
                color: 0xcccccc, side: THREE.DoubleSide, flatShading: true
            }));
            scene.add(mesh);
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(50, 100, 150);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));
            camera.position.set(0, -grayMat.rows, grayMat.rows * 1.2);
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }
    </script>
</body>
</html>
