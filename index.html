<!DOCTYPE html><html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CncAi - index_fixed</title>
  <style>
    body{font-family: Arial, Helvetica, sans-serif; margin:0; padding:16px; background:#f4f6f8; color:#222}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between}
    h1{margin:0;font-size:18px}
    .container{display:grid;grid-template-columns:360px 1fr;gap:12px;margin-top:12px}
    .panel{background:white;padding:12px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.05)}
    label{display:block;margin:6px 0;font-size:13px}
    input[type=file]{width:100%}
    canvas{background:#222;border-radius:4px;max-width:100%;display:block}
    textarea{width:100%;height:160px}
    .row{display:flex;gap:8px}
    button{padding:8px 10px;border-radius:6px;border:0;background:#0b74de;color:white;cursor:pointer}
    .muted{font-size:12px;color:#666}
  </style>
</head>
<body>
  <header>
    <h1>CncAi — نسخة مُصحّحة (index_fixed.html)</h1>
    <div class="muted">حافظت على أساسيات الكود: رفع صورة، كشف الحواف، توليد G-code</div>
  </header>  <div class="container">
    <div class="panel">
      <label>رفع صورة</label>
      <input id="imgFile" type="file" accept="image/*">
      <label>خيارات الكشف والتوليد</label>
      <label>Threshold (Canny): <input id="cannyThresh" type="range" min="10" max="200" value="80"></label>
      <label>Step Over (mm): <input id="stepOver" type="number" value="2" min="0.1" step="0.1"></label>
      <label>Point Spacing (mm): <input id="pointSpacing" type="number" value="1" min="0.1" step="0.1"></label>
      <label>Laser Speed (mm/min): <input id="laserSpeed" type="number" value="2000"></label>
      <label>Max S (firmware): <input id="maxS" type="number" value="1000"></label><div style="margin-top:8px" class="row">
    <button id="detectBtn">كشف الحواف</button>
    <button id="gcodeBtn">توليد G-code</button>
  </div>

  <div style="margin-top:8px">
    <div class="muted">مخرجات:</div>
    <textarea id="log" readonly></textarea>
  </div>
</div>

<div class="panel">
  <div style="display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:8px">
    <div class="muted">معاينة</div>
    <div class="muted">(X & Y سيتم استخراجهما من حدود الحواف)</div>
  </div>
  <canvas id="preview" width="800" height="600"></canvas>
</div>

  </div>  <!-- OpenCV.js CDN (إذا لم يكن مثبتاً محلياً) -->  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>  <script>
    // ======== متغيرات الواجهة ========
    const imgFile = document.getElementById('imgFile');
    const detectBtn = document.getElementById('detectBtn');
    const gcodeBtn = document.getElementById('gcodeBtn');
    const preview = document.getElementById('preview');
    const ctx = preview.getContext('2d');
    const logEl = document.getElementById('log');
    let originalImage = new Image();
    let imgMat = null;
    let contoursResult = { contours: [], hierarchy: null, boundingBox: null, mask: null };

    function onOpenCvReady(){
      appendLog('OpenCV جاهز');
    }

    function appendLog(text){
      logEl.value = (new Date()).toLocaleTimeString() + ' | ' + text + '\n' + logEl.value;
    }

    imgFile.addEventListener('change', (e)=>{
      const f = e.target.files[0];
      if(!f) return;
      const url = URL.createObjectURL(f);
      originalImage.onload = ()=>{
        // scale canvas to image but keep max size
        const maxW = 1200; const maxH = 900;
        let w = originalImage.width, h = originalImage.height;
        const ratio = Math.min(maxW/w, maxH/h, 1);
        preview.width = Math.round(w * ratio);
        preview.height = Math.round(h * ratio);
        ctx.drawImage(originalImage, 0, 0, preview.width, preview.height);

        // create imgMat (CV) from canvas
        if (imgMat) imgMat.delete();
        imgMat = cv.imread(preview);
        appendLog('تم تحميل الصورة إلى canvas');
      };
      originalImage.src = url;
    });

    detectBtn.addEventListener('click', ()=>{
      if(!imgMat){ appendLog('لا توجد صورة'); return; }
      detectLaserContours();
    });

    gcodeBtn.addEventListener('click', ()=>{
      if(!contoursResult || !contoursResult.contours || contoursResult.contours.length === 0){ appendLog('لم تُكشف أي حواف بعد'); return; }
      const gcode = generateLaserGcode(contoursResult);
      appendLog('G-code متاح. طول الأسطر: ' + gcode.split('\n').length);
      // عرض G-code داخل الـ textarea (نضعه أعلى السجل)
      logEl.value = gcode + '\n\n' + logEl.value;
    });

    // ======== كشف الحواف باستخدام OpenCV.js ========
    function detectLaserContours(){
      appendLog('بدء كشف الحواف...');
      // تحويل للصورة الرمادية
      let src = imgMat.clone();
      let gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

      // تعمل Canny (القيمة من الواجهة)
      const t = parseInt(document.getElementById('cannyThresh').value, 10);
      let edges = new cv.Mat();
      cv.Canny(gray, edges, t*0.5, t);

      // إغلاق صغير لإزالة الضوضاء
      let kernel = cv.Mat.ones(3,3,cv.CV_8U);
      cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);
      kernel.delete();

      // إيجاد الكونتورات
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      appendLog('عدد الكونتورات: ' + contours.size());

      // عمل قناع من الكونتورات الكبرى فقط
      const minContourArea = 50; // بكسل
      let mask = new cv.Mat.zeros(edges.rows, edges.cols, cv.CV_8UC1);
      let bb = {x:99999,y:99999,x2:0,y2:0};

      for(let i=0;i<contours.size();i++){
        let cnt = contours.get(i);
        const area = cv.contourArea(cnt);
        if(area < minContourArea){ cnt.delete(); continue; }
        // نمط تقريبي لتقليل عدد النقاط
        let approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 1, true);
        // رسم الكونتور المعبأ
        let cntVec = new cv.MatVector(); cntVec.push_back(approx);
        cv.drawContours(mask, cntVec, 0, new cv.Scalar(255), cv.FILLED);
        // bounding box
        const r = cv.boundingRect(approx);
        bb.x = Math.min(bb.x, r.x);
        bb.y = Math.min(bb.y, r.y);
        bb.x2 = Math.max(bb.x2, r.x + r.width);
        bb.y2 = Math.max(bb.y2, r.y + r.height);

        cntVec.delete(); approx.delete(); cnt.delete();
      }

      // إذا لم نجد أي شيء
      if(bb.x2 === 0 && bb.y2 === 0){ appendLog('لم يُعثر على حواف كافية'); edges.delete(); gray.delete(); src.delete(); contours.delete(); hierarchy.delete(); mask.delete(); return; }

      // حفظ النتائج في المتغيرات العالمية (مع تحجيم للإحداثيات الحقيقية لاحقاً)
      contoursResult.contours = contours; // ملاحظة: نحتفظ بـ MatVector هنا
      contoursResult.hierarchy = hierarchy;
      contoursResult.mask = mask;
      contoursResult.boundingBox = { x: bb.x, y: bb.y, width: bb.x2 - bb.x, height: bb.y2 - bb.y };

      // عرض الماسك على الـ canvas (للمعاينة)
      showMaskOnCanvas(mask);

      edges.delete(); gray.delete(); src.delete();
      appendLog('اكتمل كشف الحواف. Bounding box: x=' + contoursResult.boundingBox.x + ', y=' + contoursResult.boundingBox.y + ', w=' + contoursResult.boundingBox.width + ', h=' + contoursResult.boundingBox.height);
    }

    function showMaskOnCanvas(mask){
      // تحويل mask إلى canvas imageData
      const w = mask.cols, h = mask.rows;
      const imgData = ctx.createImageData(w, h);
      for(let y=0;y<h;y++){
        for(let x=0;x<w;x++){
          const v = mask.ucharPtr(y,x)[0];
          const idx = (y*w + x) * 4;
          imgData.data[idx] = v; imgData.data[idx+1] = v; imgData.data[idx+2] = v; imgData.data[idx+3] = 255;
        }
      }
      // ارسم مع تصغير/تكبير لملاءمة canvas
      const tmpCanvas = document.createElement('canvas'); tmpCanvas.width = w; tmpCanvas.height = h; tmpCanvas.getContext('2d').putImageData(imgData,0,0);
      ctx.clearRect(0,0,preview.width, preview.height);
      ctx.drawImage(tmpCanvas, 0, 0, preview.width, preview.height);
    }

    // ======== توليد G-code مُصحّح ========
    function generateLaserGcode({ mask, boundingBox }){
      appendLog('توليد G-code (باستخدام X&Y من حدود الحواف)');
      // إعدادات المستخدم
      const stepOverMm = parseFloat(document.getElementById('stepOver').value);
      const pointSpacingMm = parseFloat(document.getElementById('pointSpacing').value);
      const laserSpeed = parseFloat(document.getElementById('laserSpeed').value); // mm/min
      const maxS = parseFloat(document.getElementById('maxS').value);

      // مقياس: نحسب علاقة البيكسل -> ملم
      // نفترض: المستخدم يريد العمل بنسبة 1 canvas pixel == 1 mm أو يمكنك تعديلها
      // هنا نستخدم افتراض أن الصورة تعرض بمقياس pxPerMm = preview.width / imgPixelWidth
      const pxPerMmX = mask.cols / preview.width; // пикسل الصورة الأصلية لكل بكسل على الكanvas المعروض
      const pxPerMmY = mask.rows / preview.height;
      // لتحويل mm -> pixels on mask:
      const xStepPx = Math.max(1, Math.round(pointSpacingMm * pxPerMmX));
      const yStepPx = Math.max(1, Math.round(stepOverMm * pxPerMmY));

      appendLog('حساب خطوات بالبكسل: xStep=' + xStepPx + ', yStep=' + yStepPx);

      // نقطة البداية: نستخدم boundingBox (ضمن إحداثيات الماسك)
      const startX = boundingBox.x;
      const startY = boundingBox.y;
      const endX = boundingBox.x + boundingBox.width;
      const endY = boundingBox.y + boundingBox.height;

      // جمع نقاط المسح (raster) داخل القناع
      let allPoints = [];
      for(let y = startY; y < endY; y += yStepPx){
        let rowPoints = [];
        for(let x = startX; x < endX; x += xStepPx){
          // تحقق سريع داخل الماسك
          const v = mask.ucharPtr(Math.round(y), Math.round(x))[0];
          if(v > 0){
            rowPoints.push({x: x, y: y});
          }
        }
        // إذا كانت هناك نقاط بالصف ضفها (بـ spread) — هذا يصلح مشكلة السطر الخاطئ السابق
        if(rowPoints.length > 0){
          allPoints.push(...rowPoints);
        }
      }

      if(allPoints.length === 0){ appendLog('لم تُوجد نقاط داخل حدود الحواف'); return ''; }

      // تحويل allPoints إلى إحداثيات G-code (ملم)
      // نفترض أن كل px على الماسك يساوي (1/pxPerMmX) ملم
      const mmPerPxX = 1/pxPerMmX;
      const mmPerPxY = 1/pxPerMmY;

      // توليد G-code
      let g = [];
      g.push('; Generated by CncAi index_fixed');
      g.push('G21 ; mm');
      g.push('G90 ; absolute');
      g.push('G0 F' + laserSpeed);

      function mapPowerToS(p){
        // p in 0..1 -> S in 0..maxS
        return Math.round(p * maxS);
      }

      // سنقوم بتجميع مسارات بسيطة — تشغيل الليزر عند دخول نقاط
      let prev = null;
      for(let i=0;i<allPoints.length;i++){
        const pt = allPoints[i];
        const gx = (pt.x * mmPerPxX).toFixed(3);
        const gy = (pt.y * mmPerPxY).toFixed(3);
        if(!prev){
          g.push('G0 X' + gx + ' Y' + gy);
          g.push('M3 S' + mapPowerToS(1.0)); // تشغيل بقوة كاملة (يمكن تحسين لاحقاً حسب gray)
        } else {
          g.push('G1 X' + gx + ' Y' + gy + ' F' + laserSpeed);
        }
        prev = pt;
      }
      g.push('M5');
      g.push('G0 X0 Y0');

      appendLog('تم إنشاء G-code بعدد نقاط: ' + allPoints.length);
      return g.join('\n');
    }

    // ======== تنظيف عند إغلاق الصفحة ========
    window.addEventListener('beforeunload', ()=>{
      try{ if(imgMat) imgMat.delete(); }catch(e){}
      try{ if(contoursResult.mask) contoursResult.mask.delete(); }catch(e){}
      try{ if(contoursResult.contours) contoursResult.contours.delete(); }catch(e){}
      try{ if(contoursResult.hierarchy) contoursResult.hierarchy.delete(); }catch(e){}
    });

  </script></body>
</html>
