<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>CNC AI - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©</title>

  <!-- Ù…ÙƒØªØ¨Ø© Clipper.js Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø­ÙŠØ·Ø§Øª Ø¨Ø¯Ù‚Ø© -->
  <script src="https://cdn.jsdelivr.net/npm/clipper-lib@6.4.2/clipper.js"></script>

  <style>
    :root{
      --primary:#1f78d1;--bg:#f4f6fa;--card:#fff;--muted:#777;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:Tahoma,Arial,sans-serif;background:var(--bg);color:#222;}
    header{background:linear-gradient(90deg,var(--primary),#5aa6f7);color:#fff;padding:12px 18px;display:flex;justify-content:space-between;align-items:center}
    header h1{margin:0;font-size:18px}
    .container{display:grid;grid-template-columns:1fr 420px;gap:14px;max-width:1400px;margin:14px auto;padding:12px}
    .panel{background:var(--card);padding:12px;border-radius:10px;box-shadow:0 2px 6px rgba(0,0,0,0.06);}
    label{font-weight:600;display:block;margin-top:8px}
    canvas{background:#eee;border-radius:6px;max-width:100%}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .btn{padding:8px 12px;border:0;border-radius:8px;cursor:pointer}
    .btn-primary{background:var(--primary);color:#fff}
    .gcode-output{height:200px;overflow:auto;background:#0b1220;color:#cfe8ff;padding:8px;border-radius:8px;font-family:monospace;font-size:13px}
    .small{font-size:13px;color:var(--muted)}
    input[type=range]{width:100%}
    @media(max-width:980px){.container{grid-template-columns:1fr}}
  </style>
</head>
<body>
<header>
  <h1>ğŸ›  CNC AI - Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©</h1>
  <div class="small">Ø±ÙØ¹ ØµÙˆØ±Ø© â†’ Ù…Ø¹Ø§Ù„Ø¬Ø© â†’ Ù…Ø¹Ø§ÙŠÙ†Ø© â†’ G-code</div>
</header>

<main class="container">
  <!-- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø£ÙŠØ³Ø±: Ù…Ø¹Ø§ÙŠÙ†Ø© ÙˆÙ…Ø¹Ø§Ù„Ø¬Ø© -->
  <section class="panel">
    <label>Ø±ÙØ¹ ØµÙˆØ±Ø© Ø§Ù„ØªØµÙ…ÙŠÙ…</label>
    <input id="fileInput" type="file" accept="image/*">

    <div class="row" style="margin-top:8px">
      <button id="btnAnalyze" class="btn btn-primary">ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù ÙˆØªØ­Ù„ÙŠÙ„</button>
      <button id="btnPreview2D" class="btn">Ø¹Ø±Ø¶ 2D</button>
      <button id="btnHeatmap" class="btn">Ø¹Ø±Ø¶ Heatmap</button>
      <button id="btn3D" class="btn">Ù…Ø¹Ø§ÙŠÙ†Ø© 3D</button>
    </div>

    <hr>
    <label>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</label>
    <div class="row">
      <div>
        Ù‚Ø·Ø± Ø§Ù„Ø£Ø¯Ø§Ø©: <input id="toolDia" type="number" value="3" step="0.1"> Ù…Ù…
      </div>
      <div>
        Stepover: <input id="stepover" type="range" min="10" max="90" value="40">
      </div>
      <div>
        Ø¹Ù…Ù‚ Ø§Ù„Ù…Ù…Ø±: <input id="passDepth" type="number" value="0.5" step="0.1">
      </div>
    </div>

    <label style="margin-top:8px">Ø®ÙŠØ§Ø±Ø§Øª Ø§Ù„ØªÙˆÙ„ÙŠØ¯</label>
    <div class="row">
      <label><input id="startFromEdges" type="checkbox" checked> Ø¨Ø¯Ø¡ Ù…Ù† Ø§Ù„Ø­ÙˆØ§Ù</label>
      <label><input id="usePerimeters" type="checkbox" checked> Ù…Ø­ÙŠØ·Ø§Øª (Perimeters)</label>
      <label><input id="useInfill" type="checkbox" checked> ØªØ¹Ø¨Ø¦Ø© Ø¯Ø§Ø®Ù„ÙŠØ©</label>
      <select id="infillType">
        <option value="lines">Ø®Ø·ÙˆØ·</option>
        <option value="zigzag">Zigzag</option>
        <option value="grid">Ø´Ø¨ÙƒØ© Grid</option>
      </select>
    </div>

    <hr>
    <label>Ù…Ø¹Ø§ÙŠÙ†Ø© 2D</label>
    <canvas id="preview2d" width="800" height="450"></canvas>

    <label style="margin-top:8px">Heatmap (Ù…ØµØºØ±Ø©)</label>
    <canvas id="heatmap" width="320" height="180"></canvas>

    <label style="margin-top:8px">Ù…Ø¹Ø§ÙŠÙ†Ø© 3D</label>
    <div id="preview3d" style="width:100%;height:360px;background:#eee;border-radius:8px"></div>
  </section>

  <!-- Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ø£ÙŠÙ…Ù†: G-code ÙˆÙ†ØªØ§Ø¦Ø¬ -->
  <aside class="panel">
    <h3>G-code ÙˆØ§Ù„ØªØ­ÙƒÙ…</h3>
    <button id="generatePaths" class="btn btn-primary">ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª</button>
    <button id="genG" class="btn">ØªÙˆÙ„ÙŠØ¯ G-code</button>
    <button id="downloadG" class="btn">ØªØ­Ù…ÙŠÙ„ G-code</button>

    <label style="margin-top:8px">Feed Rate</label>
    <input id="feedRate" type="number" value="800">

    <label style="margin-top:8px">Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª</label>
    <div class="small">Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø­ÙŠØ·Ø§Øª: <span id="contCount">0</span></div>
    <div class="small">Ø¹Ø¯Ø¯ Ù†Ù‚Ø§Ø· Ø£ÙˆÙ„ Ù…Ø­ÙŠØ·: <span id="firstLen">0</span></div>

    <label style="margin-top:8px">G-code Output</label>
    <div id="gcodeOutput" class="gcode-output">// G-code Ø³ÙŠØ¸Ù‡Ø± Ù‡Ù†Ø§</div>

    <div class="row" style="margin-top:8px">
      <button id="clearAll" class="btn">Ù…Ø³Ø­</button>
      <button id="simulate" class="btn">Ù…Ø­Ø§ÙƒØ§Ø©</button>
    </div>
  </aside>
</main>

<!-- Ù…ÙƒØªØ¨Ø© Three.js + OrbitControls -->
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/examples/js/controls/OrbitControls.js"></script>

<script>
(function(){
  const fileInput=document.getElementById('fileInput');
  const preview2d=document.getElementById('preview2d');
  const ctx2d=preview2d.getContext('2d');
  const heatmap=document.getElementById('heatmap');
  const ctxHeat=heatmap.getContext('2d');

  const contCountEl=document.getElementById('contCount');
  const firstLenEl=document.getElementById('firstLen');
  const gcodeOutput=document.getElementById('gcodeOutput');

  let loadedImage=null;
  let contours=[];
  let perimeters=[];
  let infillPaths=[];
  let heatmapData=null;

  // --- Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©
  fileInput.addEventListener('change',e=>{
    const f=e.target.files[0];
    if(!f) return;
    const reader=new FileReader();
    reader.onload=ev=>{
      const img=new Image();
      img.onload=()=>{
        loadedImage=img;
        const maxW=1000;
        let w=img.width,h=img.height;
        if(w>maxW){h=Math.round(h*(maxW/w));w=maxW;}
        preview2d.width=w;preview2d.height=h;
        ctx2d.drawImage(img,0,0,w,h);
        // heatmap Ù…ØµØºØ±Ø©
        const hmW=Math.min(512,w);
        const scale=hmW/w;
        heatmap.width=Math.round(w*scale);
        heatmap.height=Math.round(h*scale);
        ctxHeat.drawImage(img,0,0,heatmap.width,heatmap.height);
        heatmapData=ctxHeat.getImageData(0,0,heatmap.width,heatmap.height);
      };
      img.src=ev.target.result;
    };
    reader.readAsDataURL(f);
  });

  // --- Ù…Ø¹Ø§ÙŠÙ†Ø§Øª Ø¨Ø³ÙŠØ·Ø©
  document.getElementById('btnPreview2D').addEventListener('click',()=>{
    if(!loadedImage) return alert('Ø§Ø±ÙØ¹ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹');
    ctx2d.clearRect(0,0,preview2d.width,preview2d.height);
    ctx2d.drawImage(loadedImage,0,0,preview2d.width,preview2d.height);
  });

  document.getElementById('btnHeatmap').addEventListener('click',()=>{
    if(!heatmapData) return alert('Ù„Ø§ ØªÙˆØ¬Ø¯ Heatmap');
    ctxHeat.putImageData(heatmapData,0,0);
  });

  // --- ØªØ­Ù„ÙŠÙ„ ÙˆÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù
  document.getElementById('btnAnalyze').addEventListener('click',()=>{
    if(!heatmapData) return alert('Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ù…Ø­Ù„Ù„Ø©');
    const w=heatmap.width,h=heatmap.height;
    const imgData=ctxHeat.getImageData(0,0,w,h);
    const src=imgData.data;
    const gray=new Float32Array(w*h);
    for(let i=0;i<w*h;i++){
      const j=i*4;
      gray[i]=0.34*src[j]+0.5*src[j+1]+0.16*src[j+2];
    }
    // Sobel
    const sob=new Float32Array(w*h);
    const kx=[-1,0,1,-2,0,2,-1,0,1];
    const ky=[-1,-2,-1,0,0,0,1,2,1];
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        let gx=0,gy=0,idx=0;
        for(let ky0=-1;ky0<=1;ky0++){
          for(let kx0=-1;kx0<=1;kx0++){
            const v=gray[(y+ky0)*w+(x+kx0)];
            gx+=v*kx[idx];
            gy+=v*ky[idx];
            idx++;
          }
        }
        sob[y*w+x]=Math.hypot(gx,gy);
      }
    }
    // Normalize + threshold
    let min=Infinity,max=-Infinity;
    sob.forEach(v=>{if(v<min)min=v;if(v>max)max=v;});
    const bin=new Uint8Array(w*h);
    const threshold=(min+max)/2*0.6;
    for(let i=0;i<w*h;i++) bin[i]=sob[i]>threshold?1:0;

    // Marching Squares Ø¨Ø³ÙŠØ·
    contours=[];
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        if(bin[y*w+x]===1){
          const pts=[];
          for(let yy=y-1;yy<=y+1;yy++){
            for(let xx=x-1;xx<=x+1;xx++){
              if(bin[yy*w+xx]===1) pts.push({x:xx,y:yy});
            }
          }
          if(pts.length>4) contours.push(pts);
        }
      }
    }

    contCountEl.textContent=contours.length;
    firstLenEl.textContent=contours[0]?contours[0].length:0;
    redrawContours();
  });

  function redrawContours(){
    ctx2d.clearRect(0,0,preview2d.width,preview2d.height);
    if(loadedImage) ctx2d.drawImage(loadedImage,0,0,preview2d.width,preview2d.height);
    ctx2d.strokeStyle='#ff0000';
    contours.forEach(cont=>{
      ctx2d.beginPath();
      cont.forEach((p,i)=>{
        if(i===0) ctx2d.moveTo(p.x,p.y);
        else ctx2d.lineTo(p.x,p.y);
      });
      ctx2d.closePath();
      ctx2d.stroke();
    });
  }

  // --- ØªÙˆÙ„ÙŠØ¯ Ù…Ø­ÙŠØ·Ø§Øª Ø¯Ù‚ÙŠÙ‚Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Clipper
  document.getElementById('generatePaths').addEventListener('click',()=>{
    if(contours.length===0) return alert('Ù„Ø§ Ù…Ø­ÙŠØ·Ø§Øª');
    perimeters=[];
    const scale=100;
    contours.forEach(cont=>{
      const path=cont.map(p=>({X:p.x*scale,Y:p.y*scale}));
      const solution=new ClipperLib.Paths();
      const co=new ClipperLib.ClipperOffset();
      co.AddPath(path,ClipperLib.JoinType.jtRound,ClipperLib.EndType.etClosedPolygon);
      const offsetVal=parseFloat(document.getElementById('toolDia').value)*scale;
      co.Execute(solution,-offsetVal);
      solution.forEach(sol=>{
        perimeters.push(sol.map(pt=>({x:pt.X/scale,y:pt.Y/scale})));
      });
    });
    redrawContours();
    alert('ØªÙ… ØªÙˆÙ„ÙŠØ¯ Ù…Ø­ÙŠØ·Ø§Øª Ø¯Ù‚ÙŠÙ‚Ø©');
  });

  // --- G-code
  document.getElementById('genG').addEventListener('click',()=>{
    if(perimeters.length===0) return alert('Ù„Ø§ Ù…Ø­ÙŠØ·Ø§Øª Ù„Ù„ØªÙˆÙ„ÙŠØ¯');
    const feed=parseFloat(document.getElementById('feedRate').value)||800;
    const lines=[];
    lines.push('; G-code by CNC AI');
    lines.push('G21');
    lines.push('G90');
    lines.push('G0 Z5.000');

    perimeters.forEach(path=>{
      const first=path[0];
      lines.push(`G0 X${first.x.toFixed(2)} Y${first.y.toFixed(2)} Z5.000`);
      path.forEach(p=>{
        const z=(1-(ctxHeat.getImageData(p.x,p.y,1,1).data[0]/255))*3;
        lines.push(`G1 X${p.x.toFixed(2)} Y${p.y.toFixed(2)} Z-${z.toFixed(2)} F${feed}`);
      });
      lines.push('G0 Z5.000');
    });
    lines.push('M30');
    gcodeOutput.textContent=lines.join('\n');
  });

  // --- ØªØ­Ù…ÙŠÙ„ G-code
  document.getElementById('downloadG').addEventListener('click',()=>{
    const txt=gcodeOutput.textContent;
    if(!txt) return alert('Ù„Ø§ ÙŠÙˆØ¬Ø¯ ÙƒÙˆØ¯ Ù„Ù„Ø­ÙØ¸');
    const blob=new Blob([txt],{type:'text/plain'});
    const a=document.createElement('a');
    a.href=URL.createObjectURL(blob);
    a.download='cnc_output.nc';
    a.click();
  });

  // --- Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
  document.getElementById('btn3D').addEventListener('click',()=>{
    if(!heatmapData) return alert('Ù„Ø§ ØªÙˆØ¬Ø¯ Heatmap');
    const container=document.getElementById('preview3d');
    container.innerHTML='';
    const scene=new THREE.Scene();
    const camera=new THREE.PerspectiveCamera(45,container.clientWidth/container.clientHeight,0.1,1000);
    camera.position.set(0,80,120);
    const renderer=new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(container.clientWidth,container.clientHeight);
    container.appendChild(renderer.domElement);

    const controls=new THREE.OrbitControls(camera,renderer.domElement);
    const light=new THREE.DirectionalLight(0xffffff,1);
    light.position.set(0,100,100);
    scene.add(light);

    const w=heatmap.width,h=heatmap.height;
    const geometry=new THREE.PlaneGeometry(100,100,w-1,h-1);
    const verts=geometry.attributes.position.array;
    let k=0;
    for(let yy=0;yy<h;yy++){
      for(let xx=0;xx<w;xx++){
        const idx=(yy*w+xx)*4;
        const br=heatmapData.data[idx]*0.34+heatmapData.data[idx+1]*0.5+heatmapData.data[idx+2]*0.16;
        const z=(1-br/255)*10;
        verts[k+2]=z;
        k+=3;
      }
    }
    geometry.computeVertexNormals();
    const mat=new THREE.MeshStandardMaterial({color:0xdddddd,wireframe:false,side:THREE.DoubleSide});
    const mesh=new THREE.Mesh(geometry,mat);
    mesh.rotation.x=-Math.PI/2;
    scene.add(mesh);

    function animate(){requestAnimationFrame(animate);renderer.render(scene,camera);}
    animate();
  });

})();
</script>
</body>
</html>
