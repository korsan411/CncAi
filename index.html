<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>CNC AI — 2D/3D G-code from Image + Heatmap (OpenCV.js + Three.js)</title>

<!-- OpenCV.js -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<!-- three.js -->
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

<style>
  :root{
    --bg:#071022; --panel:#0b1320; --muted:#92a6bf; --accent:#06b6d4;
  }
  body{margin:0;font-family:Inter,Segoe UI,Arial;background:linear-gradient(180deg,#041022,#071022);color:#e6eef6;}
  .app{max-width:1200px;margin:18px auto;padding:16px;}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:12px}
  header h1{margin:0;font-size:18px;color:var(--accent)}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:12px}
  .panel{background:var(--panel);padding:12px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.5)}
  canvas#preview{width:100%;height:auto;border-radius:6px;background:#000}
  label{display:block;font-size:13px;color:var(--muted);margin-top:8px}
  input,select,button{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:#e6eef6}
  input[type=file]{padding:6px}
  input[type=range]{width:100%}
  button.primary{background:var(--accent);color:#042;font-weight:700;border:none;cursor:pointer}
  .row{display:flex;gap:8px}
  .row > *{flex:1}
  textarea{width:100%;height:220px;border-radius:8px;padding:8px;background:#021024;color:#cfeaf2;border:1px solid rgba(255,255,255,0.03);font-family:monospace}
  #threeContainer{width:100%;height:360px;background:#081224;border-radius:8px}
  #overlayBox{position:fixed;right:16px;bottom:16px;background:rgba(1,6,12,0.95);padding:8px;border-radius:8px;display:none;z-index:9999;border:1px solid rgba(6,182,212,0.12)}
  #overlayBox img{max-width:260px;max-height:260px}
  #toast{position:fixed;left:16px;bottom:16px;background:rgba(0,0,0,0.8);padding:8px 10px;border-radius:8px;color:#fff;display:none;z-index:10000}
  .small{font-size:12px;color:var(--muted)}
  @media(max-width:980px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>CNC AI — 2D & 3D (Heatmap → Z) G-code</h1>
      <div class="small">OpenCV.js + Three.js integrated</div>
    </header>

    <div class="grid">
      <!-- left: preview + 3D -->
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small">Preview (2D)</div>
          <div style="width:320px">
            <input id="fileInput" type="file" accept="image/*">
          </div>
        </div>

        <canvas id="preview" width="900" height="600"></canvas>

        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="btnDetect" class="primary">Detect contours & generate</button>
          <button id="btnPreview3D">Show 3D Preview</button>
        </div>

        <div id="threeContainer" style="margin-top:12px"></div>
        <div class="small" style="margin-top:8px">Tip: use <b>ε slider</b> to control simplification. Increase <b>procRes</b> to improve 3D detail (but CPU cost increases).</div>
      </div>

      <!-- right: controls & output -->
      <div class="panel">
        <h3 style="margin:0 0 8px 0">Controls</h3>

        <label>Canny low threshold
          <input id="cannyLow" type="number" value="50" min="0" max="255">
        </label>
        <label>Canny high threshold
          <input id="cannyHigh" type="number" value="150" min="0" max="255">
        </label>

        <label>Approx epsilon (fraction of contour perimeter)
          <input id="epsilon" type="range" min="0.005" max="0.05" step="0.001" value="0.01">
          <div class="small" id="epsDisplay">ε = 1.00%</div>
        </label>

        <label>Processing resolution for 3D preview (px, max dimension)
          <input id="procRes" type="number" value="200" min="80" max="800" step="10">
        </label>

        <label>Max depth (mm) — depth for white pixel (positive number, used as engraving depth)
          <input id="maxDepth" type="number" value="5" min="0.1" step="0.1">
        </label>

        <label>Real work width (mm) — map px → mm horizontally (image width → this mm)
          <input id="realWidth" type="number" value="200" min="1" step="1">
        </label>

        <label>Feed rate (mm/min)
          <input id="feedRate" type="number" value="800" min="10">
        </label>

        <label>Spindle RPM
          <input id="spindle" type="number" value="10000" min="100">
        </label>

        <div style="display:flex;gap:8px;margin-top:8px">
          <select id="gcodeMode">
            <option value="2d">2D (Z0 / Cut)</option>
            <option value="3d">3D Relief (Z from heatmap)</option>
          </select>
          <button id="btnGen" class="primary">Generate G-code</button>
        </div>

        <label style="margin-top:10px">Generated G-code</label>
        <textarea id="gcodeOut" placeholder="G-code will appear here..." readonly></textarea>

        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="btnDownload" class="primary">Download G-code</button>
          <button id="btnCopy">Copy</button>
          <button id="btnClear">Clear</button>
        </div>

        <div id="summary" class="small" style="margin-top:8px">Status: idle</div>
      </div>
    </div>
  </div>

  <div id="overlayBox"><img id="overlayImg" alt="overlay"></div>
  <div id="toast"></div>

<script>
/* ----------------------------------------------------------
  Helper UI & readiness for OpenCV
-----------------------------------------------------------*/
const toast = document.getElementById('toast');
function showToast(msg, ms=3000){
  toast.textContent = msg; toast.style.display='block';
  clearTimeout(toast._t); toast._t = setTimeout(()=> toast.style.display='none', ms);
}

let cvReady = false;
function markCvReady(){ cvReady = true; showToast('OpenCV ready'); console.log('OpenCV ready'); }
function waitForCv(){
  if(window.cv && cv.getBuildInformation) markCvReady();
  else if(window.cv) { cv['onRuntimeInitialized']=markCvReady; }
  else setTimeout(waitForCv, 200);
}
waitForCv();
setTimeout(()=> { if(!cvReady) showToast('OpenCV loading — wait a few seconds'); }, 12000);

/* ----------------------------------------------------------
  DOM refs & state
-----------------------------------------------------------*/
const fileInput = document.getElementById('fileInput');
const preview = document.getElementById('preview');
const pctx = preview.getContext('2d');
const btnDetect = document.getElementById('btnDetect');
const btnGen = document.getElementById('btnGen');
const btnPreview3D = document.getElementById('btnPreview3D');
const gcodeOut = document.getElementById('gcodeOut');
const btnDownload = document.getElementById('btnDownload');
const btnCopy = document.getElementById('btnCopy');
const btnClear = document.getElementById('btnClear');
const summary = document.getElementById('summary');

const epsSlider = document.getElementById('epsilon');
const epsDisplay = document.getElementById('epsDisplay');
epsDisplay.textContent = `ε = ${(parseFloat(epsSlider.value)*100).toFixed(2)}%`;
epsSlider.addEventListener('input', ()=> { epsDisplay.textContent = `ε = ${(parseFloat(epsSlider.value)*100).toFixed(2)}%`; });

let img = new Image();
let originalImage = null; // hold full-size image object
let processedPaths = [];   // array of paths (arrays of {x,y} in px space of processed image)
let procImageSize = {w:0,h:0}; // processed canvas size used for path detection
let grayMatForZ = null; // OpenCV Mat grayscale used for sampling Z (resized to procRes)
let lastProcRes = 200;

/* ----------------------------------------------------------
  Load image preview
-----------------------------------------------------------*/
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  img = new Image();
  img.onload = ()=>{
    originalImage = img;
    // draw scaled to preview canvas (fit width 900)
    const maxW = 900, maxH = 600;
    const ratio = Math.min(maxW/img.width, maxH/img.height, 1);
    preview.width = Math.round(img.width*ratio);
    preview.height = Math.round(img.height*ratio);
    pctx.clearRect(0,0,preview.width,preview.height);
    pctx.drawImage(img,0,0, preview.width, preview.height);
    summary.textContent = `Image: ${img.width}×${img.height} — preview: ${preview.width}×${preview.height}`;
  };
  img.src = url;
});

/* ----------------------------------------------------------
  OpenCV: detect contours, simplify, store paths
  - This uses the preview canvas as input (already scaled).
  - We also create a gray Mat at procRes for Z generation (resized).
-----------------------------------------------------------*/
function detectContoursAndPaths(){
  if(!cvReady) { showToast('OpenCV not ready'); return; }
  if(!originalImage) { showToast('Please load an image'); return; }

  showToast('Processing contours...');
  // operate on preview canvas (fast). If preview is small enough, use it; otherwise use downscale
  const canW = preview.width, canH = preview.height;
  // read image into cv.Mat
  let src = cv.imread(preview); // rgba
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

  // blur -> canny
  let blurred = new cv.Mat();
  cv.GaussianBlur(gray, blurred, new cv.Size(3,3), 0, 0, cv.BORDER_DEFAULT);

  const low = parseInt(document.getElementById('cannyLow').value||50);
  const high = parseInt(document.getElementById('cannyHigh').value||150);
  let edges = new cv.Mat();
  cv.Canny(blurred, edges, low, high);

  // find contours
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  // prepare output display mat
  let disp = new cv.Mat.zeros(edges.rows, edges.cols, cv.CV_8UC3);

  processedPaths = [];
  const epsilonFactor = parseFloat(epsSlider.value||0.01);

  for(let i=0;i<contours.size();i++){
    let cnt = contours.get(i);
    const area = Math.abs(cv.contourArea(cnt));
    if(area < 10){ cnt.delete(); continue; } // filter small noise
    const peri = cv.arcLength(cnt, true);
    const eps = Math.max(1.0, epsilonFactor * peri);
    let approx = new cv.Mat();
    cv.approxPolyDP(cnt, approx, eps, true);

    // draw with random color
    const color = new cv.Scalar(Math.random()*255, Math.random()*255, Math.random()*255);
    let mv = new cv.MatVector(); mv.push_back(approx);
    cv.drawContours(disp, mv, -1, color, 1, cv.LINE_8);

    // extract points
    if(approx.data32S && approx.data32S.length >= 6){
      const path = [];
      for(let k=0;k<approx.data32S.length;k+=2){
        path.push({ x: approx.data32S[k], y: approx.data32S[k+1] });
      }
      if(path.length>2) processedPaths.push(path);
    }

    mv.delete(); approx.delete(); cnt.delete();
  }

  // show overlay preview image (disp) in overlay box
  const dispCanvas = document.createElement('canvas');
  dispCanvas.width = disp.cols; dispCanvas.height = disp.rows;
  cv.imshow(dispCanvas, disp);
  document.getElementById('overlayImg').src = dispCanvas.toDataURL();
  document.getElementById('overlayBox').style.display = 'block';

  // cleanup
  src.delete(); gray.delete(); blurred.delete(); edges.delete();
  contours.delete(); hierarchy.delete(); disp.delete();

  // Prepare grayscale Mat for Z sampling:
  const procRes = parseInt(document.getElementById('procRes').value||200);
  lastProcRes = procRes;
  // create an offscreen canvas sized by procRes (largest dimension)
  const targetMax = procRes;
  const scale = Math.min(targetMax / preview.width, targetMax / preview.height, 1);
  const gw = Math.max(16, Math.round(preview.width * scale));
  const gh = Math.max(16, Math.round(preview.height * scale));
  const tempCanvas = document.createElement('canvas');
  tempCanvas.width = gw; tempCanvas.height = gh;
  const tctx = tempCanvas.getContext('2d');
  tctx.drawImage(preview, 0, 0, gw, gh);

  // read grayscale into grayMatForZ
  if(grayMatForZ) { grayMatForZ.delete(); grayMatForZ = null; }
  grayMatForZ = cv.imread(tempCanvas);
  let tmpGray = new cv.Mat();
  cv.cvtColor(grayMatForZ, tmpGray, cv.COLOR_RGBA2GRAY);
  grayMatForZ.delete();
  grayMatForZ = tmpGray; // single-channel 8U

  // note processed image size for px->mm mapping
  procImageSize.w = preview.width;
  procImageSize.h = preview.height;

  summary.textContent = `Found ${processedPaths.length} paths. Grayscale map: ${gw}×${gh}`;
  showToast('Contours extracted');
}

/* ----------------------------------------------------------
  Generate G-code 2D and 3D
  - 2D: Z 0 for cutting/contour (with safe Z moves)
  - 3D: sample grayMatForZ at each point to compute Z between 0 and -maxDepth
-----------------------------------------------------------*/
function pxToMm(px, imagePixelWidth, realWidthMm){
  return (px / imagePixelWidth) * realWidthMm;
}
function pixelValueAtGrayMat(x, y){
  // x,y are coordinates in processed preview resolution (procImageSize.w/h)
  // Need to map to grayMatForZ resolution
  if(!grayMatForZ) return 0;
  const gw = grayMatForZ.cols, gh = grayMatForZ.rows;
  const gx = Math.min(gw-1, Math.max(0, Math.round((x / procImageSize.w) * (gw-1))));
  const gy = Math.min(gh-1, Math.max(0, Math.round((y / procImageSize.h) * (gh-1))));
  // data is uchar in grayMatForZ.data
  const idx = gy * gw + gx;
  return grayMatForZ.data ? grayMatForZ.data[idx] : 0;
}

function generateGcode2D(paths){
  const feed = parseFloat(document.getElementById('feedRate').value||800);
  const spindle = parseInt(document.getElementById('spindle').value||10000);
  const realW = parseFloat(document.getElementById('realWidth').value||200);

  let g = `; Generated by CNC AI - 2D\nG21\nG90\nM3 S${spindle}\nG0 Z5\n`;
  for(const path of paths){
    if(!path || path.length<2) continue;
    const s = path[0];
    const sx = pxToMm(s.x, procImageSize.w, realW);
    const sy = pxToMm(s.y, procImageSize.w, realW);
    g += `G0 X${sx.toFixed(3)} Y${sy.toFixed(3)}\n`;
    g += `G1 Z0 F${feed}\n`;
    for(const p of path){
      const x = pxToMm(p.x, procImageSize.w, realW);
      const y = pxToMm(p.y, procImageSize.w, realW);
      g += `G1 X${x.toFixed(3)} Y${y.toFixed(3)} F${feed}\n`;
    }
    g += `G0 Z5\n`;
  }
  g += `M5\nG0 X0 Y0\nM30\n`;
  return g;
}

function generateGcode3D(paths){
  if(!grayMatForZ) { showToast('No heatmap prepared — run detect first'); return ''; }
  const feed = parseFloat(document.getElementById('feedRate').value||800);
  const spindle = parseInt(document.getElementById('spindle').value||10000);
  const realW = parseFloat(document.getElementById('realWidth').value||200);
  const maxDepth = parseFloat(document.getElementById('maxDepth').value||5); // mm (positive)
  let g = `; Generated by CNC AI - 3D Relief\nG21\nG90\nM3 S${spindle}\nG0 Z5\n`;

  for(const path of paths){
    if(!path || path.length<2) continue;
    // move to start fast at safe Z
    const s = path[0];
    const sx = pxToMm(s.x, procImageSize.w, realW);
    const sy = pxToMm(s.y, procImageSize.w, realW);
    g += `G0 X${sx.toFixed(3)} Y${sy.toFixed(3)}\n`;
    // for each point in path write X Y Z where Z is mapped from grayscale
    for(const p of path){
      const x = pxToMm(p.x, procImageSize.w, realW);
      const y = pxToMm(p.y, procImageSize.w, realW);
      const pv = pixelValueAtGrayMat(p.x, p.y); // 0..255
      const z = - (pv / 255.0) * maxDepth; // negative depth
      g += `G1 X${x.toFixed(3)} Y${y.toFixed(3)} Z${z.toFixed(3)} F${feed}\n`;
    }
    g += `G0 Z5\n`;
  }

  g += `M5\nG0 X0 Y0\nM30\n`;
  return g;
}

/* ----------------------------------------------------------
  3D preview with Three.js: heightmap + toolpaths overlay
  - Creates a plane geometry sized by preview dimensions but scaled for performance
  - Samples grayscale map at lower resolution (procRes)
-----------------------------------------------------------*/
let threeScene, threeCamera, threeRenderer, threeControls, heightMesh, pathsGroup;
function initThree(container){
  if(threeRenderer) return;
  const w = container.clientWidth, h = container.clientHeight;
  threeRenderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
  threeRenderer.setPixelRatio(window.devicePixelRatio);
  threeRenderer.setSize(w,h);
  container.appendChild(threeRenderer.domElement);
  threeScene = new THREE.Scene();
  threeCamera = new THREE.PerspectiveCamera(45, w/h, 0.1, 1000);
  threeCamera.position.set(0, -Math.max(w,h)/2, Math.max(w,h)/1.5);
  threeControls = new THREE.OrbitControls(threeCamera, threeRenderer.domElement);
  threeControls.target.set(0,0,0);
  const light = new THREE.DirectionalLight(0xffffff, 0.9);
  light.position.set(1,1,1);
  threeScene.add(light);
  const amb = new THREE.AmbientLight(0x444444); threeScene.add(amb);

  window.addEventListener('resize', ()=> {
    const cw = container.clientWidth, ch = container.clientHeight;
    threeRenderer.setSize(cw,ch);
    threeCamera.aspect = cw/ch;
    threeCamera.updateProjectionMatrix();
  });
}

function buildHeightmapAndPaths(){
  if(!grayMatForZ) { showToast('Run detect/prepare heatmap first'); return; }
  const container = document.getElementById('threeContainer');
  initThree(container);

  // clear previous
  if(heightMesh){ threeScene.remove(heightMesh); heightMesh.geometry.dispose(); heightMesh.material.dispose(); heightMesh=null; }
  if(pathsGroup){ threeScene.remove(pathsGroup); pathsGroup=null; }

  const gw = grayMatForZ.cols, gh = grayMatForZ.rows;
  const realW = parseFloat(document.getElementById('realWidth').value||200);
  const aspect = procImageSize.h>0 ? procImageSize.h / procImageSize.w : 1;
  const realH = realW * (procImageSize.h / procImageSize.w);

  // geometry resolution equal to grayMat dimensions (or clamp)
  const segX = gw-1, segY = gh-1;
  const geometry = new THREE.PlaneGeometry(realW, realH, segX, segY);
  // map z from grayMat: white->-maxDepth (we flip sign so Z up is positive)
  const maxDepth = parseFloat(document.getElementById('maxDepth').value||5);

  // plane geometry vertices are row-major: iterate and set z
  const pos = geometry.attributes.position;
  for(let j=0;j<=segY;j++){
    for(let i=0;i<=segX;i++){
      const idx = j*(segX+1) + i;
      // sample grayscale at i,j
      const pv = grayMatForZ.data[j*gw + i]; // 0..255
      const z = - (pv/255.0) * maxDepth;
      pos.setZ(idx, z);
    }
  }
  pos.needsUpdate = true;
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({color:0x8899ff,wireframe:false,side:THREE.DoubleSide,flatShading:false,metalness:0.1,roughness:0.7});
  heightMesh = new THREE.Mesh(geometry, material);
  heightMesh.rotateX(-Math.PI/2); // plane to horizontal
  // center at origin
  heightMesh.position.set(0,0,0);
  threeScene.add(heightMesh);

  // draw toolpaths (processedPaths) as line segments overlay
  pathsGroup = new THREE.Group();
  const lineMat = new THREE.LineBasicMaterial({color:0xff6666,linewidth:2});
  for(const path of processedPaths){
    const pts = [];
    for(const p of path){
      // map p.x/p.y (px in preview) -> world X,Y (centered)
      const worldX = (pxToMm(p.x, procImageSize.w, realW) - realW/2);
      const worldY = ( (pxToMm(p.y, procImageSize.w, realW) - realH/2) );
      // sample z from grayMatForZ (map coordinates)
      const pv = pixelValueAtGrayMat(p.x, p.y);
      const z = - (pv/255.0) * maxDepth;
      pts.push(new THREE.Vector3(worldX, z, worldY)); // note y-axis used for z
    }
    if(pts.length>1){
      const g = new THREE.BufferGeometry().setFromPoints(pts);
      const line = new THREE.Line(g, lineMat);
      pathsGroup.add(line);
    }
  }
  threeScene.add(pathsGroup);

  // adjust camera to fit
  const bbox = new THREE.Box3().setFromObject(heightMesh);
  const size = new THREE.Vector3(); bbox.getSize(size);
  const center = new THREE.Vector3(); bbox.getCenter(center);
  threeControls.target.copy(center);
  threeCamera.position.set(center.x, center.y - Math.max(size.x,size.z)*1.2, Math.max(size.x,size.z));
  threeCamera.lookAt(center);
  threeControls.update();

  // start render loop
  (function animate(){ threeRenderer && threeRenderer.render(threeScene, threeCamera); requestAnimationFrame(animate); })();
}

/* ----------------------------------------------------------
  UI actions
-----------------------------------------------------------*/
btnDetect.addEventListener('click', ()=> {
  if(!cvReady) { showToast('OpenCV is still loading...'); return; }
  detectContoursAndPaths();
});

btnGen.addEventListener('click', ()=>{
  const mode = document.getElementById('gcodeMode').value;
  if(processedPaths.length===0){ showToast('No processed paths. Run Detect first.'); return; }
  let g = '';
  if(mode==='2d') g = generateGcode2D(processedPaths);
  else g = generateGcode3D(processedPaths);
  gcodeOut.value = g;
  summary.textContent = `G-code generated (${mode}). Paths: ${processedPaths.length}`;
  showToast('G-code ready');
});

btnPreview3D.addEventListener('click', ()=>{
  if(!grayMatForZ || processedPaths.length===0){ showToast('Run Detect first to prepare heatmap and paths'); return; }
  buildHeightmapAndPaths();
});

btnDownload.addEventListener('click', ()=>{
  if(!gcodeOut.value) return showToast('No G-code to download');
  const blob = new Blob([gcodeOut.value], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download = 'cnc_paths.ngc'; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  showToast('G-code downloaded');
});
btnCopy.addEventListener('click', async ()=>{
  if(!gcodeOut.value) return showToast('No G-code to copy');
  try{ await navigator.clipboard.writeText(gcodeOut.value); showToast('Copied'); }
  catch(e){ showToast('Copy failed'); }
});
btnClear.addEventListener('click', ()=>{ gcodeOut.value=''; showToast('Cleared'); });

/* ----------------------------------------------------------
  Clean up on page unload
-----------------------------------------------------------*/
window.addEventListener('beforeunload', ()=>{
  if(grayMatForZ) { try{ grayMatForZ.delete(); }catch(e){} grayMatForZ = null; }
  // three cleanup if needed
});
</script>
</body>
</html>
