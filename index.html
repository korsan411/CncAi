<!doctype html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>CNC Raster 3D Engraver — Final</title>

<!-- Libraries -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipper-lib@6.4.2/clipper.js"></script>

<style>
:root{--bg:#041022;--panel:#0b1320;--accent:#06b6d4;--muted:#9bb0c8}
body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#021021,#041022);color:#e6eef6}
.app{max-width:1200px;margin:14px auto;padding:14px}
header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
h1{margin:0;color:var(--accent)}
.grid{display:grid;grid-template-columns:1fr 460px;gap:12px}
.panel{background:var(--panel);padding:12px;border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.35)}
.tabs{display:flex;gap:8px;margin-top:8px}
.tab{padding:6px 10px;border-radius:8px;cursor:pointer;background:rgba(255,255,255,0.02)}
.tab.active{background:rgba(6,182,212,0.13);color:var(--accent)}
.preview-wrap{position:relative;background:#000;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.03)}
canvas{display:block;width:100%;height:auto}
.controls-row{display:flex;gap:8px;margin-top:8px}
label{display:block;margin-top:8px;color:var(--muted)}
input,select,button,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#e6eef6;box-sizing:border-box}
button.primary{background:var(--accent);color:#042;border:none;cursor:pointer;font-weight:700}
button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
textarea{height:220px;background:#021024;color:#cfeaf2;font-family:monospace;white-space:pre-wrap;overflow:auto}
.small{font-size:13px;color:var(--muted)}
#toast{position:fixed;left:16px;bottom:16px;background:rgba(0,0,0,0.85);color:#fff;padding:8px 10px;border-radius:8px;display:none;z-index:10000}
@media(max-width:980px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="app">
  <header>
    <div>
      <h1>CNC Raster 3D Engraver — نهائي</h1>
      <div class="small">Raster-fill داخل الحد الخارجي + Heatmap → G-code Router 3D</div>
    </div>
    <div class="small" id="cvState">OpenCV: جاري التحميل...</div>
  </header>

  <div class="grid">
    <!-- Left: previews -->
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <input id="fileInput" type="file" accept="image/*"/>
          <div class="small" style="margin-top:4px">حمّل صورة (JPEG/PNG)</div>
        </div>
        <div class="small" id="imgInfo">لم تُحمّل صورة</div>
      </div>

      <div class="tabs" role="tablist">
        <div class="tab active" data-tab="original">الأصلية</div>
        <div class="tab" data-tab="heatmap">Heatmap</div>
        <div class="tab" data-tab="contour">Contour</div>
        <div class="tab" data-tab="3d">3D Preview</div>
      </div>

      <!-- Original -->
      <div id="view-original" class="preview-wrap" style="margin-top:10px">
        <canvas id="previewCanvas" width="900" height="600"></canvas>
      </div>

      <!-- Heatmap -->
      <div id="view-heatmap" class="preview-wrap" style="margin-top:10px;display:none">
        <canvas id="heatmapCanvas"></canvas>
      </div>

      <!-- Contour -->
      <div id="view-contour" class="preview-wrap" style="margin-top:10px;display:none">
        <canvas id="contourCanvas"></canvas>
      </div>

      <!-- 3D -->
      <div id="view-3d" style="margin-top:10px;display:none">
        <div id="threeContainer" style="height:440px;border-radius:8px;overflow:hidden"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="btnShowAllSegments" class="secondary">عرض كل المسارات</button>
          <button id="btnShowSampleSegments" class="secondary">عرض عيّنة المسارات</button>
        </div>
      </div>

      <div class="controls-row" style="margin-top:10px">
        <button id="btnDetect" class="primary">كشف الحواف وتهيئة Heatmap</button>
        <button id="btnQuickTest" class="secondary">اختبار سريع (low-res)</button>
        <button id="btnHeatOverlay" class="secondary">عرض Heatmap</button>
      </div>
    </div>

    <!-- Right: Settings & generation -->
    <div class="panel">
      <h3 style="margin:0 0 8px 0">إعدادات التوليد</h3>

      <label>عرض العمل الحقيقي (مم) — يربط px → mm
        <input id="realWidth" type="number" value="200" step="1"/>
      </label>

      <div style="display:flex;gap:8px;margin-top:8px">
        <label style="flex:1">Feed (مم/دقيقة)<input id="feedRate" type="number" value="800" step="1"/></label>
        <label style="flex:1">Safe Z (مم)<input id="safeZ" type="number" value="5.0" step="0.1"/></label>
      </div>

      <label style="margin-top:8px">Invert Z
        <select id="invertZ"><option value="no">لا</option><option value="yes">نعم</option></select>
      </label>

      <hr style="border-color:rgba(255,255,255,0.04)">

      <h4 style="margin:8px 0 4px 0">Raster Engraving (داخل الشكل)</h4>

      <label>اتجاه المسارات
        <select id="scanDir"><option value="x">أفقي (X)</option><option value="y">رأسي (Y)</option></select>
      </label>

      <div style="display:flex;gap:8px;margin-top:8px">
        <label style="flex:1">خطوة المسح (مم) — Step-over<input id="stepOver" type="number" value="1.0" step="0.1" min="0.1"/></label>
        <label style="flex:1">أقصى عمق (مم)<input id="maxDepth" type="number" value="3.0" step="0.1" min="0"/></label>
      </div>

      <label style="margin-top:8px">دقة Heatmap (procRes px — أكبر بُعد)
        <input id="procRes" type="number" value="360" step="16" min="32" max="1600"/>
      </label>

      <label style="margin-top:8px">حد أدنى لمساحة الشكل (نسبة مئوية من معاينة) — لإقصاء الضجيج
        <input id="minAreaPct" type="number" value="0.5" step="0.1" min="0"/>
      </label>

      <div style="display:flex;gap:8px;margin-top:12px">
        <button id="btnGen" class="primary">توليد G-code</button>
        <button id="btnDownload" class="secondary">تحميل G-code</button>
      </div>

      <label style="margin-top:8px">G-code الناتج</label>
      <textarea id="gcodeOut" readonly placeholder="G-code سيظهر هنا..."></textarea>

      <div id="timeEst" class="small" style="margin-top:8px">تقدير الوقت: —</div>
      <div id="summary" class="small" style="margin-top:6px">حالة: جاهز</div>
    </div>
  </div>
</div>

<div id="toast"></div>

<script>
/* ================= Utilities & State ================= */
const toast = document.getElementById('toast');
function showToast(msg, ms=2500){ toast.textContent = msg; toast.style.display = 'block'; clearTimeout(toast._t); toast._t = setTimeout(()=>toast.style.display='none', ms); }

let cvReady = false;
function markCvReady(){ cvReady = true; document.getElementById('cvState').textContent = 'OpenCV جاهز'; showToast('OpenCV جاهز'); }
function waitForCv(){ if(window.cv && cv.getBuildInformation) markCvReady(); else if(window.cv) cv.onRuntimeInitialized = markCvReady; else setTimeout(waitForCv,200); }
waitForCv();

const previewCanvas = document.getElementById('previewCanvas');
const heatmapCanvas = document.getElementById('heatmapCanvas');
const contourCanvas = document.getElementById('contourCanvas');
const pctx = previewCanvas.getContext('2d');
const hctx = heatmapCanvas.getContext('2d');
const cctx = contourCanvas.getContext('2d');

let originalImage = null;
let procImageSize = {w:0,h:0};
let grayMat = null; // scaled gray mat (cols x rows)
let chosenContourMat = null; // Mat clone of chosen contour in preview px coords
let outerContours = []; // array of {contour: Mat, area}
let _lastCutSegments = []; // used for 3D overlay

const CLIP_SCALE = 1000; // Clipper scale for integer robustness

/* Jet LUT for heatmap visualization */
const JET_LUT = (() => {
  const lut = new Uint8ClampedArray(256*3);
  for(let i=0;i<256;i++){
    const x = i/255;
    const r = Math.round(255 * Math.max(Math.min(1.5 - Math.abs(4*x-3), 1), 0));
    const g = Math.round(255 * Math.max(Math.min(1.5 - Math.abs(4*x-2), 1), 0));
    const b = Math.round(255 * Math.max(Math.min(1.5 - Math.abs(4*x-1), 1), 0));
    lut[i*3+0]=r; lut[i*3+1]=g; lut[i*3+2]=b;
  }
  return lut;
})();

/* ================= Tabs logic ================= */
document.querySelectorAll('.tab').forEach(t => {
  t.addEventListener('click', ()=> {
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    const tab = t.dataset.tab;
    document.getElementById('view-original').style.display = (tab === 'original') ? 'block' : 'none';
    document.getElementById('view-heatmap').style.display = (tab === 'heatmap') ? 'block' : 'none';
    document.getElementById('view-contour').style.display = (tab === 'contour') ? 'block' : 'none';
    document.getElementById('view-3d').style.display = (tab === '3d') ? 'block' : 'none';
    // rebuild 3D if needed
    if(tab === '3d' && grayMat) build3DPreview();
  });
});
/* initialize visible */
document.querySelector('.tab[data-tab="original"]').classList.add('active');
document.getElementById('view-original').style.display = 'block';

/* ================= Image load & preview ================= */
document.getElementById('fileInput').addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => {
    originalImage = img;
    // scale preview to max 900x600 while preserving aspect
    const maxW = 900, maxH = 600;
    const ratio = Math.min(maxW/img.width, maxH/img.height, 1);
    previewCanvas.width = Math.round(img.width * ratio);
    previewCanvas.height = Math.round(img.height * ratio);
    procImageSize.w = previewCanvas.width;
    procImageSize.h = previewCanvas.height;
    pctx.clearRect(0,0,previewCanvas.width, previewCanvas.height);
    pctx.drawImage(img, 0, 0, previewCanvas.width, previewCanvas.height);
    document.getElementById('imgInfo').textContent = `معاينة: ${previewCanvas.width}×${previewCanvas.height}`;
    document.getElementById('summary').textContent = 'صورة محمّلة — اضغط "كشف الحواف"';
    showToast('تم تحميل الصورة');
    // clear previous mats
    if(grayMat){ try{ grayMat.delete(); } catch(e){} grayMat=null; }
    if(chosenContourMat){ try{ chosenContourMat.delete(); } catch(e){} chosenContourMat=null; }
    outerContours.forEach(c=>{ try{ c.contour.delete(); }catch(e){} }); outerContours=[];
    _lastCutSegments = [];
  };
  img.src = url;
});

/* ================= Detect contours & prepare Heatmap (scaled) ================= */
document.getElementById('btnDetect').addEventListener('click', () => {
  if(!originalImage) return showToast('حمّل صورة أولاً');
  if(!cvReady) return showToast('OpenCV لا يزال يحمل');
  showToast('جاري الكشف وتهيئة Heatmap — انتظر...');

  // read preview into mat
  let src = cv.imread(previewCanvas); // RGBA
  let gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

  // blur and canny
  cv.GaussianBlur(gray, gray, new cv.Size(3,3), 0, 0, cv.BORDER_DEFAULT);
  const low = 50, high = 150;
  let edges = new cv.Mat();
  cv.Canny(gray, edges, low, high);

  // find external contours
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  // assemble contours and areas
  outerContours = [];
  const totalPreviewArea = previewCanvas.width * previewCanvas.height;
  for(let i=0;i<contours.size();i++){
    const cnt = contours.get(i);
    const area = Math.abs(cv.contourArea(cnt));
    outerContours.push({contour: cnt.clone(), area});
    // free temporary cnt
    cnt.delete();
  }
  // sort by area desc
  outerContours.sort((a,b)=>b.area - a.area);

  // filter by minAreaPct
  const minAreaPct = parseFloat(document.getElementById('minAreaPct').value || 0.5) / 100.0;
  const filtered = [];
  for(const o of outerContours){
    if(o.area >= (minAreaPct * totalPreviewArea)) filtered.push(o);
    else { try{ o.contour.delete(); } catch(e){} }
  }
  outerContours = filtered;

  // if none left, create rectangle contour (whole preview)
  if(outerContours.length === 0){
    const rect = new cv.Mat();
    rect.create(4,1,cv.CV_32SC2);
    rect.data32S[0]=0; rect.data32S[1]=0;
    rect.data32S[2]=previewCanvas.width; rect.data32S[3]=0;
    rect.data32S[4]=previewCanvas.width; rect.data32S[5]=previewCanvas.height;
    rect.data32S[6]=0; rect.data32S[7]=previewCanvas.height;
    outerContours.push({contour: rect, area: previewCanvas.width*previewCanvas.height});
  }

  // choose largest contour
  if(chosenContourMat){ try{ chosenContourMat.delete(); } catch(e){} chosenContourMat=null; }
  chosenContourMat = outerContours[0].contour.clone();

  // prepare scaled grayMat according to procRes
  const procRes = Math.max(32, Math.min(1600, parseInt(document.getElementById('procRes').value || 360)));
  const scale = Math.min(procRes / procImageSize.w, procRes / procImageSize.h, 1);
  const gw = Math.max(16, Math.round(procImageSize.w * scale));
  const gh = Math.max(16, Math.round(procImageSize.h * scale));
  const tmp = document.createElement('canvas'); tmp.width = gw; tmp.height = gh;
  tmp.getContext('2d').drawImage(previewCanvas, 0, 0, gw, gh);

  if(grayMat){ try{ grayMat.delete(); } catch(e){} grayMat=null; }
  let rgbaSmall = cv.imread(tmp);
  let graySmall = new cv.Mat();
  cv.cvtColor(rgbaSmall, graySmall, cv.COLOR_RGBA2GRAY);
  cv.GaussianBlur(graySmall, graySmall, new cv.Size(3,3), 0,0,cv.BORDER_DEFAULT);
  rgbaSmall.delete();
  grayMat = graySmall;

  // render heatmap preview and contour overlay
  renderHeatmapPreview();
  renderContourPreview();

  // cleanup mats used in detection
  try{ src.delete(); gray.delete(); edges.delete(); contours.delete(); hierarchy.delete(); } catch(e){ console.warn('cleanup detect', e); }

  document.getElementById('summary').textContent = `Heatmap: ${grayMat.cols}×${grayMat.rows} — contours: ${outerContours.length}`;
  showToast('اكتملت معالجة Heatmap والـ contours');
  build3DPreview(false); // refresh 3D preview (sample)
});

/* ================= render Heatmap & Contour previews ================= */
function renderHeatmapPreview(){
  if(!grayMat) return;
  heatmapCanvas.width = procImageSize.w;
  heatmapCanvas.height = procImageSize.h;
  // create colored image from grayMat (jet-like)
  const gw = grayMat.cols, gh = grayMat.rows;
  const id = new ImageData(gw, gh);
  for(let i=0;i<gw*gh;i++){
    const v = grayMat.data[i];
    const idx = 255 - v;
    id.data[i*4+0] = JET_LUT[idx*3+0];
    id.data[i*4+1] = JET_LUT[idx*3+1];
    id.data[i*4+2] = JET_LUT[idx*3+2];
    id.data[i*4+3] = 220;
  }
  const tmp = document.createElement('canvas'); tmp.width = gw; tmp.height = gh;
  tmp.getContext('2d').putImageData(id, 0, 0);
  hctx.clearRect(0,0,heatmapCanvas.width, heatmapCanvas.height);
  hctx.drawImage(tmp, 0, 0, heatmapCanvas.width, heatmapCanvas.height);
}

function renderContourPreview(){
  if(!chosenContourMat) return;
  contourCanvas.width = procImageSize.w;
  contourCanvas.height = procImageSize.h;
  cctx.clearRect(0,0,contourCanvas.width, contourCanvas.height);
  // draw preview faint
  cctx.globalAlpha = 0.6; cctx.drawImage(previewCanvas, 0, 0); cctx.globalAlpha = 1.0;
  // draw contour
  cctx.strokeStyle = '#ffdd66'; cctx.lineWidth = 2; cctx.beginPath();
  const pts = chosenContourMat.data32S;
  if(pts && pts.length >= 6){
    for(let k=0;k<pts.length;k+=2){
      const x = pts[k], y = pts[k+1];
      if(k===0) cctx.moveTo(x,y); else cctx.lineTo(x,y);
    }
    cctx.closePath(); cctx.stroke();
  }
}

/* ================= Quick Test (low-res detect + generate) ================= */
document.getElementById('btnQuickTest').addEventListener('click', ()=>{
  if(!originalImage) return showToast('حمّل صورة أولاً');
  const prev = document.getElementById('procRes').value;
  document.getElementById('procRes').value = '160';
  document.getElementById('btnDetect').click();
  setTimeout(()=>{ document.getElementById('procRes').value = prev; showToast('اختبار سريع انتهى'); }, 900);
});

/* ================== Clipper utilities ================== */
function pxContourToClipperPath(contourMat, scale){
  const pts = contourMat.data32S;
  const path = [];
  for(let i=0;i<pts.length;i+=2){
    const x = Math.round(pts[i] * scale);
    const y = Math.round(pts[i+1] * scale);
    path.push({X:x, Y:y});
  }
  return path;
}

function makeRasterLinesAsPaths(scanDir, pxStep){
  const paths = [];
  if(scanDir === 'x'){
    for(let py = 0; py < procImageSize.h; py += pxStep){
      paths.push([{X:0, Y:py}, {X:procImageSize.w - 1, Y:py}]);
    }
  } else {
    for(let px = 0; px < procImageSize.w; px += pxStep){
      paths.push([{X:px, Y:0}, {X:px, Y:procImageSize.h - 1}]);
    }
  }
  return paths;
}

/* ================== sample gray from grayMat using preview px coords ================== */
function sampleGrayAtPreviewXY(px, py){
  if(!grayMat) return 128;
  const gw = grayMat.cols, gh = grayMat.rows;
  const gx = Math.max(0, Math.min(gw-1, Math.round((px / procImageSize.w) * (gw - 1))));
  const gy = Math.max(0, Math.min(gh-1, Math.round((py / procImageSize.h) * (gh - 1))));
  return grayMat.data[gy * gw + gx];
}

/* ================== px -> mm conversions ================== */
function pxToMmX(px){
  const realW = parseFloat(document.getElementById('realWidth').value || 200);
  return (px / procImageSize.w) * realW;
}
function pxToMmY(py){
  const realW = parseFloat(document.getElementById('realWidth').value || 200);
  const realH = realW * (procImageSize.h / procImageSize.w);
  return (py / procImageSize.h) * realH;
}

/* ================== Main Generator using Clipper ================== */
function generateRasterGcodeInsideShape(){
  if(!grayMat || !chosenContourMat) { showToast('الرجاء تنفيذ كشف الحواف أولاً'); return ''; }

  const scanDir = document.getElementById('scanDir').value;
  const stepOverMm = parseFloat(document.getElementById('stepOver').value || 1.0);
  const maxDepth = parseFloat(document.getElementById('maxDepth').value || 3.0);
  const feed = parseFloat(document.getElementById('feedRate').value || 800);
  const safeZ = parseFloat(document.getElementById('safeZ').value || 5.0);
  const invertZ = document.getElementById('invertZ').value === 'yes';
  const realW = parseFloat(document.getElementById('realWidth').value || 200);
  const realH = realW * (procImageSize.h / procImageSize.w);

  // px per mm
  const pxPerMmX = procImageSize.w / realW;
  const pxPerMmY = procImageSize.h / realH;

  // px step for scanning
  const pxStep = Math.max(1, Math.round((scanDir === 'x') ? (stepOverMm * pxPerMmY) : (stepOverMm * pxPerMmX)));

  // build raster lines in preview px coordinates (open paths)
  const rasterLines = makeRasterLinesAsPaths(scanDir, pxStep);

  // convert chosenContour to clipper polygon (scaled)
  const clipPolygon = pxContourToClipperPath(chosenContourMat, CLIP_SCALE);

  const resultSegments = []; // each segment: array of {x:float, y:float} in preview px

  // clip each raster line with polygon
  for(let rlIdx=0; rlIdx<rasterLines.length; rlIdx++){
    const rl = rasterLines[rlIdx];
    const subj = [ rl.map(p => ({ X: Math.round(p.X * CLIP_SCALE), Y: Math.round(p.Y * CLIP_SCALE) })) ];
    const clip = [ clipPolygon ];
    const clipper = new ClipperLib.Clipper();
    try{
      clipper.AddPaths(subj, ClipperLib.PolyType.ptSubject, false); // open
      clipper.AddPaths(clip, ClipperLib.PolyType.ptClip, true);     // closed polygon
      const sol = new ClipperLib.Paths();
      clipper.Execute(ClipperLib.ClipType.ctIntersection, sol, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);
      for(const sp of sol){
        if(sp.length < 2) continue;
        // convert sol path back to preview px (float)
        const seg = sp.map(pt => ({ x: pt.X / CLIP_SCALE, y: pt.Y / CLIP_SCALE }));
        // store
        resultSegments.push({seg, rowIndex: rlIdx});
      }
    } catch(e){
      console.warn('Clipper error', e);
    }
  }

  if(resultSegments.length === 0) { showToast('لم يتم توليد أي مقطع داخل الشكل — تفقد الإعدادات'); return ''; }

  // Order segments by rowIndex and direction (zigzag per row)
  // Group segments by rowIndex
  const rowsMap = new Map();
  for(const rs of resultSegments){
    if(!rowsMap.has(rs.rowIndex)) rowsMap.set(rs.rowIndex, []);
    rowsMap.get(rs.rowIndex).push(rs.seg);
  }
  const orderedSegments = [];
  const sortedRowIndices = Array.from(rowsMap.keys()).sort((a,b)=>a-b);
  for(const rowIdx of sortedRowIndices){
    let segs = rowsMap.get(rowIdx);
    // optionally sort segments by X (start) for stable order
    segs.sort((A,B)=> (A[0].x - B[0].x));
    // zigzag across rows: even -> left->right, odd -> right->left
    const forward = (rowIdx % 2 === 0);
    if(!forward) segs.reverse();
    for(const s of segs) orderedSegments.push(s);
  }

  // sample along each polyline and convert to mm + Z
  const sampleStepPx = 1; // 1 px sampling resolution
  const cutSegmentsG = []; // arrays of points {x(mm), y(mm), z(mm)}
  let totalCutLenMm = 0;
  let totalRapidLenMm = 0;

  for(let idx=0; idx<orderedSegments.length; idx++){
    const seg = orderedSegments[idx];
    // densify polyline by sampling between consecutive vertices
    const ptsPx = [];
    for(let k=0;k<seg.length-1;k++){
      const a = seg[k], b = seg[k+1];
      const dx = b.x - a.x, dy = b.y - a.y;
      const distPx = Math.hypot(dx,dy);
      const steps = Math.max(1, Math.round(distPx / sampleStepPx));
      for(let s=0;s<=steps;s++){
        const t = s/steps;
        const x = a.x + dx*t;
        const y = a.y + dy*t;
        const last = ptsPx[ptsPx.length-1];
        if(!last || Math.hypot(x-last.x, y-last.y) >= 0.4) ptsPx.push({x,y});
      }
    }
    if(ptsPx.length < 2) continue;

    // convert to mm + compute z from grayMat
    const ptsMm = ptsPx.map(p => {
      const px = Math.round(p.x), py = Math.round(p.y);
      const gv = sampleGrayAtPreviewXY(px, py); // 0..255
      let z = - ((255 - gv) / 255.0) * maxDepth; // negative depth (cut into material)
      if(invertZ) z = -z;
      return { x: pxToMmX(px), y: pxToMmY(py), z: z };
    });

    // measure XY length
    let segLen = 0;
    for(let i=1;i<ptsMm.length;i++){
      segLen += Math.hypot(ptsMm[i].x - ptsMm[i-1].x, ptsMm[i].y - ptsMm[i-1].y);
    }
    totalCutLenMm += segLen;
    cutSegmentsG.push(ptsMm);
  }

  // estimate rapid travel length approx between segments (start points)
  let prevEnd = {x:0,y:0};
  for(let i=0;i<cutSegmentsG.length;i++){
    const seg = cutSegmentsG[i];
    const start = seg[0], end = seg[seg.length-1];
    // from prev end to start
    totalRapidLenMm += Math.hypot(start.x - prevEnd.x, start.y - prevEnd.y);
    prevEnd = end;
  }
  // return home
  totalRapidLenMm += Math.hypot(prevEnd.x - 0, prevEnd.y - 0);

  // compute time estimates
  const cutTimeMin = totalCutLenMm / (feed || 1);
  const rapidFeed = Math.max(feed * 3, 100); // assume rapids 3x or at least 100 mm/min
  const rapidTimeMin = totalRapidLenMm / rapidFeed;
  const totalTimeMin = cutTimeMin + rapidTimeMin;
  document.getElementById('timeEst').textContent = `تقدير الوقت (دقائق): قطع ≈ ${cutTimeMin.toFixed(2)}, تنقّل ≈ ${rapidTimeMin.toFixed(2)}, إجمالي ≈ ${totalTimeMin.toFixed(2)}`;

  // build G-code
  const lines = [];
  lines.push('; --- Raster Engraving inside contour (Generated) ---');
  lines.push(`; Date: ${new Date().toLocaleString()}`);
  lines.push('; Units: mm, Absolute positioning');
  lines.push('G21');
  lines.push('G90');
  lines.push('G17');
  lines.push(`G0 Z${safeZ.toFixed(3)} ; safe height`);
  lines.push('; M3 S<rpm> ; enable spindle if desired (uncomment and set RPM)');

  // emit segments with rapid and cut motions
  for(let si=0; si<cutSegmentsG.length; si++){
    const seg = cutSegmentsG[si];
    if(seg.length === 0) continue;
    const p0 = seg[0];
    lines.push(`; segment ${si+1} start`);
    lines.push(`G0 X${p0.x.toFixed(3)} Y${p0.y.toFixed(3)} Z${safeZ.toFixed(3)}`);
    // plunge to first Z at feed (we use feed for plunge)
    lines.push(`G1 Z${p0.z.toFixed(3)} F${feed}`);
    // cut along these points
    for(let k=0;k<seg.length;k++){
      const p = seg[k];
      lines.push(`G1 X${p.x.toFixed(3)} Y${p.y.toFixed(3)} Z${p.z.toFixed(3)} F${feed}`);
    }
    // retract
    lines.push(`G0 Z${safeZ.toFixed(3)}`);
  }

  lines.push('');
  lines.push('M5 ; stop spindle');
  lines.push('G0 X0 Y0 ; return home');
  lines.push('M30 ; end');

  // store segments for 3D preview
  window._lastCutSegments = cutSegmentsG;

  // final stats in summary
  document.getElementById('summary').textContent = `Segments: ${cutSegmentsG.length} — Cut length ≈ ${totalCutLenMm.toFixed(1)} mm`;

  return lines.join('\n');
}

/* ================= Buttons actions ================= */
document.getElementById('btnGen').addEventListener('click', ()=>{
  if(!grayMat || !chosenContourMat) return showToast('نفّذ كشف الحواف أولاً');
  const g = generateRasterGcodeInsideShape();
  if(!g) return;
  document.getElementById('gcodeOut').value = g;
  showToast('تم توليد G-code');
  // switch to 3D for inspection
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  document.querySelector('.tab[data-tab="3d"]').classList.add('active');
  document.getElementById('view-original').style.display='none';
  document.getElementById('view-heatmap').style.display='none';
  document.getElementById('view-contour').style.display='none';
  document.getElementById('view-3d').style.display='block';
  setTimeout(()=> build3DPreview(false), 80);
});

document.getElementById('btnDownload').addEventListener('click', ()=>{
  const txt = document.getElementById('gcodeOut').value;
  if(!txt) return showToast('لا يوجد G-code للتحميل');
  const blob = new Blob([txt], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'raster_inside_shape.ngc'; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
  showToast('تم تحميل ملف G-code');
});

/* Heatmap overlay button */
document.getElementById('btnHeatOverlay').addEventListener('click', ()=>{
  if(!grayMat) return showToast('لم يتم تهيئة Heatmap');
  // switch to heatmap tab
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  document.querySelector('.tab[data-tab="heatmap"]').classList.add('active');
  document.getElementById('view-original').style.display='none';
  document.getElementById('view-heatmap').style.display='block';
  document.getElementById('view-contour').style.display='none';
  document.getElementById('view-3d').style.display='none';
});

/* Quick Test (generate with coarse sampling) */
document.getElementById('btnQuickTest').addEventListener('click', ()=>{
  // do quick detect with small procRes if not yet processed
  const prevProc = document.getElementById('procRes').value;
  document.getElementById('procRes').value = '160';
  document.getElementById('btnDetect').click();
  setTimeout(()=>{ document.getElementById('procRes').value = prevProc; document.getElementById('btnGen').click(); }, 900);
});

/* show all / sample segments in 3D */
document.getElementById('btnShowAllSegments').addEventListener('click', ()=> build3DPreview(true));
document.getElementById('btnShowSampleSegments').addEventListener('click', ()=> build3DPreview(false));

/* ==================== 3D Preview: fixed rendering & lights ==================== */
let threeRenderer, threeScene, threeCamera, threeControls, heightMesh, segmentsGroup;
function initThree(container){
  while(container.firstChild) container.removeChild(container.firstChild);
  threeRenderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  threeRenderer.setPixelRatio(window.devicePixelRatio);
  threeRenderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(threeRenderer.domElement);
  threeScene = new THREE.Scene();
  threeCamera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.1, 2000);
  threeCamera.position.set(0, -300, 300);
  threeControls = new THREE.OrbitControls(threeCamera, threeRenderer.domElement);
  threeScene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.8));
  const dl = new THREE.DirectionalLight(0xffffff, 0.9); dl.position.set(1,2,3); threeScene.add(dl);
  threeScene.add(new THREE.AmbientLight(0x404040, 0.6));
  (function animate(){ if(threeRenderer) threeRenderer.render(threeScene, threeCamera); requestAnimationFrame(animate); })();
}

function build3DPreview(showAll=false){
  if(!grayMat) return;
  const container = document.getElementById('threeContainer');
  initThree(container);

  // cleanup previous
  if(heightMesh){ try{ threeScene.remove(heightMesh); heightMesh.geometry.dispose(); heightMesh.material.dispose(); } catch(e){} heightMesh=null; }
  if(segmentsGroup){ try{ threeScene.remove(segmentsGroup); } catch(e){} segmentsGroup=null; }

  const gw = grayMat.cols, gh = grayMat.rows;
  const realW = parseFloat(document.getElementById('realWidth').value || 200);
  const realH = realW * (procImageSize.h / procImageSize.w);
  const maxDepth = parseFloat(document.getElementById('maxDepth').value || 3);

  // reduce geometry resolution for performance
  const segX = Math.min(160, Math.max(8, gw - 1));
  const segY = Math.min(160, Math.max(8, gh - 1));

  const geometry = new THREE.PlaneGeometry(realW, realH, segX, segY);
  geometry.rotateX(-Math.PI/2); // make Z up
  const pos = geometry.attributes.position;

  // set Z values per vertex
  for(let j=0;j<=segY;j++){
    for(let i=0;i<=segX;i++){
      const idx = j*(segX+1) + i;
      const gx = Math.round((i / segX) * (gw - 1));
      const gy = Math.round((j / segY) * (gh - 1));
      const pv = grayMat.data[gy * gw + gx];
      const meshZ = ((255 - pv) / 255.0) * maxDepth;
      pos.setZ(idx, meshZ);
    }
  }
  pos.needsUpdate = true;
  geometry.computeVertexNormals();

  const mat = new THREE.MeshStandardMaterial({color:0xddeeff, metalness:0.05, roughness:0.7, side:THREE.DoubleSide});
  heightMesh = new THREE.Mesh(geometry, mat);
  threeScene.add(heightMesh);

  // draw chosen contour
  if(chosenContourMat){
    const pts = chosenContourMat.data32S;
    const verts = [];
    for(let k=0;k<pts.length;k+=2){
      const px = pts[k], py = pts[k+1];
      const wx = pxToMmX(px) - realW/2;
      const wy = pxToMmY(py) - realH/2;
      verts.push(new THREE.Vector3(wx, 0.5, wy));
    }
    if(verts.length>1){
      const g = new THREE.BufferGeometry().setFromPoints(verts);
      const line = new THREE.Line(g, new THREE.LineBasicMaterial({color:0xffaa00, linewidth:2}));
      threeScene.add(line);
    }
  }

  // draw cut segments overlay (use window._lastCutSegments)
  const segs = window._lastCutSegments || [];
  segmentsGroup = new THREE.Group();
  const cutMat = new THREE.LineBasicMaterial({color:0xff4444});
  const rapidMat = new THREE.LineBasicMaterial({color:0x999999});
  const maxShow = showAll ? segs.length : Math.min(120, segs.length);
  for(let i=0;i<maxShow;i++){
    const s = segs[i];
    const pts = [];
    for(const p of s){
      const wx = p.x - realW/2;
      const wy = p.y - realH/2;
      const wz = Math.abs(p.z) + 0.5;
      pts.push(new THREE.Vector3(wx, wz, wy));
    }
    if(pts.length > 1){
      const g = new THREE.BufferGeometry().setFromPoints(pts);
      const line = new THREE.Line(g, cutMat);
      segmentsGroup.add(line);
    }
  }
  threeScene.add(segmentsGroup);

  // center camera
  const box = new THREE.Box3().setFromObject(heightMesh);
  if(segmentsGroup) box.union(new THREE.Box3().setFromObject(segmentsGroup));
  const center = box.getCenter(new THREE.Vector3());
  const size = box.getSize(new THREE.Vector3());
  threeControls.target.copy(center);
  const diag = Math.max(size.x, size.y, size.z);
  const dist = diag * 1.8 + 80;
  threeCamera.position.set(center.x, center.y + dist, center.z + dist/3);
  threeCamera.lookAt(center);
  threeControls.update();
}

/* cleanup on unload */
window.addEventListener('beforeunload', ()=>{
  if(grayMat){ try{ grayMat.delete(); } catch(e){} grayMat=null; }
  if(chosenContourMat){ try{ chosenContourMat.delete(); } catch(e){} chosenContourMat=null; }
  if(outerContours){ outerContours.forEach(c=>{ try{ c.contour.delete(); } catch(e){} }); outerContours=[]; }
});

</script>
</body>
</html>
