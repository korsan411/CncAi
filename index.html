<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8">
  <title>CNC AI Preview</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#fdfdfd; --text:#333; --header-bg:linear-gradient(90deg,#4a90e2,#67b0f5);
      --card:#fff; --border:#ccc; --btn:#f0f0f0; --btn-hover:#e0e0e0;
    }
    body.dark{ --bg:#1e1e1e; --text:#eee; --header-bg:linear-gradient(90deg,#222,#555); --card:#2a2a2a; --border:#555; --btn:#444; --btn-hover:#666; }
    body{
      font-family: "Segoe UI", Arial, sans-serif;
      background:var(--bg); color:var(--text); margin:0; padding:0;
      display:flex; flex-direction:column; align-items:center; min-height:100vh;
    }
    header{
      width:100%; background:var(--header-bg); color:#fff; padding:14px;
      display:flex; align-items:center; justify-content:center; position:relative; box-shadow:0 2px 6px rgba(0,0,0,0.12);
      font-weight:700;
    }
    #themeToggle{ position:absolute; right:12px; top:50%; transform:translateY(-50%); background:transparent; border:none; color:#fff; cursor:pointer; font-size:18px; }
    #gcodeLink{ position:absolute; left:12px; top:50%; transform:translateY(-50%); color:#fff; text-decoration:none; background:rgba(255,255,255,0.08); padding:6px 10px; border-radius:6px; }
    .file-upload{ margin:18px 0; text-align:center; }
    .file-upload input[type=file]{ padding:8px; border-radius:6px; border:1px solid var(--border); background:var(--card); color:var(--text); }
    .container{ width:100%; max-width:950px; padding:12px; box-sizing:border-box; }
    .preview-block{ background:var(--card); border-radius:10px; padding:14px; margin-bottom:16px; box-shadow:0 2px 8px rgba(0,0,0,0.06); text-align:center; }
    .preview-title{ font-weight:700; margin-top:8px; color:var(--text); }
    canvas, #preview3d canvas{ border:1px solid var(--border); border-radius:8px; max-width:100%; display:block; margin:8px auto; background:#fff; }
    .options{ display:flex; gap:12px; flex-wrap:wrap; justify-content:center; align-items:center; margin-top:8px; }
    .colormap-controls{ display:flex; gap:8px; justify-content:center; flex-wrap:wrap; margin-top:8px; }
    .colormap-controls button{ padding:8px 12px; border-radius:8px; border:none; cursor:pointer; background:var(--btn); color:var(--text); font-weight:600; }
    .colormap-controls button:hover{ background:var(--btn-hover); transform:translateY(-2px); }
    label{ font-size:14px; display:flex; align-items:center; gap:8px; }
    input[type=range]{ vertical-align:middle; }
    @media (max-width:720px){ header{ font-size:16px } .options{ flex-direction:column } }
  </style>
</head>
<body>
  <header>ğŸ› ï¸ CNC AI Preview
    <button id="themeToggle" title="ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø«ÙŠÙ…">ğŸŒ™</button>
    <a id="gcodeLink" href="gcode.html">âš™ï¸ ØªÙˆÙ„ÙŠØ¯ G-code</a>
  </header>

  <div class="file-upload container">
    <input type="file" id="fileInput" accept="image/*">
  </div>

  <div class="container">
    <div class="preview-block">
      <h3 class="preview-title">ğŸ“· Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</h3>
      <canvas id="preview2d" aria-label="ØµÙˆØ±Ø© 2D"></canvas>
    </div>

    <div class="preview-block">
      <h3 class="preview-title">ğŸŒ€ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</h3>
      <div id="preview3d" style="width:420px;height:420px;margin:0 auto;"></div>
      <div class="options">
        <label>ğŸ”„ Ø³Ø±Ø¹Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù†: <input id="rotationSpeed" type="range" min="0" max="0.05" step="0.001" value="0.01"></label>
        <label>ğŸ” Ø²ÙˆÙ…: <input id="zoomControl" type="range" min="80" max="800" step="10" value="200"></label>
      </div>
    </div>

    <div class="preview-block">
      <h3 class="preview-title">ğŸŒˆ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª (Heatmap)</h3>
      <canvas id="heatmap" aria-label="Heatmap"></canvas>
      <div class="colormap-controls" style="margin-top:10px;">
        <button onclick="setColormap('jet')" title="Jet">ğŸŒˆ Jet</button>
        <button onclick="setColormap('hot')" title="Hot">ğŸ”¥ Hot</button>
        <button onclick="setColormap('cool')" title="Cool">â„ï¸ Cool</button>
        <button onclick="setColormap('gray')" title="Gray">âšª Gray</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    // Ø¹Ù†Ø§ØµØ± DOM
    const fileInput = document.getElementById('fileInput');
    const canvas2d = document.getElementById('preview2d');
    const ctx2d = canvas2d.getContext('2d');
    const heatmap = document.getElementById('heatmap');
    const ctxHeat = heatmap.getContext('2d');
    const preview3d = document.getElementById('preview3d');

    const rotationSpeedInput = document.getElementById('rotationSpeed');
    const zoomControl = document.getElementById('zoomControl');
    const themeToggle = document.getElementById('themeToggle');

    // Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ - Three.js
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    let DPR = Math.min(window.devicePixelRatio || 1, 2);
    renderer.setPixelRatio(DPR);
    // Ø­Ø¬Ù… Ø«Ø§Ø¨Øª/Ù…Ø¹Ù‚ÙˆÙ„ Ù„Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Ø«Ø§Ø¨Øª ÙƒÙ…Ø§ Ø·Ù„Ø¨Øª)
    const RENDER_SIZE = 420;
    renderer.setSize(RENDER_SIZE, RENDER_SIZE, false);
    preview3d.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(0, 1, 1).normalize();
    scene.add(light);

    camera.position.z = 200;
    camera.lookAt(0,0,0);

    let mesh = null;
    let rotationSpeed = parseFloat(rotationSpeedInput.value) || 0.01;
    let currentColormap = 'jet';
    let lastImage = null;        // Ù†Ø­ØªÙØ¸ Ø¨Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£Ø®ÙŠØ±Ø© Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ù€ colormap Ø¨Ø¯ÙˆÙ† Ø¥Ø¹Ø§Ø¯Ø© Ø±ÙØ¹
    let heightRaw = null;        // raw rgba data from temp canvas (full image)
    let heightW = 0, heightH = 0;

    // Ù…Ø³Ø­ Ø§Ù„Ù…ÙŠØ´ Ø§Ù„Ø­Ø§Ù„ÙŠ ÙˆØªØ­Ø±ÙŠØ± Ø§Ù„Ø°Ø§ÙƒØ±Ø©
    function disposeMesh() {
      if (!mesh) return;
      try {
        mesh.geometry.dispose();
      } catch(e){}
      try {
        if(Array.isArray(mesh.material)){
          mesh.material.forEach(m => m.dispose());
        } else {
          mesh.material.dispose();
        }
      } catch(e){}
      scene.remove(mesh);
      mesh = null;
    }

    // ØªØ­ÙˆÙŠÙ„ Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‰ Ù„ÙˆÙ† Ø­Ø³Ø¨ Ø§Ù„Ø®Ø±ÙŠØ·Ø©
    function getHeatColor(value, map) {
      value = Math.max(0, Math.min(1, value));
      let r=0,g=0,b=0;
      if (map === 'jet') {
        r = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-3),1),0));
        g = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-2),1),0));
        b = Math.floor(255 * Math.max(Math.min(1.5 - Math.abs(4*value-1),1),0));
      } else if (map === 'hot') {
        r = Math.floor(255 * Math.min(1, 3*value));
        g = Math.floor(255 * Math.min(1, 3*value-1)); g = Math.max(g,0);
        b = Math.floor(255 * Math.min(1, 3*value-2)); b = Math.max(b,0);
      } else if (map === 'cool') {
        r = Math.floor(255 * value);
        g = Math.floor(255 * (1-value));
        b = 255;
      } else if (map === 'gray') {
        r = g = b = Math.floor(255 * value);
      }
      return {r,g,b};
    }

    // Ø¥Ù†Ø´Ø§Ø¡ height map Ùˆ mesh Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
    function createHeightMap(img) {
      lastImage = img;
      // Ù†Ø£Ø®Ø° Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù…Ù† Ø§Ù„ØµÙˆØ±Ø© (full-size) ÙÙŠ temp canvas
      const w = img.width;
      const h = img.height;
      heightW = w; heightH = h;

      const temp = document.createElement('canvas');
      temp.width = w; temp.height = h;
      const tctx = temp.getContext('2d');
      tctx.drawImage(img, 0, 0, w, h);
      const imgData = tctx.getImageData(0,0,w,h).data;
      // Ø­ÙØ¸ raw Ø¨ÙŠØ§Ù†Ø§Øª (Ù†Ø³Ø®Ø©) Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§ Ù„Ø§Ø­Ù‚Ù‹Ø§
      heightRaw = new Uint8ClampedArray(imgData); // 4*w*h

      // Ù†Ø¹Ù…Ù„ Ù†Ø³Ø®Ø© Ù…Ù†Ø®ÙØ¶Ø© Ø§Ù„Ø¯Ù‚Ø© Ù„Ù„Ù€ mesh Ø­ØªÙ‰ Ù„Ø§ Ù†Ø³Ø¨Ø¨ ØªØ­Ù…ÙŠÙ„Ù‹Ø§ Ø¹Ø§Ù„ÙŠÙ‹Ø§ (ØªÙˆØ§Ø²Ù† Ø£Ø¯Ø§Ø¡/ØªÙØ§ØµÙŠÙ„)
      // Ù„Ùˆ Ø§Ù„ØµÙˆØ±Ø© ØµØºÙŠØ±Ø© Ù†Ø³ØªØ®Ø¯Ù… Ø£Ø¨Ø¹Ø§Ø¯Ù‡Ø§ØŒ ÙˆØ¥Ù„Ø§ Ù†Ø®ÙØ¶ Ø¥Ù„Ù‰ Ø£Ù‚ØµÙ‰ 200 Ø¨ÙƒØ³Ù„ Ù„ÙƒÙ„ Ø¨Ø¹Ø¯
      const MAX_MESH_DIM = 200;
      const meshW = Math.min(w, MAX_MESH_DIM);
      const meshH = Math.min(h, MAX_MESH_DIM);

      // Ø¹ÙŠÙ† canvas Ù…ØµØºÙ‘Ø± Ù„Ù„Ø¨Ù†Ø§Ø¡ (sampling)
      const sample = document.createElement('canvas');
      sample.width = meshW; sample.height = meshH;
      const sctx = sample.getContext('2d');
      // disable smoothing for sharper sampling if desired:
      sctx.imageSmoothingEnabled = false;
      sctx.drawImage(img, 0, 0, meshW, meshH);
      const sdata = sctx.getImageData(0,0,meshW,meshH).data;

      // Ø­Ø³Ø§Ø¨ min/max Ù„Ù„Ù€ normalization
      let min = 255, max = 0;
      const heights = new Float32Array(meshW * meshH);
      for (let y=0;y<meshH;y++){
        for (let x=0;x<meshW;x++){
          const idx = (y*meshW + x)*4;
          const brightness = sdata[idx]; // R
          heights[y*meshW + x] = brightness/255;
          if (brightness < min) min = brightness;
          if (brightness > max) max = brightness;
        }
      }
      const denom = (max - min) || 1;

      // ØªÙ†Ø¸ÙŠÙ mesh Ø§Ù„Ù‚Ø¯ÙŠÙ…
      disposeMesh();

      // Ø¨Ù†Ø§Ø¡ geometry
      const geom = new THREE.PlaneGeometry(100, 100, meshW-1, meshH-1);
      const pos = geom.attributes.position.array;
      const colors = new Float32Array((meshW*meshH)*3);

      for (let i=0;i<geom.attributes.position.count;i++){
        const stride = i*3;
        // xIndex, yIndex Ø­Ø³Ø¨ ØªØ±ØªÙŠØ¨ Three.js: Ù†ÙØªØ±Ø¶ ØªØ±ØªÙŠØ¨ ØµÙ-Ø¹Ù…ÙˆØ¯
        const xIdx = i % meshW;
        const yIdx = Math.floor(i / meshW);
        const value = heights[yIdx*meshW + xIdx];
        // scale Z: Ø«Ø§Ø¨Øª Ø¨Ø¯Ù‚Ø© Ø¢Ù…Ù†Ø©
        const zVal = value * 80; // ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¹Ø¯ÙŠÙ„ Ø«Ø§Ø¨Øª Ø§Ù„ØªÙƒØ¨ÙŠØ±
        pos[stride + 2] = zVal;
        // Ù„ÙˆÙ† Ù…Ù† Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©
        const c = getHeatColor(value, currentColormap);
        colors[i*3+0] = c.r/255;
        colors[i*3+1] = c.g/255;
        colors[i*3+2] = c.b/255;
      }

      geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
      geom.computeVertexNormals();
      // Ø§Ø¬Ø¨Ø§Ø± Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
      if (geom.attributes.position) geom.attributes.position.needsUpdate = true;
      if (geom.attributes.normal) geom.attributes.normal.needsUpdate = true;
      if (geom.attributes.color) geom.attributes.color.needsUpdate = true;

      const mat = new THREE.MeshLambertMaterial({ vertexColors: true, side: THREE.DoubleSide });
      mesh = new THREE.Mesh(geom, mat);
      scene.add(mesh);

      // Ø±Ø³Ù… heatmap ÙƒØ§Ù…Ù„ Ø§Ù„Ø¯Ù‚Ø©
      drawHeatmapFromRaw(heightRaw, w, h, min, max);
      // Ø¶Ø¨Ø· Ø§Ù„Ù…Ø¸Ù‡Ø±
      camera.lookAt(0,0,0);
      renderer.render(scene, camera);
    }

    // Ø±Ø³Ù… heatmap Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø®Ø²Ù†Ø© (full resolution)
    function drawHeatmapFromRaw(rawData, w, h, min, max){
      if(!rawData) return;
      const denom = (max - min) || 1;
      // Ù†Ø±ÙŠØ¯ Ø£Ù† ÙŠÙƒÙˆÙ† canvas Ø¨Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠ (Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø·Ù„Ø¨ Ø°Ù„Ùƒ)
      heatmap.width = w;
      heatmap.height = h;
      const out = ctxHeat.createImageData(w, h);
      for (let y=0;y<h;y++){
        for (let x=0;x<w;x++){
          const idx = (y*w + x)*4;
          const brightness = rawData[idx];
          let norm = (brightness - min)/denom;
          norm = Math.max(0, Math.min(1, norm));
          const c = getHeatColor(norm, currentColormap);
          out.data[idx] = c.r;
          out.data[idx+1] = c.g;
          out.data[idx+2] = c.b;
          out.data[idx+3] = 255;
        }
      }
      // Ø¶Ø¹ Ø§Ù„ØµÙˆØ±Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù€ canvas (full-res)
      ctxHeat.putImageData(out, 0, 0);
      // Ø¥Ø°Ø§ Ø£Ø±Ø¯Ù†Ø§ ØªÙƒØ¨ÙŠØ± Ø§Ù„Ø¹Ø±Ø¶ Ø¨ØµØ±ÙŠÙ‹Ø§ Ù„Ù…Ù„Ø¡ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ù†Ø±Ø³Ù…Ù‡Ø§ Ø¨Ù†Ø³Ø®Ø© Ù…ÙƒØ¨Ø±Ø©:
      // Ù‡Ù†Ø§ Ù†ØªØ±ÙƒÙ‡Ø§ Ø¨Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠ. Ø¥Ù† Ø£Ø±Ø¯Øª ØªÙƒØ¨ÙŠØ±Ø§Ù‹ Ø¨ØµØ±ÙŠØ§Ù‹ØŒ ÙŠÙ…ÙƒÙ†Ùƒ ÙÙƒ Ø§Ù„ØªØ¹Ù„ÙŠÙ‚:
      // const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h; tmp.getContext('2d').putImageData(out,0,0);
      // ctxHeat.drawImage(tmp, 0, 0, heatmap.clientWidth, heatmap.clientHeight);
    }

    // ØªØºÙŠÙŠØ± colormap Ø¯ÙˆÙ† Ø¥Ø¹Ø§Ø¯Ø© Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© (ÙŠØ¹ÙŠØ¯ Ø±Ø³Ù… heatmap ÙˆÙŠØ­Ø¯Ù‘Ø« Ø£Ù„ÙˆØ§Ù† Ø§Ù„Ù€ mesh)
    function setColormap(map){
      currentColormap = map;
      // Ù†Ø­Ø¯Ù‘Ø« Ø§Ù„Ù€ mesh Ø§Ù„Ø£Ù„ÙˆØ§Ù† Ø¥Ø°Ø§ Ù…ÙˆØ¬ÙˆØ¯
      if (mesh && mesh.geometry && mesh.geometry.attributes.color){
        const colorAttr = mesh.geometry.attributes.color;
        const count = colorAttr.count;
        for (let i=0;i<count;i++){
          const x = (i % (mesh.geometry.parameters.widthSegments + 1));
          const y = Math.floor(i / (mesh.geometry.parameters.widthSegments + 1));
          // Ù‚ÙŠÙ…Ø© ØªÙ‚Ø±ÙŠØ¨ÙŠÙ‘Ø© Ù„Ù†Ø³ØªØ®Ø±Ø¬Ù‡Ø§ Ù…Ù† pos.z
          const z = mesh.geometry.attributes.position.array[i*3 + 2];
          // value in [0..1] approx:
          const value = Math.max(0, Math.min(1, z / 80)); // ÙŠØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ scaleZ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ø¹Ù„Ù‰
          const c = getHeatColor(value, currentColormap);
          colorAttr.array[i*3+0] = c.r/255;
          colorAttr.array[i*3+1] = c.g/255;
          colorAttr.array[i*3+2] = c.b/255;
        }
        colorAttr.needsUpdate = true;
      }
      // redraw full-res heatmap if raw data available
      if (heightRaw && heightW && heightH){
        // need min/max: recompute quickly from raw
        let min=255,max=0;
        for (let i=0;i<heightRaw.length;i+=4){
          const b = heightRaw[i];
          if (b < min) min = b;
          if (b > max) max = b;
        }
        drawHeatmapFromRaw(heightRaw, heightW, heightH, min, max);
      } else if (lastImage){
        // fallback: re-create from image (slower)
        createHeightMap(lastImage);
      }
    }

    // Ù†Ø§ÙØ°Ø© Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ©
    function animate(){
      requestAnimationFrame(animate);
      if (mesh){
        mesh.rotation.y += rotationSpeed;
      }
      renderer.render(scene, camera);
    }
    animate();

    // Ø£Ø­Ø¯Ø§Ø« DOM
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files[0];
      if (!f) return;
      const url = URL.createObjectURL(f);
      const img = new Image();
      img.onload = () => {
        // Ø­Ù…Ø§ÙŠØ© Ù…Ù† ØµÙˆØ± Ø¶Ø®Ù…Ø© Ø¬Ø¯Ø§Ù‹ ÙÙŠ Ø§Ù„Ø¹Ø±Ø¶
        const MAX_PREVIEW = 1600;
        let drawW = img.width, drawH = img.height;
        if (drawW > MAX_PREVIEW){
          const r = MAX_PREVIEW / drawW;
          drawW = MAX_PREVIEW;
          drawH = Math.round(drawH * r);
        }
        canvas2d.width = drawW;
        canvas2d.height = drawH;
        ctx2d.clearRect(0,0,drawW,drawH);
        ctx2d.imageSmoothingEnabled = true;
        ctx2d.drawImage(img, 0, 0, drawW, drawH);

        // Ù†Ø±ÙŠØ¯ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù€ heightmap Ù…Ù† Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© (full resolution)
        createHeightMap(img);

        URL.revokeObjectURL(url);
      };
      img.onerror = () => {
        URL.revokeObjectURL(url);
        alert('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©. Ø¬Ø±Ù‘Ø¨ ØµÙˆØ±Ø© Ù…Ø®ØªÙ„ÙØ©.');
      };
      img.src = url;
    });

    // ØªØ­ÙƒÙ‘Ù… Ø³Ø±Ø¹Ø© Ø§Ù„Ø¯ÙˆØ±Ø§Ù† ÙˆØ§Ù„ØªÙƒØ¨ÙŠØ±
    rotationSpeedInput.addEventListener('input', () => {
      rotationSpeed = parseFloat(rotationSpeedInput.value) || 0;
    });
    zoomControl.addEventListener('input', () => {
      const z = parseFloat(zoomControl.value) || 200;
      camera.position.z = z;
      camera.updateProjectionMatrix();
    });

    // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø«ÙŠÙ…
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark');
      themeToggle.textContent = document.body.classList.contains('dark') ? "â˜€ï¸" : "ğŸŒ™";
    });

    // Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„Ø¯Ù‚Ø© ÙˆØ§Ù„Ø­Ø¬Ù… Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø© (renderer Ø«Ø§Ø¨Øª Ø§Ù„Ø­Ø¬Ù… Ù„ÙƒÙ† Ù†Ø¯Ø¹Ù… DPR)
    window.addEventListener('resize', () => {
      DPR = Math.min(window.devicePixelRatio || 1, 2);
      renderer.setPixelRatio(DPR);
      renderer.setSize(RENDER_SIZE, RENDER_SIZE, false);
    });

    // ØªÙ‡ÙŠØ¦Ø© Ø£ÙˆÙ„ÙŠØ©: Ø§Ø¶Ø¨Ø· Ø­Ø¬Ù… Ø§Ù„Ø¹Ù†ØµØ± renderer Ø¨Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø®ØµØµØ©
    (function initRendererSize(){
      renderer.setPixelRatio(DPR);
      renderer.setSize(RENDER_SIZE, RENDER_SIZE, false);
    })();

  </script>
</body>
</html>
