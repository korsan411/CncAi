<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>CNC AI â€” Fixed & Improved</title>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.150.1/examples/js/controls/OrbitControls.js"></script>
  <!-- OpenCV (async) -->
  <script async src="https://docs.opencv.org/4.8.0/opencv.js"></script>

  <style>
    :root{
      --bg:#041022; --panel:#0b1320; --muted:#9bb0c8; --accent:#06b6d4; --text:#e6eef6; --card-border:#1e293b;
    }
    body{ margin:0; font-family:Arial,Segoe UI,system-ui; background:var(--bg); color:var(--text); }
    header{ display:flex; justify-content:space-between; align-items:center; padding:12px 16px; border-bottom:1px solid var(--card-border); }
    .app{ max-width:1400px; margin:16px auto; padding:14px; }
    .grid{ display:grid; grid-template-columns:1fr 420px; gap:16px; }
    @media(max-width:1000px){ .grid{ grid-template-columns:1fr; } }
    .panel{ background:var(--panel); padding:14px; border-radius:10px; border:1px solid var(--card-border); }
    .tabs{ display:flex; gap:6px; border-bottom:1px solid var(--card-border); margin-top:12px;}
    .tabs button{ padding:8px 12px; border-radius:6px 6px 0 0; border:none; background:transparent; color:var(--muted); cursor:pointer; }
    .tabs button.active{ background:var(--accent); color:#021; }
    .tab-content{ display:none; margin-top:12px; }
    .tab-content.active{ display:block; }
    .canvas-placeholder{ width:100%; height:300px; background:#000; border-radius:6px; display:flex; align-items:center; justify-content:center; color:var(--muted); border:1px solid #334155; }
    canvas{ display:block; border-radius:6px; background:#000; max-width:100%; border:1px solid #334155; transform-origin: top left; }
    .file-input-container{ position:relative; width:100%; margin-bottom:8px; }
    .file-input-label{ display:block; padding:10px; background:#1e293b; color:var(--text); text-align:center; border-radius:6px; cursor:pointer; border:2px dashed #334155; }
    .controls-row{ display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap;}
    label{ font-weight:bold; color:var(--text); display:block; margin-top:8px; }
    input, select{ padding:8px 10px; border-radius:6px; border:1px solid var(--card-border); background:#0f172a; color:var(--text); margin-top:6px; }
    .button-group{ display:flex; flex-direction:column; gap:8px; margin-top:12px; }
    button.primary{ background:var(--accent); color:#021; border:none; padding:10px; border-radius:8px; cursor:pointer; }
    button.secondary{ background:#1e293b; color:var(--text); border:none; padding:10px; border-radius:8px; cursor:pointer; }
    #toast{ position:fixed; left:16px; bottom:16px; background:rgba(0,0,0,0.85); color:#fff; padding:10px 14px; border-radius:8px; display:none; z-index:10000; }
    .progress-bar{ width:100%; height:8px; background:#111827; border-radius:6px; overflow:hidden; margin-top:8px; }
    .progress-fill{ height:100%; width:0%; background:var(--accent); transition:width .2s; }
    .meta-line{ font-size:0.85rem; color:var(--muted); margin-top:8px; }
    #threeContainer{ width:100%; height:400px; background:#081224; border-radius:8px; overflow:hidden; position:relative; }
    .simulation-controls{ position:absolute; top:10px; left:10px; z-index:100; display:flex; gap:8px; }
    .simulation-info{ position:absolute; bottom:10px; left:10px; background:rgba(0,0,0,0.6); color:white; padding:8px 12px; border-radius:4px; font-size:0.8rem; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1 style="margin:0; color:var(--accent)">CNC AI â€” Fixed</h1>
      <div style="display:flex; gap:10px; align-items:center;">
        <div id="cvState"><span style="display:inline-block;width:14px;height:14px;border:2px solid var(--accent);border-radius:50%;margin-left:8px"></span> Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ OpenCV...</div>
        <button id="themeToggle" title="ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø«ÙŠÙ…">ğŸŒ—</button>
      </div>
    </header>

    <div class="grid">
      <!-- left panel: preview -->
      <div class="panel">
        <div class="file-input-container">
          <input id="fileInput" type="file" accept="image/*" style="opacity:0; position:absolute; left:0; top:0; width:100%; height:100%; cursor:pointer;"/>
          <label class="file-input-label" for="fileInput">ğŸ“ Ø§Ø®ØªØ± ØµÙˆØ±Ø© Ù„Ù„ØªØ­Ù…ÙŠÙ„</label>
        </div>
        <div class="meta-line" id="imageMeta">Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ù…Ø­Ù…Ù„Ø©</div>

        <div class="tabs">
          <button data-tab="original" class="active">ğŸ–¼ï¸ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©</button>
          <button data-tab="heatmap">ğŸ”¥ Heatmap</button>
          <button data-tab="contour">ğŸ“ ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù</button>
          <button data-tab="simulation">ğŸ¬ Ù…Ø­Ø§ÙƒØ§Ø© 3D</button>
        </div>

        <div id="original" class="tab-content active">
          <div class="canvas-placeholder" id="originalPlaceholder">Ø³ÙŠØªÙ… Ø¹Ø±Ø¶ Ø§Ù„ØµÙˆØ±Ø© Ù‡Ù†Ø§</div>
          <canvas id="canvasOriginal" style="display:none;"></canvas>
          <div class="controls-row">
            <button id="origZoomIn" class="secondary">+</button>
            <button id="origZoomOut" class="secondary">âˆ’</button>
            <button id="origReset" class="secondary">âŸ²</button>
            <label style="margin-left:8px"><input type="checkbox" id="autoResize" checked/> Ø¶ØºØ· ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù„ØµÙˆØ±Ø©</label>
          </div>
        </div>

        <div id="heatmap" class="tab-content">
          <div class="canvas-placeholder" id="heatmapPlaceholder">Heatmap Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
          <canvas id="canvasHeatmap" style="display:none;"></canvas>
          <div class="controls-row">
            <button id="heatZoomIn" class="secondary">+</button>
            <button id="heatZoomOut" class="secondary">âˆ’</button>
            <button id="heatReset" class="secondary">âŸ²</button>
            <label>Colormap:
              <select id="colormapSelect">
                <option value="jet">Jet</option>
                <option value="hot">Hot</option>
                <option value="cool">Cool</option>
                <option value="gray">Gray</option>
              </select>
            </label>
          </div>
        </div>

        <div id="contour" class="tab-content">
          <div class="canvas-placeholder" id="contourPlaceholder">Contour Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§</div>
          <canvas id="canvasContour" style="display:none;"></canvas>
          <div class="controls-row">
            <button id="contZoomIn" class="secondary">+</button>
            <button id="contZoomOut" class="secondary">âˆ’</button>
            <button id="contReset" class="secondary">âŸ²</button>
            <label><input type="checkbox" id="showAllContours" checked/> Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ±Ø§Øª Ø§Ù„ØªÙØµÙŠÙ„ÙŠØ©</label>
          </div>
        </div>

        <div id="simulation" class="tab-content">
          <div id="threeContainer">
            <div class="canvas-placeholder" id="simulationPlaceholder">Ù…Ø­Ø§ÙƒØ§Ø© 3D Ø³ØªØ¸Ù‡Ø± Ù‡Ù†Ø§ Ø¨Ø¹Ø¯ ØªÙˆÙ„ÙŠØ¯ G-code</div>
          </div>
        </div>
      </div>

      <!-- right panel: settings -->
      <div class="panel">
        <h3 style="margin-top:0;color:var(--muted)">âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª</h3>

        <label>Ù†ÙˆØ¹ Ø§Ù„Ù…Ø§ÙƒÙŠÙ†Ø©</label>
        <select id="machineType">
          <option value="router">Router CNC</option>
          <option value="laser">Laser Engraver</option>
          <option value="plasma">Plasma Cutter</option>
          <option value="3dprinter">3D Printer</option>
        </select>
        <div id="machineDescription" class="meta-line">Router CNC - Ø§ÙØªØ±Ø§Ø¶ÙŠ</div>

        <label>Ø¹Ø±Ø¶ Ø§Ù„Ø¹Ù…Ù„ (Ø³Ù…)</label>
        <input id="workWidth" type="number" value="30" step="0.1"/>
        <label>Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø¹Ù…Ù„ (Ø³Ù…)</label>
        <input id="workHeight" type="number" value="20" step="0.1"/>
        <label>Ø¹Ù…Ù‚ Ø§Ù„Ø¹Ù…Ù„ (Ù…Ù…)</label>
        <input id="workDepth" type="number" value="3.0" step="0.1"/>

        <label>Ø³Ø±Ø¹Ø© Ø§Ù„ØªØºØ°ÙŠØ© (Ù…Ù…/Ø¯Ù‚ÙŠÙ‚Ø©)</label>
        <input id="feedRate" type="number" value="800" />
        <label>Ø§Ø±ØªÙØ§Ø¹ Ø§Ù„Ø£Ù…Ø§Ù† (Ù…Ù…)</label>
        <input id="safeZ" type="number" value="5" step="0.1"/>
        <label>Ø®Ø·ÙˆØ© Ø§Ù„Ù…Ø³Ø­ (Ù…Ù…)</label>
        <input id="stepOver" type="number" value="5" step="0.1"/>
        <label>Ø£Ù‚ØµÙ‰ Ø¹Ù…Ù‚ (Ù…Ù…)</label>
        <input id="maxDepth" type="number" value="3.0" step="0.1"/>

        <div style="margin-top:10px;" class="controls-row">
          <button id="btnGen" class="primary">âš¡ ØªÙˆÙ„ÙŠØ¯ G-code</button>
          <button id="btnQuick" class="secondary">ğŸ§ª ØªÙˆÙ„ÙŠØ¯ Ø³Ø±ÙŠØ¹</button>
          <button id="btnDownload" class="secondary">ğŸ’¾ ØªØ­Ù…ÙŠÙ„ G-code</button>
        </div>

        <div class="progress-bar" aria-hidden="true"><div class="progress-fill" id="procFill"></div></div>
        <div id="estTime" class="meta-line"></div>

        <label style="margin-top:12px">ğŸ“„ Ù…Ø®Ø±Ø¬Ø§Øª G-code</label>
        <textarea id="gcodeOut" readonly style="width:100%;height:180px;background:#021024;color:#cfeaf2;border-radius:8px;border:1px solid var(--card-border);padding:8px;"></textarea>
      </div>
    </div>
  </div>

  <div id="toast"></div>

  <script>
  // ========= Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø© =========
  let cvReady = false;
  let grayMat = null;
  let mainContour = null;
  let extraContours = [];
  let previewCanvas = null;

  // Ø«ÙŠÙ…
  const themeToggle = document.getElementById('themeToggle');
  themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('light-theme');
    // Simple visual invert for demo:
    if (document.body.classList.contains('light-theme')) {
      document.documentElement.style.setProperty('--bg','#f4f7fb');
      document.documentElement.style.setProperty('--panel','#ffffff');
      document.documentElement.style.setProperty('--text','#042233');
      document.documentElement.style.setProperty('--muted','#5b6b78');
    } else {
      document.documentElement.style.setProperty('--bg','#041022');
      document.documentElement.style.setProperty('--panel','#0b1320');
      document.documentElement.style.setProperty('--text','#e6eef6');
      document.documentElement.style.setProperty('--muted','#9bb0c8');
    }
  });

  // toast
  function showToast(msg, ms = 2500) {
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.style.display = 'block';
    clearTimeout(t._t);
    t._t = setTimeout(()=> t.style.display='none', ms);
  }

  // wait for opencv runtime
  function onOpenCvReady() {
    cvReady = true;
    document.getElementById('cvState').innerText = 'âœ… OpenCV Ø¬Ø§Ù‡Ø²';
    showToast('OpenCV Ø¬Ø§Ù‡Ø²');
  }
  // opencv will call this (if built that way) â€” but ensure fallback:
  if (typeof cv !== 'undefined') {
    if (cv && cv.onRuntimeInitialized !== undefined) {
      cv['onRuntimeInitialized'] = onOpenCvReady;
    } else {
      // if not ready yet, poll
      const t = setInterval(() => {
        if (typeof cv !== 'undefined' && cv.getBuildInformation) {
          clearInterval(t);
          onOpenCvReady();
        }
      },100);
    }
  } else {
    // poll until script loaded
    const t2 = setInterval(()=> {
      if (typeof cv !== 'undefined' && cv.getBuildInformation) {
        clearInterval(t2);
        if (cv.onRuntimeInitialized !== undefined) cv['onRuntimeInitialized'] = onOpenCvReady;
        else onOpenCvReady();
      }
    }, 200);
  }

  // Tabs
  document.querySelectorAll('.tabs button').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tabs button').forEach(b=>b.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(tc=>tc.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById(btn.dataset.tab).classList.add('active');
      if (btn.dataset.tab === 'simulation' && document.getElementById('gcodeOut').value) {
        initSimulation();
      }
    });
  });

  // Zoom helpers (scale transform)
  function applyZoom(canvasId, scale) {
    const c = document.getElementById(canvasId);
    c.style.transform = `scale(${scale})`;
    c._scale = scale;
  }
  function wireZoom(inId, outId, resetId, canvasId) {
    let s = 1;
    document.getElementById(inId).addEventListener('click', () => { s = Math.min(4, s+0.25); applyZoom(canvasId, s);});
    document.getElementById(outId).addEventListener('click', () => { s = Math.max(0.25, s-0.25); applyZoom(canvasId, s);});
    document.getElementById(resetId).addEventListener('click', () => { s = 1; applyZoom(canvasId, s);});
  }
  wireZoom('origZoomIn','origZoomOut','origReset','canvasOriginal');
  wireZoom('heatZoomIn','heatZoomOut','heatReset','canvasHeatmap');
  wireZoom('contZoomIn','contZoomOut','contReset','canvasContour');

  // File input handling
  document.getElementById('fileInput').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    if (!file.type.match('image.*')) { showToast('Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù ØµÙˆØ±Ø©'); return; }
    const img = new Image();
    img.onload = () => {
      previewCanvas = document.getElementById('canvasOriginal');
      const ctx = previewCanvas.getContext('2d');

      let w = img.width, h = img.height;
      const auto = document.getElementById('autoResize').checked;
      const maxW = auto ? 1000 : 1600;
      const maxH = auto ? 700 : 1200;

      if (w > maxW) { h = Math.round((maxW / w) * h); w = maxW; }
      if (h > maxH) { w = Math.round((maxH / h) * w); h = maxH; }

      previewCanvas.width = w; previewCanvas.height = h;
      ctx.clearRect(0,0,w,h);
      ctx.drawImage(img,0,0,w,h);
      document.getElementById('originalPlaceholder').style.display = 'none';
      previewCanvas.style.display = 'block';
      document.getElementById('imageMeta').textContent = `Ø­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø£ØµÙ„ÙŠ: ${img.width}Ã—${img.height} â€” Ù„Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©: ${w}Ã—${h}`;

      // cleanup old mats
      if (grayMat) { try { grayMat.delete(); } catch(e){} grayMat = null; }
      mainContour = null; extraContours = [];

      if (cvReady) detectContours();
      else {
        showToast('Ø¬Ø§Ø±ÙŠ Ø§Ù†ØªØ¸Ø§Ø± OpenCV...');
        const t = setInterval(()=>{ if (cvReady) { clearInterval(t); detectContours(); } },200);
      }
    };
    img.onerror = () => showToast('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©');
    img.src = URL.createObjectURL(file);
  });

  // detectContours: uses OpenCV to compute gray, edges, contours
  function detectContours() {
    try {
      if (!cvReady) { showToast('OpenCV ØºÙŠØ± Ø¬Ø§Ù‡Ø²'); return; }
      showToast('Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©...');
      const src = cv.imread(previewCanvas);
      const gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

      const blurred = new cv.Mat();
      cv.GaussianBlur(gray, blurred, new cv.Size(5,5), 0);

      const edges = new cv.Mat();
      const median = cv.mean(blurred).w;
      const lower = Math.max(0, (1.0 - 0.33) * median);
      const upper = Math.min(255, (1.0 + 0.33) * median);
      cv.Canny(blurred, edges, lower, upper);

      const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3,3));
      cv.morphologyEx(edges, edges, cv.MORPH_CLOSE, kernel);

      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);

      const minArea = (gray.cols * gray.rows) * 0.005; // 0.5% tolerance
      const valids = [];
      for (let i=0;i<contours.size();i++) {
        const c = contours.get(i);
        const area = cv.contourArea(c);
        if (area > minArea) {
          valids.push({contour: c, area});
        } else {
          c.delete();
        }
      }

      if (valids.length === 0) {
        showToast('Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ÙƒÙˆÙ†ØªÙˆØ± ÙƒØ§ÙÙ');
      } else {
        valids.sort((a,b)=> b.area - a.area);
        mainContour = valids[0].contour;
        extraContours = valids.slice(1).map(v=>v.contour);
        showToast(`ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${valids.length} ÙƒÙˆÙ†ØªÙˆØ± â€” Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£ÙƒØ¨Ø± ÙƒØ£Ø³Ø§Ø³`);
      }

      if (grayMat) { try{ grayMat.delete(); } catch(e){} }
      grayMat = gray.clone();

      renderHeatmap(grayMat);
      renderContours(grayMat, mainContour);

      // cleanup
      src.delete(); blurred.delete(); edges.delete(); hierarchy.delete(); contours.delete(); kernel.delete();
      // Note: mainContour kept for later (do not delete)
    } catch (err) {
      console.error(err);
      showToast('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: ' + (err.message || err));
    }
  }

  // renderHeatmap with simple colormaps
  function renderHeatmap(gray) {
    const c = document.getElementById('canvasHeatmap');
    const ctx = c.getContext('2d');
    c.width = gray.cols; c.height = gray.rows;
    const img = ctx.createImageData(c.width, c.height);
    const data = gray.data;
    const cmap = document.getElementById('colormapSelect').value;

    for (let i=0;i<data.length;i++) {
      const v = data[i];
      const idx = i*4;
      let r=0,g=0,b=0;
      if (cmap === 'jet') {
        // rough jet
        r = Math.max(0, Math.min(255, (v-128)*2 ));
        g = Math.max(0, Math.min(255, 255 - Math.abs(v-128)*2 ));
        b = Math.max(0, Math.min(255, (128-v)*2 ));
      } else if (cmap === 'hot') {
        r = v; g = Math.round(v*0.5); b = Math.round(v*0.1);
      } else if (cmap === 'cool') {
        r = 255 - v; g = v; b = 255;
      } else {
        r=g=b=v;
      }
      img.data[idx] = r; img.data[idx+1] = g; img.data[idx+2] = b; img.data[idx+3] = 255;
    }
    ctx.putImageData(img, 0, 0);
    document.getElementById('heatmapPlaceholder').style.display = 'none';
    c.style.display = 'block';
  }

  // renderContours: draw heatmap then overlay contour lines
  function renderContours(gray, mainCnt) {
    const c = document.getElementById('canvasContour');
    const ctx = c.getContext('2d');
    c.width = gray.cols; c.height = gray.rows;
    // draw heatmap as background
    const heat = document.getElementById('canvasHeatmap');
    if (heat.width !== c.width || heat.height !== c.height) {
      // regenerate heatmap if needed
      renderHeatmap(gray);
    }
    ctx.clearRect(0,0,c.width,c.height);
    ctx.drawImage(heat, 0, 0);

    if (mainCnt) {
      ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 2;
      ctx.beginPath();
      const data = mainCnt.data32S;
      for (let i=0;i<data.length;i+=2) {
        const x = data[i], y = data[i+1];
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath(); ctx.stroke();
    }
    if (document.getElementById('showAllContours').checked) {
      ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 1;
      extraContours.forEach(cnt => {
        ctx.beginPath();
        const d = cnt.data32S;
        for (let i=0;i<d.length;i+=2) {
          const x = d[i], y = d[i+1];
          if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.closePath(); ctx.stroke();
      });
    }
    document.getElementById('contourPlaceholder').style.display = 'none';
    c.style.display = 'block';
  }

  // helper: extract polygon points from contour (convert to simple array)
  function contourToArray(cnt) {
    if (!cnt) return [];
    const pts = [];
    const data = cnt.data32S;
    for (let i=0;i<data.length;i+=2) pts.push([data[i], data[i+1]]);
    return pts;
  }

  // point in polygon (ray-casting) used in worker too (but worker has its own copy)
  function pointInPoly(x,y,poly) {
    let inside = false;
    for (let i=0,j=poly.length-1;i<poly.length;j=i++) {
      const xi=poly[i][0], yi=poly[i][1];
      const xj=poly[j][0], yj=poly[j][1];
      const intersect = ((yi>y)!==(yj>y)) && (x < (xj - xi)*(y - yi)/(yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  // Create worker for G-code generation â€” worker will receive gray buffer, contour polygon, settings
  function createGcodeWorker() {
    const code = `
      // simple ray-casting point-in-polygon
      function pointInPoly(x,y,poly) {
        let inside=false;
        for(let i=0,j=poly.length-1;i<poly.length;j=i++){
          const xi=poly[i][0], yi=poly[i][1];
          const xj=poly[j][0], yj=poly[j][1];
          const intersect = ((yi>y)!==(yj>y)) && (x < (xj - xi)*(y - yi)/(yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      onmessage = function(e) {
        try {
          const { buf, width, height, poly, params } = e.data;
          const step = Math.max(1, Math.round(params.stepOver)); // pixels per step
          const feed = params.feed;
          const safeZ = params.safeZ;
          const maxDepth = params.maxDepth;
          const includeComments = params.includeComments;
          const originX = params.originX;
          const originY = params.originY;
          const invertZ = params.invertZ;

          const lines = [];
          lines.push('; G21 G90 G17');
          lines.push('G0 Z' + safeZ.toFixed(2));

          // bounding box of polygon to reduce scanning
          let minX = width, minY = height, maxX = 0, maxY = 0;
          for (const p of poly) { if (p[0]<minX) minX=p[0]; if(p[0]>maxX) maxX=p[0]; if(p[1]<minY) minY=p[1]; if(p[1]>maxY) maxY=p[1]; }

          let total = 0;
          const estTotalRows = Math.ceil((maxY - minY)/step) || 1;
          for (let ry=minY, rIdx=0; ry<=maxY; ry += step, rIdx++) {
            const points = [];
            for (let x=minX; x<=maxX; x++) {
              if (((x - minX) % 1) !== 0) {} // no-op: iterate integer x
              const px = x, py = ry;
              if (pointInPoly(px,py,poly)) {
                // sample gray at integer coords: buf[py*width + px]
                const pv = buf[py*width + px];
                let z = -((255 - pv)/255.0) * maxDepth;
                if (invertZ) z = -z;
                // scale X/Y to machine space will be applied in main thread (we can pack pixel coords)
                points.push({x:px, y:py, z:z});
              }
            }
            if (points.length>0) {
              // create passes
              // go to first point at safeZ
              lines.push(includeComments ? ('; Row Y=' + ry) : '');
              lines.push('G0 X' + (points[0].x).toFixed(2) + ' Y' + (points[0].y).toFixed(2) + ' Z' + safeZ.toFixed(2));
              lines.push('G1 F' + feed);
              for (const p of points) {
                lines.push('G1 X' + p.x.toFixed(2) + ' Y' + p.y.toFixed(2) + ' Z' + p.z.toFixed(3));
              }
              lines.push('G0 Z' + safeZ.toFixed(2));
            }
            total += points.length;
            if (rIdx % Math.max(1,Math.floor(estTotalRows/20)) === 0) {
              const prog = Math.round(( (ry - minY) / Math.max(1, (maxY-minY)) ) * 100);
              postMessage({ type:'progress', progress: Math.min(100, Math.max(0, prog)) });
            }
          }

          lines.push('M5');
          lines.push('M30');
          postMessage({ type:'done', gcode: lines.join('\\n'), stats:{ totalPoints: total } });
        } catch (err) {
          postMessage({ type:'error', message: err.message || err });
        }
      };
    `;
    const blob = new Blob([code], { type:'application/javascript' });
    return new Worker(URL.createObjectURL(blob));
  }

  // generateRasterGcodeAsync: prepare data and call worker
  async function generateRasterGcodeAsync() {
    if (!grayMat || !mainContour) { showToast('Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ§ÙÙŠØ© (Ø­ÙÙ…Ù‘Ù„ ØµÙˆØ±Ø© ÙˆØ§ÙƒØ´Ù Ø§Ù„Ø­ÙˆØ§Ù)'); return ''; }
    const w = grayMat.cols, h = grayMat.rows;
    // copy grayscale to buffer
    const buf = new Uint8ClampedArray(w*h);
    for (let i=0;i<w*h;i++) buf[i] = grayMat.data[i];

    // contour poly array
    const poly = contourToArray(mainContour);
    if (poly.length < 3) { showToast('Ø§Ù„ÙƒÙˆÙ†ØªÙˆØ± ØºÙŠØ± ÙƒØ§ÙÙ'); return ''; }

    // params
    const feed = parseFloat(document.getElementById('feedRate').value) || 800;
    const safeZ = parseFloat(document.getElementById('safeZ').value) || 5;
    const stepOver = parseFloat(document.getElementById('stepOver').value) || 5;
    const maxDepth = parseFloat(document.getElementById('maxDepth').value) || 3;
    const includeComments = true;
    const invertZ = false;

    // show progress
    const procFill = document.getElementById('procFill');
    procFill.style.width = '0%';

    return new Promise((resolve) => {
      const worker = createGcodeWorker();
      worker.onmessage = function(ev) {
        const d = ev.data;
        if (d.type === 'progress') {
          procFill.style.width = d.progress + '%';
        } else if (d.type === 'done') {
          procFill.style.width = '100%';
          // Now translate pixel X/Y to machine coordinates scale
          const workWidth = (parseFloat(document.getElementById('workWidth').value) || 30) * 10; // mm
          const workHeight = (parseFloat(document.getElementById('workHeight').value) || 20) * 10; // mm
          const originX = 0; const originY = 0; // for now
          const scaleX = workWidth / w;
          const scaleY = workHeight / h;
          // replace X Y numeric values in G-code lines which are in pixel units to machine mm using regex
          let g = d.gcode.split('\\n').map(line => {
            // convert lines like G1 X123.00 Y45.00 Z...
            const xm = line.match(/X([\\d.-]+)/); const ym = line.match(/Y([\\d.-]+)/);
            if (xm && ym) {
              const px = parseFloat(xm[1]); const py = parseFloat(ym[1]);
              const mx = (px * scaleX) + originX; const my = (py * scaleY) + originY;
              line = line.replace(/X[\\d.-]+/, 'X' + mx.toFixed(2));
              line = line.replace(/Y[\\d.-]+/, 'Y' + my.toFixed(2));
            }
            return line;
          }).join('\\n');
          // Estimate time simple (count movement lines / feed)
          document.getElementById('estTime').textContent = `â±ï¸ Ù…Ø®Ø±Ø¬Ø§Øª ØªÙ‚Ø±ÙŠØ¨ÙŠØ© â€” Ù†Ù‚Ø§Ø·: ${d.stats.totalPoints}`;
          worker.terminate();
          resolve(g);
        } else if (d.type === 'error') {
          showToast('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù€ Worker: ' + d.message);
          worker.terminate();
          resolve('');
        }
      };

      worker.postMessage({ buf: buf, width: w, height: h, poly: poly, params: { feed, safeZ, stepOver, maxDepth, includeComments, invertZ, originX:0, originY:0 } });
    });
  }

  // Buttons
  document.getElementById('btnGen').addEventListener('click', async () => {
    document.getElementById('gcodeOut').value = '';
    const g = await generateRasterGcodeAsync();
    if (g) {
      document.getElementById('gcodeOut').value = g;
      showToast('ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code');
      // switch to simulation tab automatically
      document.querySelector('[data-tab="simulation"]').click();
    } else {
      showToast('ÙØ´Ù„ ØªÙˆÙ„ÙŠØ¯ G-code');
    }
  });

  document.getElementById('btnQuick').addEventListener('click', async () => {
    document.getElementById('gcodeOut').value = '';
    const prevStep = document.getElementById('stepOver').value;
    document.getElementById('stepOver').value = Math.max(1, parseFloat(prevStep)*2);
    const g = await generateRasterGcodeAsync();
    document.getElementById('stepOver').value = prevStep;
    if (g) {
      document.getElementById('gcodeOut').value = g;
      showToast('ØªÙ… ØªÙˆÙ„ÙŠØ¯ G-code Ø³Ø±ÙŠØ¹');
      document.querySelector('[data-tab="simulation"]').click();
    }
  });

  document.getElementById('btnDownload').addEventListener('click', () => {
    const text = document.getElementById('gcodeOut').value;
    if (!text) { showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„ØªØ­Ù…ÙŠÙ„'); return; }
    const blob = new Blob([text], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'cnc_output.gcode';
    document.body.appendChild(a); a.click(); document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù');
  });

  // Basic 3D simulation (reads G-code text)
  let scene, camera, renderer, controls;
  function parseGcodeForSimulation(gcode) {
    const lines = gcode.split('\\n');
    const path = [];
    let pos = { x:0, y:0, z:0 };
    for (const L of lines) {
      const t = L.trim();
      if (t.startsWith('G1') || t.startsWith('G0')) {
        const xm = t.match(/X([\\d.-]+)/); const ym = t.match(/Y([\\d.-]+)/); const zm = t.match(/Z([\\d.-]+)/);
        if (xm) pos.x = parseFloat(xm[1]);
        if (ym) pos.y = parseFloat(ym[1]);
        if (zm) pos.z = parseFloat(zm[1]);
        path.push({ ...pos });
      }
    }
    return path;
  }

  function createToolPathVisualization(pathPoints) {
    if (!pathPoints || pathPoints.length < 2) return;
    const points = pathPoints.map(p => new THREE.Vector3(p.x, p.z + 5, p.y));
    const geometry = new THREE.BufferGeometry().setFromPoints(points);
    const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
    const line = new THREE.Line(geometry, material);
    scene.add(line);
  }

  function createToolModel() {
    const g = new THREE.Group();
    const geom = new THREE.CylinderGeometry(2,2,20,12);
    const mat = new THREE.MeshPhongMaterial({ color: 0xff4444 });
    const mesh = new THREE.Mesh(geom, mat);
    g.add(mesh);
    const tipGeom = new THREE.ConeGeometry(3,8,12);
    const tip = new THREE.Mesh(tipGeom, new THREE.MeshPhongMaterial({ color: 0xffff00 }));
    tip.position.y = -14;
    g.add(tip);
    return g;
  }

  function initSimulation() {
    const container = document.getElementById('threeContainer');
    container.innerHTML = '';
    const gcode = document.getElementById('gcodeOut').value;
    if (!gcode) { document.getElementById('simulationPlaceholder').style.display = 'flex'; showToast('Ù„Ø§ ÙŠÙˆØ¬Ø¯ G-code Ù„Ù„Ù…Ø­Ø§ÙƒØ§Ø©'); return; }
    try {
      document.getElementById('simulationPlaceholder').style.display = 'none';
      scene = new THREE.Scene(); scene.background = new THREE.Color(0x081224);
      camera = new THREE.PerspectiveCamera(60, container.clientWidth/container.clientHeight, 0.1, 10000);
      camera.position.set(200,200,200);
      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
      controls = new THREE.OrbitControls(camera, renderer.domElement);

      const ambient = new THREE.AmbientLight(0x404040, 0.8); scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(50,200,100); scene.add(dir);

      // workpiece box
      const workW = (parseFloat(document.getElementById('workWidth').value)||30)*10;
      const workH = (parseFloat(document.getElementById('workHeight').value)||20)*10;
      const workD = parseFloat(document.getElementById('workDepth').value)||3;
      const geom = new THREE.BoxGeometry(workW, workD, workH);
      const mat = new THREE.MeshPhongMaterial({ color: 0x8B4513, transparent:true, opacity:0.95 });
      const box = new THREE.Mesh(geom, mat); box.position.y = workD/2; scene.add(box);

      const path = parseGcodeForSimulation(gcode);
      createToolPathVisualization(path);
      const tool = createToolModel(); scene.add(tool);

      const grid = new THREE.GridHelper(Math.max(workW, workH), 10); scene.add(grid);
      const axes = new THREE.AxesHelper(50); scene.add(axes);

      function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
      animate();
      showToast('ØªÙ… ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
    } catch (err) {
      console.error(err); showToast('Ø®Ø·Ø£ ÙÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©');
    }
  }

  // on show simulation tab, init if gcode present
  document.querySelector('[data-tab="simulation"]').addEventListener('click', () => {
    if (document.getElementById('gcodeOut').value) initSimulation();
  });

  // initial small helper: update machine desc on change
  document.getElementById('machineType').addEventListener('change', (e) => {
    const map = {
      router: 'Router CNC - Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ø®Ø´Ø¨',
      laser: 'Laser Engraver - Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ù†Ù‚Ø´',
      plasma: 'Plasma Cutter - Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ù‚Ø·Ø¹',
      '3dprinter': '3D Printer - Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ø·Ø¨Ø§Ø¹Ø©'
    };
    document.getElementById('machineDescription').textContent = map[e.target.value] || '';
  });

  </script>
</body>
</html>
