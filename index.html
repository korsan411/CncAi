<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CNC AI - Final Version</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background: #f9f9f9;
      color: #333;
    }
    header {
      background: linear-gradient(90deg, #2196f3, #21cbf3);
      color: #fff;
      text-align: center;
      padding: 1rem;
      font-size: 1.5rem;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      padding: 1rem;
    }
    canvas {
      border: 1px solid #ccc;
      border-radius: 8px;
      max-width: 100%;
    }
    #preview3d {
      width: 100%;
      height: 400px;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    .controls {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    button {
      padding: 10px;
      border: none;
      border-radius: 5px;
      background: #2196f3;
      color: #fff;
      cursor: pointer;
    }
    button:hover { background: #1976d2; }
    textarea {
      width: 100%;
      height: 200px;
      margin-top: 1rem;
      font-family: monospace;
      padding: 0.5rem;
    }
  </style>
</head>
<body>
<header>ğŸ› ï¸ CNC AI - Final Version</header>

<div class="container">
  <div>
    <h3>ğŸ“¤ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©</h3>
    <input type="file" id="fileInput" accept="image/*">
    <canvas id="inputCanvas"></canvas>
    <h3>ğŸŒˆ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª</h3>
    <canvas id="heatmapCanvas"></canvas>
    <div class="controls">
      <label>Ø´Ø¯Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ (Z)
        <input type="range" id="zScale" min="10" max="300" value="80">
      </label>
      <button onclick="extractEdges()">ğŸ” Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­ÙˆØ§Ù</button>
      <button onclick="generateGCode()">âš¡ ØªÙˆÙ„ÙŠØ¯ G-code</button>
      <button onclick="downloadGCode()">ğŸ’¾ Ø­ÙØ¸ G-code</button>
    </div>
  </div>

  <div>
    <h3>ğŸŒ€ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø«Ù„Ø§Ø«ÙŠØ© Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</h3>
    <div id="preview3d"></div>
    <textarea id="gcodeOutput" readonly></textarea>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/* ----------------------------
   Ø¹Ù†Ø§ØµØ± DOM
---------------------------- */
const fileInput = document.getElementById("fileInput");
const inputCanvas = document.getElementById("inputCanvas");
const ctxInput = inputCanvas.getContext("2d");
const heatmapCanvas = document.getElementById("heatmapCanvas");
const ctxHeatmap = heatmapCanvas.getContext("2d");
const gcodeOutput = document.getElementById("gcodeOutput");
const zScaleInput = document.getElementById("zScale");

/* ----------------------------
   Ø¨ÙŠØ§Ù†Ø§Øª
---------------------------- */
let imageWidth = 0, imageHeight = 0;
let heightMap = null;       // Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª
let edgePaths = [];         // Ù…Ø³Ø§Ø±Ø§Øª Ø§Ù„Ø­ÙˆØ§Ù XY
let scene, camera, renderer, mesh;

/* ----------------------------
   ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
---------------------------- */
fileInput.addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const img = new Image();
  img.onload = () => {
    const maxWidth = 400;
    const scale = Math.min(1, maxWidth / img.width);
    imageWidth = Math.round(img.width * scale);
    imageHeight = Math.round(img.height * scale);

    inputCanvas.width = imageWidth;
    inputCanvas.height = imageHeight;
    ctxInput.drawImage(img, 0, 0, imageWidth, imageHeight);

    generateHeightMap();
    update3DPreview();
  };
  img.src = URL.createObjectURL(file);
});

/* ----------------------------
   Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª
---------------------------- */
function generateHeightMap() {
  const imageData = ctxInput.getImageData(0, 0, imageWidth, imageHeight);
  heightMap = new Float32Array(imageWidth * imageHeight);

  for (let i = 0, j = 0; i < imageData.data.length; i += 4, j++) {
    const gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
    heightMap[j] = gray / 255;
  }

  // Ø±Ø³Ù… heatmap
  heatmapCanvas.width = imageWidth;
  heatmapCanvas.height = imageHeight;
  const heatmapData = ctxHeatmap.createImageData(imageWidth, imageHeight);

  for (let i = 0; i < heightMap.length; i++) {
    const val = heightMap[i];
    const r = val * 255;
    const g = 0;
    const b = 255 - r;
    heatmapData.data[i * 4] = r;
    heatmapData.data[i * 4 + 1] = g;
    heatmapData.data[i * 4 + 2] = b;
    heatmapData.data[i * 4 + 3] = 255;
  }
  ctxHeatmap.putImageData(heatmapData, 0, 0);
}

/* ----------------------------
   Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­ÙˆØ§Ù (Sobel)
---------------------------- */
function extractEdges() {
  const imageData = ctxInput.getImageData(0, 0, imageWidth, imageHeight);
  const gray = new Uint8ClampedArray(imageWidth * imageHeight);

  for (let i = 0, j = 0; i < imageData.data.length; i += 4, j++) {
    gray[j] = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
  }

  const sobelX = [-1,0,1,-2,0,2,-1,0,1];
  const sobelY = [-1,-2,-1,0,0,0,1,2,1];
  const threshold = 100;
  edgePaths = [];

  for (let y = 1; y < imageHeight - 1; y++) {
    for (let x = 1; x < imageWidth - 1; x++) {
      let gx = 0, gy = 0;
      for (let ky = -1; ky <= 1; ky++) {
        for (let kx = -1; kx <= 1; kx++) {
          const idx = (y + ky) * imageWidth + (x + kx);
          const wX = sobelX[(ky + 1) * 3 + (kx + 1)];
          const wY = sobelY[(ky + 1) * 3 + (kx + 1)];
          gx += gray[idx] * wX;
          gy += gray[idx] * wY;
        }
      }
      const mag = Math.sqrt(gx * gx + gy * gy);
      if (mag > threshold) edgePaths.push({ x, y });
    }
  }

  alert(`ØªÙ… Ø§Ø³ØªØ®Ø±Ø§Ø¬ ${edgePaths.length} Ù†Ù‚Ø·Ø© Ø­Ø§ÙØ©`);
  update3DPreview();
}

/* ----------------------------
   ØªÙˆÙ„ÙŠØ¯ G-code ÙØ¹Ù„ÙŠ
   XY = Ø§Ù„Ø­ÙˆØ§Ù
   Z = Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª
---------------------------- */
function generateGCode() {
  if (!edgePaths.length || !heightMap) {
    alert("ÙŠØ¬Ø¨ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© ÙˆØ§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø­ÙˆØ§Ù Ø£ÙˆÙ„Ø§Ù‹");
    return;
  }

  const feedRate = 800;
  const safeZ = 5;
  const maxCutDepth = 2; 
  const zScale = parseFloat(zScaleInput.value);

  let gcode = `; G-code Generated by CNC AI\nG21 ; Units in mm\nG90 ; Absolute positioning\nG17\nG94\nF${feedRate}\nM3\nG0 Z${safeZ}\n`;

  let lastPos = null;
  edgePaths.forEach(pt => {
    const idx = pt.y * imageWidth + pt.x;
    const zVal = (heightMap[idx] || 0) * zScale;
    const z = -Math.min(zVal, maxCutDepth).toFixed(3);

    if (!lastPos || Math.hypot(pt.x - lastPos.x, pt.y - lastPos.y) > 5) {
      gcode += `G0 X${pt.x.toFixed(2)} Y${pt.y.toFixed(2)} Z${safeZ}\n`;
      gcode += `G1 Z${z} F${feedRate / 2}\n`;
    } else {
      gcode += `G1 X${pt.x.toFixed(2)} Y${pt.y.toFixed(2)} Z${z}\n`;
    }
    lastPos = pt;
  });

  gcode += "G0 Z5\nM5\nG0 X0 Y0\nM30";
  gcodeOutput.value = gcode;

  update3DPreview(true); // Ø¹Ø±Ø¶ ToolPath
}

/* ----------------------------
   Ø­ÙØ¸ G-code
---------------------------- */
function downloadGCode() {
  const blob = new Blob([gcodeOutput.value], { type: "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "cnc_output.gcode";
  a.click();
  URL.revokeObjectURL(url);
}

/* ----------------------------
   Ù…Ø¹Ø§ÙŠÙ†Ø© 3D
---------------------------- */
function init3D() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f0f0);

  camera = new THREE.PerspectiveCamera(45, preview3d.offsetWidth / preview3d.offsetHeight, 0.1, 1000);
  camera.position.set(0, 200, 200);
  camera.lookAt(0, 0, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(preview3d.offsetWidth, preview3d.offsetHeight);
  document.getElementById("preview3d").appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(100, 200, 100);
  scene.add(light);

  scene.add(new THREE.AmbientLight(0x404040));
  scene.add(new THREE.GridHelper(200, 20));
}

function update3DPreview(showToolPath = false) {
  if (!scene) init3D();

  if (mesh) {
    scene.remove(mesh);
    mesh.geometry.dispose();
    mesh.material.dispose();
  }

  if (!heightMap) return;

  const maxSegments = 200;
  const segX = Math.min(imageWidth - 1, maxSegments);
  const segY = Math.min(imageHeight - 1, maxSegments);
  const geometry = new THREE.PlaneGeometry(imageWidth, imageHeight, segX, segY);

  const positions = geometry.attributes.position.array;
  let vIndex = 0;

  for (let y = 0; y <= segY; y++) {
    for (let x = 0; x <= segX; x++) {
      const imgX = Math.floor((x / segX) * (imageWidth - 1));
      const imgY = Math.floor((y / segY) * (imageHeight - 1));
      const idx = imgY * imageWidth + imgX;
      const z = heightMap[idx] * parseFloat(zScaleInput.value);

      positions[vIndex * 3 + 2] = z;
      vIndex++;
    }
  }

  geometry.computeVertexNormals();
  const texture = new THREE.CanvasTexture(heatmapCanvas);
  const material = new THREE.MeshPhongMaterial({ map: texture, side: THREE.DoubleSide });

  mesh = new THREE.Mesh(geometry, material);
  mesh.rotation.x = -Math.PI / 2;
  scene.add(mesh);

  if (showToolPath) {
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const points = edgePaths.map(pt => {
      const idx = pt.y * imageWidth + pt.x;
      const z = heightMap[idx] * parseFloat(zScaleInput.value);
      return new THREE.Vector3(pt.x - imageWidth/2, z, pt.y - imageHeight/2);
    });
    const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
    const line = new THREE.Line(lineGeometry, lineMaterial);
    scene.add(line);
  }

  renderer.render(scene, camera);
}

/* ----------------------------
   ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø¨Ø§Ø³ØªÙ…Ø±Ø§Ø±
---------------------------- */
function animate() {
  requestAnimationFrame(animate);
  if (mesh) mesh.rotation.y += 0.002;
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
